<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.10.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

  <meta name="description" content="Onwaier的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Onwaier&#39;s Blog">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Onwaier&#39;s Blog">
<meta property="og:description" content="Onwaier的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Onwaier">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Onwaier's Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Onwaier's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大步后退亦或停止不前，不如匍匐前进</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Onwaier</p>
  <div class="site-description" itemprop="description">Onwaier的个人博客</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Onwaier" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Onwaier" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:onwaier@163.com" title="E-Mail → mailto:onwaier@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/28/pytorch%E8%BD%BD%E5%85%A5%E9%83%A8%E5%88%86%E5%8F%82%E6%95%B0%E5%B9%B6%E5%86%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Onwaier">
      <meta itemprop="description" content="Onwaier的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Onwaier's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/28/pytorch%E8%BD%BD%E5%85%A5%E9%83%A8%E5%88%86%E5%8F%82%E6%95%B0%E5%B9%B6%E5%86%BB%E7%BB%93/" class="post-title-link" itemprop="url">Pytorch载入部分参数并冻结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-28 10:12:50" itemprop="dateCreated datePublished" datetime="2020-02-28T10:12:50+08:00">2020-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-02-13 14:29:47" itemprop="dateModified" datetime="2022-02-13T14:29:47+08:00">2022-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/pytorch/" itemprop="url" rel="index"><span itemprop="name">pytorch</span></a>
        </span>
    </span>

  
    <span id="/2020/02/28/pytorch%E8%BD%BD%E5%85%A5%E9%83%A8%E5%88%86%E5%8F%82%E6%95%B0%E5%B9%B6%E5%86%BB%E7%BB%93/" class="post-meta-item leancloud_visitors" data-flag-title="Pytorch载入部分参数并冻结" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/02/28/pytorch%E8%BD%BD%E5%85%A5%E9%83%A8%E5%88%86%E5%8F%82%E6%95%B0%E5%B9%B6%E5%86%BB%E7%BB%93/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/28/pytorch载入部分参数并冻结/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/LXX516/article/details/80124768">pytorch 模型部分参数的加载</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34914551/article/details/87871134">Pytorch中，只导入部分模型参数的做法</a></li>
<li><a target="_blank" rel="noopener" href="https://discuss.pytorch.org/t/correct-way-to-freeze-layers/26714">Correct way to freeze layers</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34147880">Pytorch自由载入部分模型参数并冻结</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21997625/article/details/90369838">pytorch冻结部分参数训练另一部分</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/jinxin521125/article/details/83621268?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task">PyTorch更新部分网络，其他不更新</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiangkejie/p/11199847.html">Pytorch固定部分参数(只训练部分层)</a></li>
</ol>
<h2 id="加载部分参数"><a href="#加载部分参数" class="headerlink" title="加载部分参数"></a>加载部分参数</h2><p>如果加载现有模型的所有参数，我们常使用的是代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.load(model.state_dict())</span><br></pre></td></tr></table></figure>
<p>在训练过程中，我们常常会使用预训练模型，有时我们是在自己的模型中加入别人的某些模块，或者对别人的模型进行局部修改，这个时候再使用<code>torch.load（model.state_dict())</code>，就会出现类似这些的错误：<code>RuntimeError: Error(s) in loading state_dict for Net:Missing key(s) in state_dict:xxx</code>。出现这个错误就是某些参数缺失或者不匹配。</p>
<h3 id="保持原来网络层的名称和结构不变"><a href="#保持原来网络层的名称和结构不变" class="headerlink" title="保持原来网络层的名称和结构不变"></a>保持原来网络层的名称和结构不变</h3><p>现有模型中引入的那部分网络结构的网络层的名称和结构保持不变，这时候加载参数的代码很简单。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载引入的网络模型</span></span><br><span class="line">model_path = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">checkpoint = torch.load(os.path.join(model_path, map_location=torch.device(<span class="string">&#x27;cpu&#x27;</span>))</span><br><span class="line">pretrained_dict = checkpoint[<span class="string">&#x27;net&#x27;</span>]</span><br><span class="line"><span class="comment"># 获取现有模型的参数字典</span></span><br><span class="line">model_dict =  model.state_dict()</span><br><span class="line"><span class="comment"># 获取两个模型相同网络层的参数字典</span></span><br><span class="line">state_dict = &#123;k:v <span class="keyword">for</span> k,v <span class="keyword">in</span> pretrained_dict.items() <span class="keyword">if</span> k <span class="keyword">in</span> model_dict.keys()&#125;</span><br><span class="line"><span class="comment"># update必不可少，实现相同key的value同步</span></span><br><span class="line">model_dict.update(state_dict)</span><br><span class="line"><span class="comment"># 加载模型部分参数</span></span><br><span class="line">model.load_state_dict(model_dict)</span><br></pre></td></tr></table></figure>
<h3 id="引入的网络层名称发生修改"><a href="#引入的网络层名称发生修改" class="headerlink" title="引入的网络层名称发生修改"></a>引入的网络层名称发生修改</h3><p>这个时候再直接使用上面的加载方法，会导致部分key的value无法实现更新。 我就曾在这个位置犯过很严重的错误。首先我定义了<code>AttentionResNet</code>，这是一个UNet来实现图像分割，然后在另一个模型中我使用了这个模型<code>self.attention_map = AttentionResNet(XXX)</code>。因为我在引用的过程中并没有对<code>AttentionResNet</code>那部分代码进行修改，所以本能的觉得这部分网络层的名称是相同的，所以加载这部分参数时，我直接使用了上面的方法。这个错误隐藏了差不多一个星期。直到我开始冻结这部分参数进行训练时，发现情况不对。因为我在输出<code>attention_map</code>的特征图时，我发现它是一张全黑图（像素全为0），这表示加载的参数不对，然后我尝试输出<code>pretrained_dict</code>时，它是一个空字典。然后继续输出<code>pretrained_dict.keys()</code>(未修改之前的<code>pretrained_dict</code>)和<code>model_dict.keys()</code>发现预期相同的那部分key中都多了一部分<code>attention_map.</code>。问题主要出在<code>self.attention_map = AttentionResNet(XXX)</code>这一句，它使原有的网络层名称都加了个前缀<code>attention_map.</code>，知道了错误，修改起来很简单。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载引入的网络模型</span></span><br><span class="line">model_path = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">checkpoint = torch.load(os.path.join(model_path, map_location=torch.device(<span class="string">&#x27;cpu&#x27;</span>))</span><br><span class="line">pretrained_dict = checkpoint[<span class="string">&#x27;net&#x27;</span>]</span><br><span class="line"><span class="comment"># 获取现有模型的参数字典</span></span><br><span class="line">model_dict =  model.state_dict()</span><br><span class="line"><span class="comment"># 获取两个模型相同网络层的参数字典</span></span><br><span class="line">state_dict = &#123;<span class="string">&#x27;attention_map.&#x27;</span> + k:v <span class="keyword">for</span> k,v <span class="keyword">in</span> pretrained_dict.items() <span class="keyword">if</span> <span class="string">&#x27;attention_map.&#x27;</span> + k <span class="keyword">in</span> model_dict.keys()&#125;</span><br><span class="line"><span class="comment"># update必不可少，实现相同key的value同步</span></span><br><span class="line">model_dict.update(state_dict)</span><br><span class="line"><span class="comment"># 加载模型部分参数</span></span><br><span class="line">model.load_state_dict(model_dict)</span><br></pre></td></tr></table></figure>
<p>其实我这个位置的修改有点投机，更加常规的方法是： 引用自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34147880">Pytorch自由载入部分模型参数并冻结</a></p>
<blockquote>
<p>我们看出只要构建一个字典，使得字典的keys和我们自己创建的网络相同，我们在从各种预训练网络把想要的参数对着新的keys填进去就可以有一个新的state_dict了，这样我们就可以load这个新的state_dict，这是最普适的方法适用于所有的网络变化。</p>
</blockquote>
<p>先输出两个模型的参数字典，观察需要加载的那部分参数所处的位置，然后利用for循环构建新的字典。</p>
<h2 id="冻结参数"><a href="#冻结参数" class="headerlink" title="冻结参数"></a>冻结参数</h2><ol>
<li>将需要固定的那部分参数的<code>requires_grad</code>置为False.</li>
<li>在优化器中加入filter根据<code>requires_grad</code>进行过滤.</li>
</ol>
<p>ps: 解决<code>AttributeError: ‘NoneType’ object has no attribute ‘data’</code>问题的一种思路就是冻结参数，参考<a target="_blank" rel="noopener" href="http://onwaier.com/?p=540">博客</a> 代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># requires_grad置为False</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> net.XXX.parameters():</span><br><span class="line">    p.requires_grad = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># filter</span></span><br><span class="line">optimizer.SGD(<span class="built_in">filter</span>(<span class="keyword">lambda</span> p: p.requires_grad, model.parameters()), lr=<span class="number">1e-3</span>)</span><br></pre></td></tr></table></figure>
<p>当需要冻结的那部分参数的网络层名称不太明确时，可以采用<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21997625/article/details/90369838">pytorch冻结部分参数训练另一部分</a>的思路，打印出所有网络层，通过参数名称进行冻结。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/17/leetcode2020%E7%AC%AC176%E5%9C%BA%E5%91%A8%E8%B5%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Onwaier">
      <meta itemprop="description" content="Onwaier的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Onwaier's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/17/leetcode2020%E7%AC%AC176%E5%9C%BA%E5%91%A8%E8%B5%9B/" class="post-title-link" itemprop="url">LeetCode2020第176场周赛</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-17 18:51:07" itemprop="dateCreated datePublished" datetime="2020-02-17T18:51:07+08:00">2020-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-02-13 14:09:35" itemprop="dateModified" datetime="2022-02-13T14:09:35+08:00">2022-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
    </span>

  
    <span id="/2020/02/17/leetcode2020%E7%AC%AC176%E5%9C%BA%E5%91%A8%E8%B5%9B/" class="post-meta-item leancloud_visitors" data-flag-title="LeetCode2020第176场周赛" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/02/17/leetcode2020%E7%AC%AC176%E5%9C%BA%E5%91%A8%E8%B5%9B/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/17/leetcode2020第176场周赛/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="5340-统计有序矩阵中的负数"><a href="#5340-统计有序矩阵中的负数" class="headerlink" title="5340. 统计有序矩阵中的负数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-negative-numbers-in-a-sorted-matrix/">5340. 统计有序矩阵中的负数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个 <code>m * n</code> 的矩阵 <code>grid</code>，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。  请你统计并返回 <code>grid</code> 中 <strong>负数</strong> 的数目。   <strong>示例 1：</strong></p>
<p><strong>输入：</strong>grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]<br><strong>输出：</strong>8<br><strong>解释：</strong>矩阵中共有 8 个负数。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>grid = [[3,2],[1,0]]<br><strong>输出：</strong>0</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>grid = [[1,-1],[-1,-1]]<br><strong>输出：</strong>3</p>
<p><strong>示例 4：</strong></p>
<p><strong>输入：</strong>grid = [[-1]]<br><strong>输出：</strong>1</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>遍历二维数组，统计负数的个数即可。 时间复杂度为：$O(n^2)$ 空间复杂度为：$O(1)$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNegatives</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] &lt; <span class="number">0</span>)&#123;<span class="comment">//统计负数的个数</span></span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="5341-最后-K-个数的乘积"><a href="#5341-最后-K-个数的乘积" class="headerlink" title="5341. 最后 K 个数的乘积"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/product-of-the-last-k-numbers/">5341. 最后 K 个数的乘积</a></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>请你实现一个「数字乘积类」<code>ProductOfNumbers</code>，要求支持下述两种方法： 1. <code>add(int num)</code></p>
<ul>
<li>将数字 <code>num</code> 添加到当前数字列表的最后面。</li>
</ul>
<ol>
<li><code>getProduct(int k)</code></li>
</ol>
<ul>
<li>返回当前数字列表中，最后 <code>k</code> 个数字的乘积。</li>
<li>你可以假设当前列表中始终 <strong>至少</strong> 包含 <code>k</code> 个数字。</li>
</ul>
<p>题目数据保证：任何时候，任一连续数字序列的乘积都在 32-bit 整数范围内，不会溢出。   <strong>示例：</strong></p>
<p><strong>输入：</strong><br>[“ProductOfNumbers”,”add”,”add”,”add”,”add”,”add”,”getProduct”,”getProduct”,”getProduct”,”add”,”getProduct”]<br>[[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]</p>
<p><strong>输出：</strong><br>[null,null,null,null,null,null,20,40,0,null,32]</p>
<p><strong>解释：</strong><br>ProductOfNumbers productOfNumbers = new ProductOfNumbers();<br>productOfNumbers.add(3);        // [3]<br>productOfNumbers.add(0);        // [3,0]<br>productOfNumbers.add(2);        // [3,0,2]<br>productOfNumbers.add(5);        // [3,0,2,5]<br>productOfNumbers.add(4);        // [3,0,2,5,4]<br>productOfNumbers.getProduct(2); // 返回 20 。最后 2 个数字的乘积是 5 * 4 = 20<br>productOfNumbers.getProduct(3); // 返回 40 。最后 3 个数字的乘积是 2 * 5 * 4 = 40<br>productOfNumbers.getProduct(4); // 返回  0 。最后 4 个数字的乘积是 0 * 2 * 5 * 4 = 0<br>productOfNumbers.add(8);        // [3,0,2,5,4,8]<br>productOfNumbers.getProduct(2); // 返回 32 。最后 2 个数字的乘积是 4 * 8 = 32 </p>
<h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>周赛的时候没有多想，上来直接用vector来存储所有的数，<code>add</code>函数用<code>push_back</code>来实现。最后k个元素乘积直接从vector的最后一个元素开始，将k个元素乘起来即可。 时间复杂度为：O(n) 空间复杂度为：O(n)</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProductOfNumbers</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;vec;</span><br><span class="line">    <span class="built_in">ProductOfNumbers</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getProduct</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = vec.<span class="built_in">size</span>(), res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= len - k; --i)&#123;</span><br><span class="line">            res = res * vec[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your ProductOfNumbers object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * ProductOfNumbers* obj = new ProductOfNumbers();</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(num);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;getProduct(k);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h2><p>参照<a target="_blank" rel="noopener" href="https://leetcode-cn.com/circle/discuss/0gO5RS/">LeetCode - 圈子</a>，对于第二题给出了许多优化的算法。题目中给出的限制条件需要注意。</p>
<blockquote>
<p>题目数据保证：任何时候，任一连续数字序列的乘积都在 32-bit 整数范围内，不会溢出。 0 &lt;= num &lt;= 100</p>
</blockquote>
<p>对于任一连续序列的乘积都小于32位整数范围，表示序列中最多只有31个数大于1（$2^{31} - 1$），其它数字都是0和1。所以可以用前缀和来统计0-100这101个数字在序列中出现的个数，这里空间开销是101 * n（n是序列的总长度）。计算最后K个数的乘积，只需要先找出每个数字num出现的次数cnt，$cnt_{num} = vec[n][num] - vec[n - k][num]$，出现0，最后乘积就为0，出现1，则跳过1不算。然后再求其它数字乘积即可。 这里我介绍前缀积的思路。数组存储连续数字的乘积，遇到0，清除数组，重新统计。当最后数组长度不足K时，表示乘积为0，否则就用总乘积除以前面元素的乘积。 时间复杂度为：O(1) 空间复杂度为：O(n)</p>
<h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProductOfNumbers</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;vec;</span><br><span class="line">    <span class="built_in">ProductOfNumbers</span>() &#123;</span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;<span class="comment">//遇到0，清空前缀积数组</span></span><br><span class="line">            vec.<span class="built_in">clear</span>();</span><br><span class="line">            vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(vec.<span class="built_in">back</span>() * num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getProduct</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vec.<span class="built_in">size</span>() - <span class="number">1</span> &lt; k)&#123;<span class="comment">//数组长度不足K表示，最后K个数中存在0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> vec[vec.<span class="built_in">size</span>() - <span class="number">1</span>] / vec[vec.<span class="built_in">size</span>() - <span class="number">1</span> - k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your ProductOfNumbers object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * ProductOfNumbers* obj = new ProductOfNumbers();</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(num);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;getProduct(k);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="1353-最多可以参加的会议数目"><a href="#1353-最多可以参加的会议数目" class="headerlink" title="1353. 最多可以参加的会议数目"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended/">1353. 最多可以参加的会议数目</a></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个数组 <code>events</code>，其中 <code>events[i] = [startDayi, endDayi]</code> ，表示会议 <code>i</code> 开始于 <code>startDayi</code> ，结束于 <code>endDayi</code> 。 你可以在满足 <code>startDayi &lt;= d &lt;= endDayi</code> 中的任意一天 <code>d</code> 参加会议 <code>i</code> 。注意，一天只能参加一个会议。 请你返回你可以参加的 <strong>最大</strong> 会议数目。   <strong>示例 1：</strong> <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/16/e1.png" alt=""></p>
<p><strong>输入：</strong>events = [[1,2],[2,3],[3,4]]<br><strong>输出：</strong>3<br><strong>解释：</strong>你可以参加所有的三个会议。<br>安排会议的一种方案如上图。<br>第 1 天参加第一个会议。<br>第 2 天参加第二个会议。<br>第 3 天参加第三个会议。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>events= [[1,2],[2,3],[3,4],[1,2]]<br><strong>输出：</strong>4</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>events = [[1,4],[4,4],[2,2],[3,4],[1,1]]<br><strong>输出：</strong>4</p>
<p><strong>示例 4：</strong></p>
<p><strong>输入：</strong>events = [[1,100000]]<br><strong>输出：</strong>1</p>
<p><strong>示例 5：</strong></p>
<p><strong>输入：</strong>events = [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7]]<br><strong>输出：</strong>7</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>贪心+优先队列 首先将区间按开始时间进行排序，然后结束时间早的先安排。还需要鼗安排冲突，不合理的去掉。 时间复杂度为：O(nlogn) 空间复杂度为：O(n)</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxEvents</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; events)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt;que;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, idx = <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//先排序</span></span><br><span class="line">        <span class="built_in">sort</span>(events.<span class="built_in">begin</span>(), events.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span>(i &lt; events.<span class="built_in">size</span>()  que.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; events.<span class="built_in">size</span>() &amp;&amp; events[i][<span class="number">0</span>] == idx)&#123;<span class="comment">//开始时间为idx的，均添加到优先队列</span></span><br><span class="line">                que.<span class="built_in">push</span>(events[i][<span class="number">1</span>]);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(que.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; que.<span class="built_in">top</span>() &lt; idx)&#123;<span class="comment">//去除安排冲突的</span></span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(que.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;<span class="comment">//优先安排结束时间早的</span></span><br><span class="line">                ++cnt;</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ++idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="5343-多次求和构造目标数组"><a href="#5343-多次求和构造目标数组" class="headerlink" title="5343. 多次求和构造目标数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-target-array-with-multiple-sums/">5343. 多次求和构造目标数组</a></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 <code>target</code> 。一开始，你有一个数组 <code>A</code> ，它的所有元素均为 1 ，你可以执行以下操作：</p>
<ul>
<li>令 <code>x</code> 为你数组里所有元素的和</li>
<li>选择满足 <code>0 &lt;= i &lt; target.size</code> 的任意下标 <code>i</code> ，并让 <code>A</code> 数组里下标为 <code>i</code> 处的值为 <code>x</code> 。</li>
<li>你可以重复该过程任意次</li>
</ul>
<p>如果能从 <code>A</code> 开始构造出目标数组 <code>target</code> ，请你返回 True ，否则返回 False 。   <strong>示例 1：</strong></p>
<p><strong>输入：</strong>target = [9,3,5]<br><strong>输出：</strong>true<br><strong>解释：</strong>从 [1, 1, 1] 开始<br>[1, 1, 1], 和为 3 ，选择下标 1<br>[1, 3, 1], 和为 5， 选择下标 2<br>[1, 3, 5], 和为 9， 选择下标 0<br>[9, 3, 5] 完成</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>target = [1,1,1,2]<br><strong>输出：</strong>false<br><strong>解释：</strong>不可能从 [1,1,1,1] 出发构造目标数组。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>target = [8,5]<br><strong>输出：</strong>true</p>
<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>正向思考，不知道用所有的数字之和去替换哪一个数字，尝试的话可能性太多，实现难度太大。反向思考的话，数组中最大的数字显然是上一个数组中所有数字之和，而它所替换的数字等于最大的数字减去其它数字之和。如此替换下去，如果最后所有的数字都为1，表示可以构造目标数组，一旦出现数字0或负数，表示不能构造。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPossible</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rep_num = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt;que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; target.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            sum += target[i];</span><br><span class="line">            que.<span class="built_in">push</span>(target[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(que.<span class="built_in">top</span>() != <span class="number">1</span>)&#123;</span><br><span class="line">            sum = sum - que.<span class="built_in">top</span>();<span class="comment">//除去最大数字其它数字之和</span></span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">1</span>)&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这里用除法而不用减法是为了处理像[100000, 1]这样的例子超时的问题</span></span><br><span class="line"><span class="comment">            用除法，直接使当前的最大数字小于其它数字之和，避免多轮最大数字都是同一个。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(que.<span class="built_in">top</span>() / sum == <span class="number">0</span>  (que.<span class="built_in">top</span>() % sum == <span class="number">0</span>))&#123;<span class="comment">//出现负数和0</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(que.<span class="built_in">top</span>() % sum);</span><br><span class="line">                sum = sum + que.<span class="built_in">top</span>() % sum;<span class="comment">//上一个数组的所有元素之和</span></span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/16/pytorch%E5%AF%B9%E4%B8%A4%E5%BC%A0%E5%9B%BE%E7%89%87%E8%BF%9B%E8%A1%8C%E7%9B%B8%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%B9%BF%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Onwaier">
      <meta itemprop="description" content="Onwaier的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Onwaier's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/16/pytorch%E5%AF%B9%E4%B8%A4%E5%BC%A0%E5%9B%BE%E7%89%87%E8%BF%9B%E8%A1%8C%E7%9B%B8%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%B9%BF%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">Pytorch对两张图片进行相同的数据增广操作</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-16 22:30:29" itemprop="dateCreated datePublished" datetime="2020-02-16T22:30:29+08:00">2020-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-02-13 14:28:35" itemprop="dateModified" datetime="2022-02-13T14:28:35+08:00">2022-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/pytorch/" itemprop="url" rel="index"><span itemprop="name">pytorch</span></a>
        </span>
    </span>

  
    <span id="/2020/02/16/pytorch%E5%AF%B9%E4%B8%A4%E5%BC%A0%E5%9B%BE%E7%89%87%E8%BF%9B%E8%A1%8C%E7%9B%B8%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%B9%BF%E6%93%8D%E4%BD%9C/" class="post-meta-item leancloud_visitors" data-flag-title="Pytorch对两张图片进行相同的数据增广操作" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/02/16/pytorch%E5%AF%B9%E4%B8%A4%E5%BC%A0%E5%9B%BE%E7%89%87%E8%BF%9B%E8%A1%8C%E7%9B%B8%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%B9%BF%E6%93%8D%E4%BD%9C/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/16/pytorch对两张图片进行相同的数据增广操作/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://dingguanglei.com/pytorch/">个人博客 - Pytorch同时对输入输出使用transform</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/95680105">知乎 - 4个例子让你的pytorch数据增强过程不随机</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/liangdong2014/article/details/83339444">CSDN - Tensorflow如何对两幅图像做同样的数据增广操作</a></li>
<li><a target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/torchvision/transforms.html?highlight=torchvision%20transforms%20functional#module-torchvision.transforms.functional">Pytorch官方文档 - torchvision.transforms.functional</a></li>
</ol>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>原始的人脸表情识别训练过程中，对于每张输入的图片，都有一个表情标签与之对应（这里只考虑单标签）。可以直接使用<code>torchvision.transform</code>中的<code>transforms.RandomCrop</code>、<code>transforms.RandomHorizontalFlip</code>、<code>transforms.RandomRotation</code>等对图片进行随机操作，从而实现对数据的增广操作，提高模型的泛化能力。 但在人脸表情识别中引入<strong>Attention</strong>机制后，对于每张输入图片，则对应一个脸部分割的概率图。在对原始图片进行<code>transform</code>的变换时，与之对应的脸部分割图mask应与之进行相同的变化。但是上面提到的所有操作都是随机操作，涉及一个随机值。所以，无法做到输入与mask进行相同的<code>transform</code>。所以，决定放弃使用数据增广的操作，而是直接使用的是原图，训练过程中出现train的准确率不断上升，最后达到100%，而test的准确率则开始是上升，中间出现波动。最后开始下降。很显然，模型过拟化。为了解决这个问题，相当于解决如何用Pytorch对两张图片进行相同的数据增广操作的问题？</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><blockquote>
<p>在pytorch文档上可以看到，除了torchvision.transform 还有torchvision.transforms.functional。 相比transform ，transforms.functional 更加灵活，该方法只提供了图像的增强变换功能，而并没有随机部分</p>
</blockquote>
<p>引用自<a target="_blank" rel="noopener" href="https://dingguanglei.com/pytorch/">资料1</a> 实际上是用<strong>torchvision.transforms.functional</strong>中提供的函数（都没有引入随机性），来自定义<code>transform</code>函数。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>原图及脸部分割mask如图所求 <img src="/images/2020/02/a224c83a16ac9de23a6d622063e8274f.png" alt=""> <img src="/images/2020/02/cc8c79c6d866801fab0a166386706afe.png" alt=""> 然后对图片同时进行随机旋转和翻转，代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms.functional <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_transform1</span>(<span class="params">image, mask</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 拿到角度的随机数。angle是一个-180到180之间的一个数</span></span><br><span class="line">        angle = transforms.RandomRotation.get_params([-<span class="number">180</span>, <span class="number">180</span>])</span><br><span class="line">        <span class="comment"># 对image和mask做相同的旋转操作，保证他们都旋转angle角度</span></span><br><span class="line">        image = image.rotate(angle)</span><br><span class="line">        mask = mask.rotate(angle)</span><br><span class="line"></span><br><span class="line">        image = tf.to_tensor(image)</span><br><span class="line">        mask = tf.to_tensor(mask)</span><br><span class="line">        <span class="keyword">return</span> image, mask</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_transform2</span>(<span class="params">image, mask</span>):</span><br><span class="line">    <span class="comment"># 50%的概率应用垂直，水平翻转。</span></span><br><span class="line">    <span class="keyword">if</span> random.random() &gt; <span class="number">0.5</span>:</span><br><span class="line">        image = tf.hflip(image)</span><br><span class="line">        mask = tf.hflip(mask)</span><br><span class="line">    <span class="keyword">if</span> random.random() &gt; <span class="number">0.5</span>:</span><br><span class="line">        image = tf.vflip(image)</span><br><span class="line">        mask = tf.vflip(mask)</span><br><span class="line">    image = tf.to_tensor(image)</span><br><span class="line">    mask = tf.to_tensor(mask)</span><br><span class="line">    <span class="keyword">return</span> image, mask</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_transform3</span>(<span class="params">image, mask</span>):</span><br><span class="line">    <span class="comment"># 随机裁剪</span></span><br><span class="line">    i, j, h, w = transforms.RandomResizedCrop.get_params(</span><br><span class="line">    image, scale=(<span class="number">0.7</span>, <span class="number">1.0</span>), ratio=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    image = tf.resized_crop(image, i, j, h, w, <span class="number">48</span>)</span><br><span class="line">    mask = tf.resized_crop(mask, i, j, h, w, <span class="number">48</span>)</span><br><span class="line">    image = tf.to_tensor(image)</span><br><span class="line">    mask = tf.to_tensor(mask)</span><br><span class="line">    <span class="keyword">return</span> image, mask</span><br><span class="line"></span><br><span class="line"><span class="comment"># transform处理对象一般都是 PIL Image</span></span><br><span class="line"></span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">&#x27;./0.jpg&#x27;</span>) <span class="comment"># 原图</span></span><br><span class="line">mask = Image.<span class="built_in">open</span>(<span class="string">&#x27;./0_seg_face.jpg&#x27;</span>) <span class="comment"># mask</span></span><br><span class="line"></span><br><span class="line">image_tensor, mask_tensor = my_transform1(image, mask)</span><br><span class="line"></span><br><span class="line"><span class="comment">#此时image, mask为tensor,需转成PIL Image</span></span><br><span class="line">image_rotate = transforms.ToPILImage()(image_tensor).convert(<span class="string">&#x27;L&#x27;</span>).save(<span class="string">&#x27;0_rotate.jpg&#x27;</span>)</span><br><span class="line">mask_rotate = transforms.ToPILImage()(mask_tensor).convert(<span class="string">&#x27;L&#x27;</span>).save(<span class="string">&#x27;0_seg_face_rotate.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">image_tensor, mask_tensor = my_transform2(image, mask)</span><br><span class="line"></span><br><span class="line"><span class="comment">#此时image, mask为tensor,需转成PIL Image</span></span><br><span class="line">image_flip = transforms.ToPILImage()(image_tensor).convert(<span class="string">&#x27;L&#x27;</span>).save(<span class="string">&#x27;0_flip.jpg&#x27;</span>)</span><br><span class="line">mask_flip = transforms.ToPILImage()(mask_tensor).convert(<span class="string">&#x27;L&#x27;</span>).save(<span class="string">&#x27;0_seg_face_flip.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">image_tensor, mask_tensor = my_transform3(image, mask)</span><br><span class="line"></span><br><span class="line"><span class="comment">#此时image, mask为tensor,需转成PIL Image</span></span><br><span class="line">image_crop = transforms.ToPILImage()(image_tensor).convert(<span class="string">&#x27;L&#x27;</span>).save(<span class="string">&#x27;0_crop.jpg&#x27;</span>)</span><br><span class="line">mask_crop = transforms.ToPILImage()(mask_tensor).convert(<span class="string">&#x27;L&#x27;</span>).save(<span class="string">&#x27;0_seg_face_crop.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>旋转后图片为（每次旋转结果可能都不一样，角度随机） <img src="/images/2020/02/488f76c329186d7ec3a42e72f032c942.png" alt=""> <img src="/images/2020/02/88758350925fa2953bc0d0747f61ef3e.png" alt=""> 50%可能性翻转后图片为 <img src="/images/2020/02/462a90f6e8b3e61c13c9a9b30fe88a1f.png" alt=""> <img src="/images/2020/02/2ef457bac586668f6fa9fab7a9a2362b.png" alt=""> 随机裁剪，裁剪后大小为原来的[0.8,1]，长宽比例为1：1，最后并将resize为(48, 48)，图片为： <img src="/images/2020/02/4d13b7f8b17042df1b272f701770e3d9.png" alt=""> <img src="/images/2020/02/3c4bf2f5dbac43a03d95553492fb9bd1.png" alt=""></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/10/typeerror-object-dtype-dtypeo-has-no-native-hdf5-equivalent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Onwaier">
      <meta itemprop="description" content="Onwaier的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Onwaier's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/10/typeerror-object-dtype-dtypeo-has-no-native-hdf5-equivalent/" class="post-title-link" itemprop="url">TypeError: Object dtype dtype('O') has no native HDF5 equivalent</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-10 23:02:29" itemprop="dateCreated datePublished" datetime="2020-02-10T23:02:29+08:00">2020-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-02-13 13:43:28" itemprop="dateModified" datetime="2022-02-13T13:43:28+08:00">2022-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/pytorch/" itemprop="url" rel="index"><span itemprop="name">pytorch</span></a>
        </span>
    </span>

  
    <span id="/2020/02/10/typeerror-object-dtype-dtypeo-has-no-native-hdf5-equivalent/" class="post-meta-item leancloud_visitors" data-flag-title="TypeError: Object dtype dtype('O') has no native HDF5 equivalent" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/02/10/typeerror-object-dtype-dtypeo-has-no-native-hdf5-equivalent/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/10/typeerror-object-dtype-dtypeo-has-no-native-hdf5-equivalent/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/chenvast/article/details/78974359">Python TypeError: No conversion path for dtype: dtype(‘</a></li>
<li><a target="_blank" rel="noopener" href="https://www.twblogs.net/a/5c359e55bd9eee35b3a55bb6/zh-cn">TypeError: Object dtype dtype(‘O’) has no native HDF5 equivalent</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ojit.com/article/358928">python - 使用不同大小的h5py数组进行保存</a></li>
</ol>
<h2 id="错误描述"><a href="#错误描述" class="headerlink" title="错误描述"></a>错误描述</h2><p>在对h5文件写的过程中，首先遇到了错误<code>OSError: Cannot write data (no appropriate function for conversion path)</code>，网上搜索之后，与之相关的问题很少，大部分提到的是字符串编码问题，参照<a target="_blank" rel="noopener" href="https://blog.csdn.net/chenvast/article/details/78974359">资料1</a>，对字符串的编码修改，但错误依旧。在这个地方卡了很长时间，一直检查数据类型哪里是不是有问题？最后尝试性，将最后创建数据集中的<code>dtype</code>去掉，即置为<code>None</code>。即将</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datafile.create_dataset(<span class="string">&quot;PrivateTest_gt&quot;</span>, dtype = <span class="string">&#x27;uint8&#x27;</span>, data=PrivateTest_z)</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datafile.create_dataset(<span class="string">&quot;PrivateTest_gt&quot;</span>, data=PrivateTest_z)</span><br></pre></td></tr></table></figure>
<p>问题出现了转机，提示的错误不一样了，<code>TypeError: Object dtype dtype(&#39;O&#39;) has no native HDF5 equivalent</code>，再查询这个问题上，发现很多博客，如<a target="_blank" rel="noopener" href="https://www.twblogs.net/a/5c359e55bd9eee35b3a55bb6/zh-cn">资料2</a>和<a target="_blank" rel="noopener" href="https://www.ojit.com/article/358928">资料3</a>提到出现错误的原因是：</p>
<blockquote>
<p>要存储的数据中存在维度不一致的数据</p>
</blockquote>
<p>具体<code>datafile.create_dataset(&quot;PrivateTest_gt&quot;, data=PrivateTest_z)</code>一行中，PrivateTest_z列表中存储着两种shape的图片数据，一种是48 * 48，而另一种是128 * 128。这种情况h5py无法统一处理。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>参照资料，解决这个问题常见有两种。</p>
<ul>
<li>散装</li>
</ul>
<p>将相同维度的数据放在同一个dataset中，即把原始数据拆分成多个dataset存储</p>
<ul>
<li>统装</li>
</ul>
<p>统一数据的维度。我用的就是这种方法，我将所有图片的数据都统一成128 * 128（对于48的resize），即解决上述问题。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/09/typeerror-caught-typeerror-in-dataloader-worker-process-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Onwaier">
      <meta itemprop="description" content="Onwaier的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Onwaier's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/09/typeerror-caught-typeerror-in-dataloader-worker-process-0/" class="post-title-link" itemprop="url">TypeError: Caught TypeError in DataLoader worker process 0.</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-09 09:48:21" itemprop="dateCreated datePublished" datetime="2020-02-09T09:48:21+08:00">2020-02-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-02-13 13:43:28" itemprop="dateModified" datetime="2022-02-13T13:43:28+08:00">2022-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/pytorch/" itemprop="url" rel="index"><span itemprop="name">pytorch</span></a>
        </span>
    </span>

  
    <span id="/2020/02/09/typeerror-caught-typeerror-in-dataloader-worker-process-0/" class="post-meta-item leancloud_visitors" data-flag-title="TypeError: Caught TypeError in DataLoader worker process 0." title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/02/09/typeerror-caught-typeerror-in-dataloader-worker-process-0/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/09/typeerror-caught-typeerror-in-dataloader-worker-process-0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45093926/article/details/103330105">Python迭代DataLoader时出现TypeError: Caught TypeError in DataLoader worker process 0.错误。</a></li>
</ol>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>用构造的数据集去训练网络过程，迭代DataLoader出现TypeError的错误，<code>Caught TypeError in DataLoader worker process 0</code></p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45093926/article/details/103330105">资料1</a>)，出错原因是数据集的标签缺失，不完整。 查看自己的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">files = os.listdir(anger_path)</span><br><span class="line">files.sort()</span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> files:</span><br><span class="line">    I = skimage.io.imread(os.path.join(anger_path,filename))</span><br><span class="line">    image = cv2.imread(os.path.join(anger_path,filename))</span><br><span class="line">    res, flag = get_mask(image)</span><br><span class="line">    data_x.append(I.tolist())</span><br><span class="line">    data_y.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> flag == <span class="literal">True</span>:</span><br><span class="line">        res = res * <span class="number">255</span></span><br><span class="line">        seg_image_data = res.tolist()</span><br><span class="line">        data_z.append(seg_image_data)</span><br><span class="line">        imageCount = imageCount + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(imageCount)</span><br></pre></td></tr></table></figure>
<p>data_x与data_y的数据是直接添加的，而data_z是经过if判断的，False时，就不会添加。这样就导致某一条记录里面没有data_z这个标签，为了解决这个问题，需将data_x和data_y的数据添加移到if条件中，实现data_x，data_y和data_z三个同步添加。即</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">files = os.listdir(anger_path)</span><br><span class="line">files.sort()</span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> files:</span><br><span class="line">    I = skimage.io.imread(os.path.join(anger_path,filename))</span><br><span class="line">    image = cv2.imread(os.path.join(anger_path,filename))</span><br><span class="line">    res, flag = get_mask(image)</span><br><span class="line">    <span class="keyword">if</span> flag == <span class="literal">True</span>:</span><br><span class="line">        data_x.append(I.tolist())</span><br><span class="line">        data_y.append(<span class="number">0</span>)</span><br><span class="line">        res = res * <span class="number">255</span></span><br><span class="line">        seg_image_data = res.tolist()</span><br><span class="line">        data_z.append(seg_image_data)</span><br><span class="line">        imageCount = imageCount + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(imageCount)</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/07/attributeerror-nonetype-object-has-no-attribute-data/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Onwaier">
      <meta itemprop="description" content="Onwaier的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Onwaier's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/07/attributeerror-nonetype-object-has-no-attribute-data/" class="post-title-link" itemprop="url">AttributeError: 'NoneType' object has no attribute 'data'</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-07 20:27:46" itemprop="dateCreated datePublished" datetime="2020-02-07T20:27:46+08:00">2020-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-02-13 13:43:28" itemprop="dateModified" datetime="2022-02-13T13:43:28+08:00">2022-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/pytorch/" itemprop="url" rel="index"><span itemprop="name">pytorch</span></a>
        </span>
    </span>

  
    <span id="/2020/02/07/attributeerror-nonetype-object-has-no-attribute-data/" class="post-meta-item leancloud_visitors" data-flag-title="AttributeError: 'NoneType' object has no attribute 'data'" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/02/07/attributeerror-nonetype-object-has-no-attribute-data/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/07/attributeerror-nonetype-object-has-no-attribute-data/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/WuJie1010/Facial-Expression-Recognition.Pytorch/issues/24">issue</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/leogo17/article/details/79970938">pytorch: grad is None while training</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21997625/article/details/90369838">pytorch冻结部分参数训练另一部分</a></li>
</ol>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>将别人模型替换成自己的模型，训练过程中出现错误<code>param.grad.data.clamp_(-grad_clip, grad_clip) AttributeError: &#39;NoneType&#39; object has no attribute &#39;data&#39;</code></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>上网查询这个问题，大部分回答都是模型中定义的某个层没有参与到前向传播，所以反向传播，计算loss时，<code>grad is None</code>。主要是要找到未参与计算的层，并注释掉。 这个问题困扰我很久，因为始终觉得没有多余的层。 下面的代码定义一个AttentionResNet模型。后来才发现罪魁祸首是<code>self.encoder</code>，这所以前面一直没有注意到它，是因为后面的层的定义用到<code>self.encoder</code>中的某个层或某几个层组合。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AttentionResNet</span>(nn.Module):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_channels=<span class="number">3</span>, out_channels=<span class="number">1</span>, num_filters=<span class="number">32</span>, encoder_depth=<span class="number">34</span>, pretrained=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(AttentionResNet, self).__init__()</span><br><span class="line">        self.in_channels  = in_channels</span><br><span class="line">        self.out_channels = out_channels </span><br><span class="line">        self.num_filters = num_filters</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> encoder_depth == <span class="number">34</span>:</span><br><span class="line">            self.encoder = torchvision.models.resnet34(pretrained=pretrained)</span><br><span class="line">            bottom_channel_nr = <span class="number">512</span></span><br><span class="line">        <span class="keyword">elif</span> encoder_depth == <span class="number">101</span>:</span><br><span class="line">            self.encoder = torchvision.models.resnet101(pretrained=pretrained)</span><br><span class="line">            bottom_channel_nr = <span class="number">2048</span></span><br><span class="line">        <span class="keyword">elif</span> encoder_depth == <span class="number">152</span>:</span><br><span class="line">            self.encoder = torchvision.models.resnet152(pretrained=pretrained)</span><br><span class="line">            bottom_channel_nr = <span class="number">2048</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> NotImplementedError(<span class="string">&#x27;only 34, 101, 152 version of Resnet are implemented&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#attention module</span></span><br><span class="line">        self.pool  = nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        self.relu  = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">        self.conv1 = nn.Sequential(self.encoder.conv1, self.encoder.bn1, self.encoder.relu, self.pool)</span><br><span class="line">        self.conv2 = self.encoder.layer1</span><br><span class="line">        self.conv3 = self.encoder.layer2</span><br><span class="line">        self.conv4 = self.encoder.layer3</span><br><span class="line">        self.conv5 = self.encoder.layer4  </span><br><span class="line"></span><br><span class="line">        self.center = DecoderBlockV2(bottom_channel_nr,                        num_filters * <span class="number">8</span> * <span class="number">2</span>, num_filters * <span class="number">8</span>)</span><br><span class="line">        self.dec5   = DecoderBlockV2(bottom_channel_nr + num_filters * <span class="number">8</span>,      num_filters * <span class="number">8</span> * <span class="number">2</span>, num_filters * <span class="number">8</span>)</span><br><span class="line">        self.dec4   = DecoderBlockV2(bottom_channel_nr // <span class="number">2</span> + num_filters * <span class="number">8</span>, num_filters * <span class="number">8</span> * <span class="number">2</span>, num_filters * <span class="number">8</span>)</span><br><span class="line">        self.dec3   = DecoderBlockV2(bottom_channel_nr // <span class="number">4</span> + num_filters * <span class="number">8</span>, num_filters * <span class="number">4</span> * <span class="number">2</span>, num_filters * <span class="number">2</span>)</span><br><span class="line">        self.dec2   = DecoderBlockV2(bottom_channel_nr // <span class="number">8</span> + num_filters * <span class="number">2</span>, num_filters * <span class="number">2</span> * <span class="number">2</span>, num_filters * <span class="number">2</span> * <span class="number">2</span>)</span><br><span class="line">        self.dec1   = DecoderBlockV2(num_filters * <span class="number">2</span> * <span class="number">2</span>,                      num_filters * <span class="number">2</span> * <span class="number">2</span>, num_filters)</span><br><span class="line"></span><br><span class="line">        self.attention_map = nn.Sequential(</span><br><span class="line">            ConvRelu(num_filters, num_filters),</span><br><span class="line">            nn.Conv2d(num_filters, <span class="number">1</span>, kernel_size=<span class="number">1</span>)  </span><br><span class="line">        )  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):        </span><br><span class="line"></span><br><span class="line">        <span class="comment">#attention module</span></span><br><span class="line">        conv1 = self.conv1(x)</span><br><span class="line">        conv2 = self.conv2(conv1)</span><br><span class="line">        conv3 = self.conv3(conv2)</span><br><span class="line">        conv4 = self.conv4(conv3)</span><br><span class="line">        conv5 = self.conv5(conv4)</span><br><span class="line"></span><br><span class="line">        pool = self.pool(conv5)</span><br><span class="line">        center = self.center( pool )  </span><br><span class="line">        dec5 = self.dec5(torch.cat([center, conv5], <span class="number">1</span>))        </span><br><span class="line">        dec4 = self.dec4(torch.cat([dec5, conv4], <span class="number">1</span>))</span><br><span class="line">        dec3 = self.dec3(torch.cat([dec4, conv3], <span class="number">1</span>))</span><br><span class="line">        dec2 = self.dec2(torch.cat([dec3, conv2], <span class="number">1</span>))</span><br><span class="line">        dec1 = self.dec1(dec2)           </span><br><span class="line"></span><br><span class="line">        <span class="comment">#attention map</span></span><br><span class="line">        x = self.attention_map( dec1 ) </span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>找到了出错的位置，如何修改呢？参照资料3，首先将self.encoder中的参数的<code>requires_grad</code>都置为False，然后在优化器中加入过滤器，只更新<code>requires_grad = True</code>的参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> net.encoder.parameters():</span><br><span class="line">    param.requires_grad = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">optimizer = optim.SGD(<span class="built_in">filter</span>(<span class="keyword">lambda</span> p: p.requires_grad, net.parameters()), lr=opt.lr, momentum=<span class="number">0.9</span>, weight_decay=<span class="number">5e-4</span>)</span><br></pre></td></tr></table></figure>
<p>找了2天，终于找到错误的位置，太难了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/05/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%9A%84%E5%85%94%E5%AD%90%E4%B8%8E%E4%B9%8C%E9%BE%9Ffloyds-tortoise-and-the-hare-algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Onwaier">
      <meta itemprop="description" content="Onwaier的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Onwaier's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/05/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%9A%84%E5%85%94%E5%AD%90%E4%B8%8E%E4%B9%8C%E9%BE%9Ffloyds-tortoise-and-the-hare-algorithm/" class="post-title-link" itemprop="url">弗洛伊德的兔子与乌龟(Floyd's Tortoise and the Hare algorithm)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-05 19:26:59" itemprop="dateCreated datePublished" datetime="2020-02-05T19:26:59+08:00">2020-02-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-02-13 13:55:54" itemprop="dateModified" datetime="2022-02-13T13:55:54+08:00">2022-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
    <span id="/2020/02/05/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%9A%84%E5%85%94%E5%AD%90%E4%B8%8E%E4%B9%8C%E9%BE%9Ffloyds-tortoise-and-the-hare-algorithm/" class="post-meta-item leancloud_visitors" data-flag-title="弗洛伊德的兔子与乌龟(Floyd's Tortoise and the Hare algorithm)" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/02/05/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%9A%84%E5%85%94%E5%AD%90%E4%B8%8E%E4%B9%8C%E9%BE%9Ffloyds-tortoise-and-the-hare-algorithm/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/05/弗洛伊德的兔子与乌龟floyds-tortoise-and-the-hare-algorithm/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-hans/Floyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95">Floyd判圈算法</a></li>
<li><a target="_blank" rel="noopener" href="http://www.siafoo.net/algorithm/11">Brent’s Cycle Detection Algorithm</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/gdymind/article/details/70544153">Floyd判圈算法（龟兔赛跑算法, Floyd’s cycle detection）及其证明</a></li>
<li><a target="_blank" rel="noopener" href="https://qht1003077897.github.io/2017/07/03/%E7%AE%97%E6%B3%95-floyd%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/">算法-floyd判环(圈)算法</a></li>
</ol>
<h2 id="算法解读"><a href="#算法解读" class="headerlink" title="算法解读"></a>算法解读</h2><blockquote>
<p>Floyd判圈算法(Floyd Cycle Detection Algorithm)，又称龟兔赛跑算法(Tortoise and Hare Algorithm)，是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，求出该环的起点与长度的算法。该算法据高德纳称由美国科学家罗伯特·弗洛伊德发明。</p>
</blockquote>
<p>引用自<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-hans/Floyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95">维基百科-Floyd判圈算法</a></p>
<h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><blockquote>
<p>如何检测一个链表是否有环（循环节），如果有，那么如何确定环的起点以及环的长度。</p>
</blockquote>
<p>引用自<a target="_blank" rel="noopener" href="https://blog.csdn.net/gdymind/article/details/70544153">博客</a> 上述问题是一个经典问题，经常会在面试中被问到。我之前在杭州一家网络公司的电话面试中就很不巧的问到，当时是第一次遇到那个问题（毕竟太菜，没有专门准备过算法面试），我思考片刻，问答的是用一个哈希表存储访问的节点的地址，当访问某节点时，发现哈希表中已存在，表明链表中存在环。面试官听了我的回答就反问了我一句：如果链表的环很大，那么哈希表的空间消耗就很大，你的方法并不实用。你能在不消耗额外空间的情况下，找到链表的环吗？当时，想了很久没想到，面试官就说可以这样做，balabala…</p>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ul>
<li>形象化解释</li>
</ul>
<p>解决上述问题的方法就是我们常说的<code>快慢指针</code>。乌龟与兔子在一个含环的跑道上（如图所求）进行比赛，乌龟在单位时间内移动一步，而兔子则在单位时间内移动两步，其移动速度是乌龟的两倍。乌龟与兔子同时从A点出发，兔子移动的快先行进入环形跑道，但那以后，一直在转圈。所以如果存在环的话，乌龟总能与兔子相遇（首次相遇在C点），甚至还能跑到兔子前面:joy:。 <img src="/images/2020/02/5cca0237fddaff11241dcb3204ae8b3c.png" alt=""></p>
<ul>
<li>判断是否有环</li>
</ul>
<p>定义两个指针p1与p2，起始时，都指向链表的起点A，p1每次移动1个长度，p2每次移动2个长度。如果p2在移到链表的尾端时，并未与p1相遇，表明链表中不存在环。如果p1与p2相遇在环上的某一点C，表明链表有环。</p>
<ul>
<li>环的长度</li>
</ul>
<p>将指针p1固定在相遇位置C，移动p2，每次移动1个长度，并用变量<code>cnt</code>计数。当p2再次与p1相遇时，此时<code>cnt</code>的值就是链表的长度。</p>
<ul>
<li>环的起点</li>
</ul>
<p>环的起点即图中点B，将指针p1指向链表的起始位置A，指针p2仍在位置C，指针p1与p2每次均移动一个单位，p1与p2再次相遇的位置就是环的起点位置点B。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul>
<li>伪代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">t := &amp;S</span><br><span class="line">h := &amp;S                 //令指针t和h均指向起始节点S。</span><br><span class="line">repeat</span><br><span class="line">    t := t-&gt;next</span><br><span class="line">    h := h-&gt;next</span><br><span class="line">    if h is not NULL       //要注意这一判断一般不能省略</span><br><span class="line">        h := h-&gt;next</span><br><span class="line">until t = h or h = NULL</span><br><span class="line">if h != NULL             //如果存在环的話</span><br><span class="line">    n := 0</span><br><span class="line">    repeat                //求环的度</span><br><span class="line">        t := t-&gt;next</span><br><span class="line">        n := n+1</span><br><span class="line">    until t = h</span><br><span class="line">    t := &amp;S               //求环的一个起点</span><br><span class="line">    while t != h</span><br><span class="line">    t := t-&gt;next</span><br><span class="line">        h := h-&gt;next</span><br><span class="line">P := *t</span><br></pre></td></tr></table></figure>
<p>引用自<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-hans/Floyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95">维基百科</a></p>
<ul>
<li>c++代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span><span class="comment">//链表节点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node * next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">findCircle</span><span class="params">(Node * list)</span></span>&#123;</span><br><span class="line">    Node* p1  = list-&gt;next, *p2;<span class="comment">//p1移动1个单位</span></span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line">    <span class="keyword">if</span>(p1 == <span class="literal">NULL</span>)&#123;<span class="comment">//链表只有1个节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p2 = p1 -&gt; next;<span class="comment">//p2移动两个单位</span></span><br><span class="line">    <span class="keyword">while</span>(p1 != p2 &amp;&amp; p2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p2 = p2-&gt;next;<span class="comment">//p2移动两个单位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//存在环，首先求环的长度</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>, p2 = p2-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p2 != p1)&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时cnt就是环的长度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//求环的起点</span></span><br><span class="line">        p1 = list;</span><br><span class="line">        <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时p1与p2都指向环的起点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="简单证明"><a href="#简单证明" class="headerlink" title="简单证明"></a>简单证明</h3><p>借鉴于<a target="_blank" rel="noopener" href="https://qht1003077897.github.io/2017/07/03/%E7%AE%97%E6%B3%95-floyd%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/">博客</a> 上面求链表是否存在环及求环的长度的思路都很好理解，主要是为什么p1与p2再次相遇就是环的起点呢？这里假设从跑道的起始点A到环的起点B的路程为m，从B到相遇点C的路程为k，环的长度为n，相遇时乌龟的爬行路程为$S_1 = m + k + t_1 * n$，兔子的奔跑距离为$S_2 = m + k + t_2 * n(t_2 &gt; t_1)$，兔子的速度是乌龟的两倍即$S_2 = 2 * S_1$，则$S_1 = S_2 - S_1 = (t_2 - t_1) * n$，$S_2 = 2 * (t_2 - t_1) * n$即兔子和乌龟相遇时的奔跑距离为环的整数倍，而$m + k = (t_2 - 2 * t_1) * n$也为环的整数倍。当兔子回到跑道的起始位置，乌龟从相遇点B出发时，这时，两人的速度均为单位时间内爬行1个长度，当兔子到达环的起点B即爬行了m距离时，乌龟则是k+m，此时刚好爬行环的整数倍，也处于环的起点B，即乌龟与兔子再次相遇的位置即为环的起点位置B。</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>空间复杂度</li>
</ul>
<p>空间复杂度为：$O(1)$。使用的p1，p2，cnt均为常量空间。</p>
<ul>
<li>时间复杂度</li>
</ul>
<p>假设链表中存在环，则p1移动m个长度即可到达环的起点，p2与p1间的最大距离为n-1。而p2移动速度是p1的两倍，每个单位时间内可以将其与p1的距离缩短1，则最多n-1时间，即可与p1相遇。时间复杂度为$O(m + n)$，即线性时间。</p>
<h2 id="Brent的移动的兔子和传送的乌龟"><a href="#Brent的移动的兔子和传送的乌龟" class="headerlink" title="Brent的移动的兔子和传送的乌龟"></a>Brent的移动的兔子和传送的乌龟</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>How do you determine if your singly-linked list has a cycle? In 1980, Brent invented an algorithm that not only worked in linear time, but required less stepping than Floyd’s Tortoise and the Hare algorithm (however it is slightly more complex). Although stepping through a ‘regular’ linked list is computationally easy, these algorithms are also used for factorization and pseudorandom number generators, linked lists are implicit and finding the next member is computationally difficult.</p>
</blockquote>
<p>引用自<a target="_blank" rel="noopener" href="http://www.siafoo.net/algorithm/11">网站</a> 1980年，Brent提出了一种算法，不仅能在线性时间内找到环，并且使用的步数比Floyd的判圈算法要少。</p>
<h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><blockquote>
<p><img src="/images/2020/02/677e7ad79f99cd994a480aaa03b4b11b.png" alt=""> Brent’s algorithm features a moving rabbit and a stationary, then teleporting, turtle. Both turtle and rabbit start at the top of the list. The rabbit takes one step per iteration. If it is then at the same position as the stationary turtle, there is obviously a loop. If it reaches the end of the list, there is no loop. Of course, this by itself will take infinite time if there is a loop. So every once in a while, we teleport the turtle to the rabbit’s position, and let the rabbit continue moving. We start out waiting just 2 steps before teleportation, and we double that each time we move the turtle.</p>
</blockquote>
<p>相比Floyd的兔子与乌龟，Brent的兔子仍然移动，但乌龟静止，达到传送时间t时，乌龟直接移动到兔子当前的位置，然后传送时间t翻倍（t = 2 * t），如此下去，如果兔子到达终点，则表示不存在环，如果兔子与乌龟相遇（兔子回到自己曾去达的位置）表示有环。</p>
<h3 id="算法效率"><a href="#算法效率" class="headerlink" title="算法效率"></a>算法效率</h3><blockquote>
<p>Note that like Floyd’s Tortoise and Hare algorithm, this one runs in O(N). However you’re doing less stepping than with Floyd’s (in fact the upper bound for steps is the number you would do with Floyd’s algorithm). According to Brent’s research, his algorithm is 24-36% faster on average for implicit linked list algorithms.</p>
</blockquote>
<p>兔子仍在不断移动，乌龟的传送使得其位置瞬移，缩短了它与兔子相遇时间。并且传送等待时间的不断翻倍，保证了兔子与乌龟在有限的时间内一定能相遇。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><ul>
<li>伪代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">turtle = top</span><br><span class="line">rabbit = top</span><br><span class="line"></span><br><span class="line">steps_taken = 0</span><br><span class="line">step_limit = 2</span><br><span class="line"></span><br><span class="line">forever:</span><br><span class="line">    if rabbit == end:</span><br><span class="line">       return &#x27;No Loop Found&#x27;</span><br><span class="line">    rabbit = rabbit.next</span><br><span class="line"></span><br><span class="line">    steps_taken += 1</span><br><span class="line"></span><br><span class="line">    if rabbit == turtle:</span><br><span class="line">        return &#x27;Loop found&#x27;</span><br><span class="line"></span><br><span class="line">    if steps_taken == step_limit:</span><br><span class="line">        steps_taken = 0</span><br><span class="line">        step_limit *= 2</span><br><span class="line">        // teleport the turtle</span><br><span class="line">        turtle = rabbit</span><br></pre></td></tr></table></figure>
<p>引用自<a target="_blank" rel="noopener" href="http://www.siafoo.net/algorithm/11">网站</a></p>
<ul>
<li>c++代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span><span class="comment">//链表节点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node * next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">findCircle</span><span class="params">(Node * list)</span></span>&#123;</span><br><span class="line">    Node* p1  = list-&gt;next, *p2 = list;<span class="comment">//p1移动1个单位</span></span><br><span class="line">    <span class="type">int</span> steps_taken = <span class="number">1</span>, step_limit = <span class="number">2</span>;</span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line">    <span class="keyword">if</span>(p1 == <span class="literal">NULL</span>)&#123;<span class="comment">//链表只有1个节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 != p2 &amp;&amp; p1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        ++steps_taken;</span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(steps_taken == step_limit)&#123;<span class="comment">//达到传送时间</span></span><br><span class="line">            steps_taken = <span class="number">0</span>;<span class="comment">//步数清0</span></span><br><span class="line">            step_limit = step_limit * <span class="number">2</span>;<span class="comment">//传送时间翻倍</span></span><br><span class="line">            p2 = p1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p1 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//存在环，首先求环的长度</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>, p2 = p2-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p2 != p1)&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时cnt就是环的长度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//求环的起点</span></span><br><span class="line">        p1 = list;</span><br><span class="line">        <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时p1与p2都指向环的起点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/03/transforms-topilimage-pic-should-be-tensor-or-ndarray/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Onwaier">
      <meta itemprop="description" content="Onwaier的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Onwaier's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/03/transforms-topilimage-pic-should-be-tensor-or-ndarray/" class="post-title-link" itemprop="url">transforms.ToPILImage(): pic should be Tensor or ndarray</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-03 23:20:26" itemprop="dateCreated datePublished" datetime="2020-02-03T23:20:26+08:00">2020-02-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-02-13 13:43:28" itemprop="dateModified" datetime="2022-02-13T13:43:28+08:00">2022-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/pytorch/" itemprop="url" rel="index"><span itemprop="name">pytorch</span></a>
        </span>
    </span>

  
    <span id="/2020/02/03/transforms-topilimage-pic-should-be-tensor-or-ndarray/" class="post-meta-item leancloud_visitors" data-flag-title="transforms.ToPILImage(): pic should be Tensor or ndarray" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/02/03/transforms-topilimage-pic-should-be-tensor-or-ndarray/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/03/transforms-topilimage-pic-should-be-tensor-or-ndarray/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/pytorch/vision/issues/408">transforms.ToPILImage(): pic should be Tensor or ndarray</a></li>
</ol>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>对UNet网络完成训练，需要输入一张图片，测试输出的概率图是否接近分割出的人脸。网络的输入为<code>(num, 3, w, h)</code>4维度tensor。输出仍为<code>(num, 1, w, h)</code>4维度的tensor，我的目标是将输出的tensor转为图像，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inputs = inputs.view(-<span class="number">1</span>, c, h, w)</span><br><span class="line"><span class="comment">#inputs = inputs.cuda()</span></span><br><span class="line"></span><br><span class="line">inputs = Variable(inputs, volatile=<span class="literal">True</span>)</span><br><span class="line">outputs = net(inputs)</span><br><span class="line"><span class="built_in">print</span>(outputs.shape)</span><br><span class="line">transforms.ToPILImage()(outputs).convert(<span class="string">&#x27;L&#x27;</span>).save(<span class="string">&#x27;test2.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>运行出现错误<code>transforms.ToPILImage(): pic should be Tensor or ndarray</code>。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>查阅<a target="_blank" rel="noopener" href="https://github.com/pytorch/vision/issues/408">资料1</a>，出错是因为</p>
<blockquote>
<p>All images in torchvision have to be represented as 3-dimensional tensors of the form [Channel, Height, Width]. I’m guessing your float tensor is a 2d tensor (height x width). For example, this works:</p>
</blockquote>
<p>即torchvision中的所有图像必须是三维的tensor表示的，而我代码中的outputs未经处理时，是四维的。所以需要进行维度转换。修改后代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inputs = inputs.view(-<span class="number">1</span>, c, h, w)</span><br><span class="line"><span class="comment">#inputs = inputs.cuda()</span></span><br><span class="line"></span><br><span class="line">inputs = Variable(inputs, volatile=<span class="literal">True</span>)</span><br><span class="line">outputs = net(inputs)</span><br><span class="line"><span class="built_in">print</span>(outputs.shape)</span><br><span class="line">outputs = outputs.view(<span class="number">1</span>, h, w)  <span class="comment"># 转成3维的 很重要！！！</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(outputs))</span><br><span class="line">transforms.ToPILImage()(outputs).convert(<span class="string">&#x27;L&#x27;</span>).save(<span class="string">&#x27;test2.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/03/typeerror-default-collate-batch-must-contain-tensors-numpy-arrays-numbers-dicts-or-lists-found/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Onwaier">
      <meta itemprop="description" content="Onwaier的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Onwaier's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/03/typeerror-default-collate-batch-must-contain-tensors-numpy-arrays-numbers-dicts-or-lists-found/" class="post-title-link" itemprop="url">TypeError: default_collate: batch must contain tensors, numpy arrays, numbers, dicts or lists; found </a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-03 11:40:21" itemprop="dateCreated datePublished" datetime="2020-02-03T11:40:21+08:00">2020-02-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-02-13 13:43:28" itemprop="dateModified" datetime="2022-02-13T13:43:28+08:00">2022-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/pytorch/" itemprop="url" rel="index"><span itemprop="name">pytorch</span></a>
        </span>
    </span>

  
    <span id="/2020/02/03/typeerror-default-collate-batch-must-contain-tensors-numpy-arrays-numbers-dicts-or-lists-found/" class="post-meta-item leancloud_visitors" data-flag-title="TypeError: default_collate: batch must contain tensors, numpy arrays, numbers, dicts or lists; found " title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/02/03/typeerror-default-collate-batch-must-contain-tensors-numpy-arrays-numbers-dicts-or-lists-found/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/03/typeerror-default-collate-batch-must-contain-tensors-numpy-arrays-numbers-dicts-or-lists-found/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://discuss.pytorch.org/t/image-file-reading-typeerror-batch-must-contain-tensors-numbers-dicts-or-lists-found-class-pil-image-image/9909">issue</a></li>
</ol>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>原始网络用来训练一个表情分类的网络，对输入的图像进行了变换；我将其换成了一个图像分割的网络，目标值从原来的表情标签变成了01概率图的ground truth，此时不能再对输入图像进行变换，因为ground truth不能随之变换。所以我将<code>transform</code>赋值为<code>None</code>,再次训练网络时，出现了错误<strong>TypeError: default_collate: batch must contain tensors, numpy arrays, numbers, dicts or lists; found</strong> 。</p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>查阅<a target="_blank" rel="noopener" href="https://discuss.pytorch.org/t/image-file-reading-typeerror-batch-must-contain-tensors-numbers-dicts-or-lists-found-class-pil-image-image/9909">相关问题</a>的回答。</p>
<blockquote>
<p>The error states that the DataLoader receives a PIL image. This is because there are no transforms made (transform=None) on the image. The <strong>getitem</strong> method of MyDataset passes an unprocessed PIL image to the DataLoader, whereas it should receive a tensor. You can add a transform that creates a tensor from the PIL image by adding transform:</p>
</blockquote>
<p>将<code>PIL image</code>交给<code>DataLoader</code>，必须要将<code>PIL image</code>先进行处理，即将其转为<code>tensor</code>，所以对图片仍需进行<code>transform</code>，将其它随机裁剪注释掉，仅保留<code>PIP image</code>转为<code>tensor</code>的代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">transform_train = transforms.Compose([</span><br><span class="line">    <span class="comment">#transforms.RandomCrop(44),</span></span><br><span class="line">    <span class="comment">#transforms.RandomHorizontalFlip(),</span></span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">transform_test = transforms.Compose([</span><br><span class="line">    <span class="comment">#transforms.TenCrop(cut_size),</span></span><br><span class="line">    transforms.Lambda(<span class="keyword">lambda</span> crops: torch.stack([transforms.ToTensor()(crop) <span class="keyword">for</span> crop <span class="keyword">in</span> crops])),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/03/numpy%EF%BC%8Copencv%E5%8F%8Aipl-image-%E6%A0%BC%E5%BC%8F%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Onwaier">
      <meta itemprop="description" content="Onwaier的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Onwaier's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/03/numpy%EF%BC%8Copencv%E5%8F%8Aipl-image-%E6%A0%BC%E5%BC%8F%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/" class="post-title-link" itemprop="url">Numpy，Opencv及PIL.Image 格式相互转换</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-03 03:05:06" itemprop="dateCreated datePublished" datetime="2020-02-03T03:05:06+08:00">2020-02-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-02-13 14:27:22" itemprop="dateModified" datetime="2022-02-13T14:27:22+08:00">2022-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/pytorch/" itemprop="url" rel="index"><span itemprop="name">pytorch</span></a>
        </span>
    </span>

  
    <span id="/2020/02/03/numpy%EF%BC%8Copencv%E5%8F%8Aipl-image-%E6%A0%BC%E5%BC%8F%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/" class="post-meta-item leancloud_visitors" data-flag-title="Numpy，Opencv及PIL.Image 格式相互转换" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/02/03/numpy%EF%BC%8Copencv%E5%8F%8Aipl-image-%E6%A0%BC%E5%BC%8F%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/03/numpy，opencv及ipl-image-格式相互转换/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31261509/article/details/94383575">Python OpenCV中的numpy与图像类型转换</a> </li>
<li><a target="_blank" rel="noopener" href="https://github.com/llSourcell/Object_Detection_demo_LIVE/issues/6">解决ndarray的类型错误</a> </li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_19707521/article/details/78367617">Python OpenCV格式和PIL.Image格式 互转</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/706086c1b8ba">python模块 opencv-python与PIL.Image图像常用方法与相互转换</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/87441580">OpenCV读取图片与PIL读取图片的差别</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/JohinieLi/article/details/81012572">python中PIL.Image，OpenCV，Numpy图像格式相互转换</a> </li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/tsq292978891/article/details/78767326">PIL.Image和np.ndarray图片与Tensor之间的转换</a></li>
</ol>
<h2 id="Numpy与Opencv格式互转"><a href="#Numpy与Opencv格式互转" class="headerlink" title="Numpy与Opencv格式互转"></a>Numpy与Opencv格式互转</h2><p>参照<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31261509/article/details/94383575">资料1</a></p>
<blockquote>
<p>Python OpenCV存储图像使用的是Numpy存储，所以可以将Numpy当做图像类型操作，操作之前还需进行类型转换，转换到int8类型</p>
</blockquote>
<p>对Opencv存储的图像格式进行验证</p>
<ul>
<li><strong>输入：</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">numpy与Opencv图像类型的转换</span></span><br><span class="line"><span class="string">&gt; Python OpenCV存储图像使用的是Numpy存储，所以可以将Numpy当做图像类型操作，操作之前还需进行类型转换，转换到int8类型</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;./Messi.jpg&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;shape:&quot;</span> + <span class="built_in">str</span>(img.shape))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(img)) <span class="comment">#数据类型显示为numpy.ndarray</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>输出：</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shape:(500, 500, 3)</span><br><span class="line">&lt;class &#x27;numpy.ndarray&#x27;&gt;</span><br></pre></td></tr></table></figure>
<p>存储类型为numpy.ndarray，这是否表明numpy与Opencv可以直接互操作呢？答案是否定的。因为图像存放时，每个像素值都是非负的，并且取值范围受限于存储位数的限制，所以将numpy.ndarray存储为图像格式，需要先将其进行类型转换。</p>
<ul>
<li><strong>输入：</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">array = np.ones([<span class="number">20</span>, <span class="number">30</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;shape:&quot;</span> + <span class="built_in">str</span>(array.shape))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(array)) <span class="comment">#数据类型显示numpy.ndarray 与Opencv图像类型格式相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以将ndarray作为Opencv图片进行处理，但在处理之前一般进行类型转换</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">类型转换时需注意，我参照博客转成int8类型，可以写入，但是单通道转多通道会出错</span></span><br><span class="line"><span class="string">Assertion failed) VScn::contains(scn) &amp;&amp; VDcn::contains(dcn) &amp;&amp; VDepth::contains(depth) in function &#x27;CvtHelper&#x27;</span></span><br><span class="line"><span class="string">参照github是类型错误导致的</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">array = np.uint8(array)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;shape:&quot;</span> + <span class="built_in">str</span>(array.shape))</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;test.jpg&#x27;</span>, array)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类型转换</span></span><br><span class="line">array = cv2.cvtColor(array, cv2.COLOR_GRAY2BGR)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;shape:&quot;</span> + <span class="built_in">str</span>(array.shape))</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;test2.jpg&#x27;</span>, array)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>输出：</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shape:(20, 30)</span><br><span class="line">&lt;class &#x27;numpy.ndarray&#x27;&gt;</span><br><span class="line">shape:(20, 30)</span><br><span class="line">shape:(20, 30, 3)</span><br></pre></td></tr></table></figure>
<p>正如注释所写，类型转换时，要注意，我参照<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31261509/article/details/94383575">资料1</a>转为int8，在通道转换时出现了错误<strong>Assertion failed) VScn::contains(scn) &amp;&amp; VDcn::contains(dcn) &amp;&amp; VDepth::contains(depth) in function ‘CvtHelper’</strong>，参照<a target="_blank" rel="noopener" href="https://github.com/llSourcell/Object_Detection_demo_LIVE/issues/6">资料2</a>进行解决。</p>
<h2 id="IPL-Image与Opencv相互转换"><a href="#IPL-Image与Opencv相互转换" class="headerlink" title="IPL.Image与Opencv相互转换"></a>IPL.Image与Opencv相互转换</h2><p>先复习一下Opencv与IPL.Image的读，写，显示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Opencv 图像的读，写，显示</span></span><br><span class="line"><span class="string">PIL.Image的读，写，显示</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Opencv读</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;Messi.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># Opencv写</span></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;Messi2.jpg&#x27;</span>, img)</span><br><span class="line"><span class="comment"># Opencv显示</span></span><br><span class="line">cv2.imshow(<span class="string">&#x27;Messi&#x27;</span>, img)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># PIL.Image读</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&#x27;Messi.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># PIL.Image写</span></span><br><span class="line">img.save(<span class="string">&#x27;Messi3.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># PIL.Image显示</span></span><br><span class="line">img.show()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Image.open()读取的通道顺序是RGB，cv2.imread()读取的通道顺序为BGR。 Image.open()函数只是保持了图像被读取的状态，但是图像的真实数据并未被读取，因此如果对需要操作图像每个元素，如输出某个像素的RGB值等，需要执行对象的load()方法读取数据 PIL.Image.save()直接保存RGB的图片 cv2.imwirte()保存图片的时候相当于做了BGR2RGB再去保存</p>
</blockquote>
<p><strong>OpenCV转换成PIL.Image格式</strong></p>
<ul>
<li><strong>代码：</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line"><span class="keyword">import</span> numpy </span><br><span class="line">img = cv2.imread(<span class="string">&quot;Messi.jpg&quot;</span>)</span><br><span class="line">cv2.imshow(<span class="string">&quot;OpenCV&quot;</span>,img)</span><br><span class="line">Image.fromarray(cv2.cvtColor(img,cv2.COLOR_BGR2RGB))  </span><br></pre></td></tr></table></figure>
<p><strong>PIL.Image转换成OpenCV格式：</strong></p>
<ul>
<li><strong>代码：</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line"><span class="keyword">import</span> numpy  </span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">&quot;Messi.jpg&quot;</span>)  </span><br><span class="line">img = cv2.cvtColor(numpy.asarray(image),cv2.COLOR_RGB2BGR)</span><br></pre></td></tr></table></figure>
<h2 id="PIL-Image与Numpy格式的相互转换"><a href="#PIL-Image与Numpy格式的相互转换" class="headerlink" title="PIL.Image与Numpy格式的相互转换"></a>PIL.Image与Numpy格式的相互转换</h2><p>相当于 Opencv与PIL.Image的相互转换少了通道的变换。</p>
<ul>
<li><strong>Numpy转PIL.Image</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line"><span class="keyword">import</span> numpy </span><br><span class="line">array = np.ones(<span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">Image.fromarray(array)  </span><br></pre></td></tr></table></figure>
<ul>
<li><strong>PIL.Image转Numpy</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy </span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">&quot;Messi.jpg&quot;</span>)</span><br><span class="line">array = numpy.asarray(image)</span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/JohinieLi/article/details/81012572">资料6</a></p>
<h3 id="list与tuple转换"><a href="#list与tuple转换" class="headerlink" title="list与tuple转换"></a>list与tuple转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]<span class="comment">#a is a list</span></span><br><span class="line">b = <span class="built_in">tuple</span>(a) <span class="comment"># b is a tuple</span></span><br><span class="line">c = <span class="built_in">list</span>(b) <span class="comment"># c is a list</span></span><br></pre></td></tr></table></figure>
<h3 id="list-tuple-ndarray转换"><a href="#list-tuple-ndarray转换" class="headerlink" title="list,tuple,ndarray转换"></a>list,tuple,ndarray转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment"># a is a list</span></span><br><span class="line">arr = np.array(a) <span class="comment"># arr is a ndarray</span></span><br><span class="line">b = <span class="built_in">tuple</span>(arr) <span class="comment"># b is a tuple</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)<span class="comment"># a is a tuple</span></span><br><span class="line">arr = np.arr(a) <span class="comment"># arr is a ndarray</span></span><br><span class="line">b = <span class="built_in">list</span>(arr) <span class="comment"># b is a list</span></span><br></pre></td></tr></table></figure>
<h3 id="torch的tensor与numpy转换"><a href="#torch的tensor与numpy转换" class="headerlink" title="torch的tensor与numpy转换"></a>torch的tensor与numpy转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tensor 转numpy</span></span><br><span class="line">array = a.numpy() <span class="comment"># a is a tensor</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy 转tensor</span></span><br><span class="line">torch.from_numpy(array) <span class="comment"># array is a ndarray</span></span><br></pre></td></tr></table></figure>
<h3 id="tensor与PIL-image转换"><a href="#tensor与PIL-image转换" class="headerlink" title="tensor与PIL image转换"></a>tensor与PIL image转换</h3><p>pytorch官方提供了<code>torchvision.transforms</code>包,可以用<code>transforms</code>来实现tensor 与PIL image的转换</p>
<blockquote>
<p>ToTensor把一个取值范围是[0,255]的PIL.Image或者shape为(H,W,C)的numpy.ndarray，转换成形状为[C,H,W]，取值范围是[0,1.0]的torch.FloadTensor</p>
</blockquote>
<ul>
<li>tensor与PIL image的转换</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># PIL Image转tensor</span></span><br><span class="line"></span><br><span class="line">transform1 = transforms.Compose([</span><br><span class="line">    <span class="keyword">pass</span>, <span class="comment"># 这里可以写对PIL的相关操作（裁剪，旋转等）</span></span><br><span class="line">    transforms.ToTensor(), </span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line">img_PIL = Image.<span class="built_in">open</span>(<span class="string">&#x27;test.jpg&#x27;</span>).convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line">img_PIL_tensor = transform1(img_PIL)<span class="comment"># 将PIL image转为tensor</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(img_PIL))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(img_PIL_tensor))</span><br><span class="line"></span><br><span class="line"><span class="comment"># transforms也提供了tensor转PIL image的方法</span></span><br><span class="line">new_img_PIL = transforms.ToPILImage()(img_PIL_Tensor).convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line"></span><br><span class="line">transform2 = transforms.Compose([</span><br><span class="line">    <span class="keyword">pass</span>, <span class="comment"># transform没有对Opencv的相关操作（裁剪，旋转等）</span></span><br><span class="line">    transforms.ToTensor(), </span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">img_Opencv = cv2.imread(<span class="string">&#x27;test&#x27;</span>.jpg)</span><br><span class="line">img_Opencv_tensor = transform2(img_Opencv)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Onwaier</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"gh8MGlPldauVJHzSrVU7V7K2-gzGzoHsz","app_key":"6PhJuVxYccEhTAXWI26qbzpG","server_url":null,"security":true}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"onwaier-blog","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
