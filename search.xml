<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>11. 盛最多水的容器 - 力扣（LeetCode）</title>
    <url>/2019/08/30/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8-%E5%8A%9B%E6%89%A3%EF%BC%88leetcode%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 n 个非负整数 [latex]a_1，a_2，\\cdots, a_n[/latex]，每个数代表坐标中的一个点 [latex](i, a_i)[/latex] 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 [latex](i, a_i)[/latex] 和[latex](i, 0)[/latex]。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 <a href="https://i.loli.net/2019/08/30/gkMoGLnE9VpHANl.jpg"><img src="https://i.loli.net/2019/08/30/gkMoGLnE9VpHANl.jpg" alt=""></a> 示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出: 49</span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最容易想到的肯定是暴力求解的方法，将所有可能的组合都尝试，然后选取出面积最大的。但是时间复杂度是[latex]o(n^2)[/latex]，运行时间会很长，从执行结果上看，仅击败了5%的用户。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, tmpArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;height.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; height.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">                tmpArea = <span class="built_in">min</span>(height[i], height[j]) * (j - i);</span><br><span class="line">                <span class="keyword">if</span>(tmpArea &gt; res)&#123;</span><br><span class="line">                    res = tmpArea;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><a href="https://i.loli.net/2019/08/30/SCE5Vs83Oy1nxiN.png"><img src="https://i.loli.net/2019/08/30/SCE5Vs83Oy1nxiN.png" alt=""></a></p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>参考官方给出的题解，采用双指针的方法。初始时两指针i与j分别指向数据height的两侧，与x轴构成的容器的面积为: [latex] Area = min(height[i], height[j]) * (j - i)\\\\ [/latex] 然后指向height较小的指针向内侧移动（对i来说，就是增加；对j来说，就是减小），为什么要这做呢？如果较大的指针向内侧移动则[latex] j - i [/latex]的值一定会减小，而[latex] min(height[i], height[j]) [/latex]的值 是小于等于移动之前的min(height[i], height[j])。这样[latex] area [/latex]一定会减小。所以要将较小的指针向内侧移动。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> resArea = <span class="number">0</span>, tmpArea;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            tmpArea = <span class="built_in">min</span>(height[i], height[j]) * (j - i);</span><br><span class="line">            <span class="keyword">if</span>(tmpArea &gt; resArea)&#123;</span><br><span class="line">                resArea = tmpArea;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(height[i] &gt; height[j])&#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h2><p><a href="https://i.loli.net/2019/08/31/1UL7mHCfYVTRJ83.png"><img src="https://i.loli.net/2019/08/31/1UL7mHCfYVTRJ83.png" alt=""></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>15. 三数之和 - 力扣（LeetCode）</title>
    <url>/2019/09/01/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-%E5%8A%9B%E6%89%A3%EF%BC%88leetcode%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最先萌发的肯定是暴力求解的方法，试探每一种可能性。三重循环，时间复杂度比较高，是[latex] O(n^3) [/latex]。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;tmp;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len - <span class="number">1</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; len; ++k)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(k &gt; j + <span class="number">1</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>])&#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span>&#123;</span><br><span class="line">                                <span class="keyword">if</span>(nums[i] + nums[j] + nums[k] == <span class="number">0</span>)&#123;</span><br><span class="line">                                    tmp.<span class="built_in">clear</span>();</span><br><span class="line">                                    tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                                    tmp.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">                                    tmp.<span class="built_in">push_back</span>(nums[k]);</span><br><span class="line">                                    res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p>超出时间限制！！</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>借鉴之前两数之和的思路，用空间来换时间，用哈希表存储前两个数的信息。通过一个数来找另两个数满足三数之和为00。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;temp;</span><br><span class="line">        map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt;myMap;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">//排序一下 是为了去重，但并没有达到想要的效果</span></span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j - <span class="number">1</span>] == nums[j])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(myMap.<span class="built_in">find</span>(nums[j]) != myMap.<span class="built_in">end</span>())&#123;<span class="comment">//存在于map中，则视为符合题意的解</span></span><br><span class="line">                    temp.<span class="built_in">clear</span>();</span><br><span class="line">                    temp.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">                    temp.<span class="built_in">push_back</span>(myMap[nums[j]][<span class="number">0</span>]);</span><br><span class="line">                    temp.<span class="built_in">push_back</span>(myMap[nums[j]][<span class="number">1</span>]);</span><br><span class="line">                    res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;<span class="comment">//不存在，就在map中记录下信息</span></span><br><span class="line">                    temp.<span class="built_in">clear</span>();</span><br><span class="line">                    num = <span class="number">0</span> - nums[i] - nums[j];</span><br><span class="line">                    temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                    temp.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">                    myMap[num] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//该解未能有效去重，不能AC，只是提出一种思路。</span></span><br></pre></td></tr></table></figure>
<h2 id="再优化"><a href="#再优化" class="headerlink" title="再优化"></a>再优化</h2><p>为了便于去重，首先仍是排序，复杂度为[latex] nlog_{2}n [/latex]。然后用双指针的方法，初始化指向数据的首尾，中间数b，保持不动。判断a+b+c。若a+b+c &gt; 0则需减小，尾指针向左移动；若a+b+c &lt; 0则需增大，头指针向右移动。将有某个指针指向b时，则结束。调整b，继续上次操作。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>(), beg, end, cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(beg &lt; i &amp;&amp; end &gt; i)&#123;<span class="comment">//位于i两侧</span></span><br><span class="line">                <span class="keyword">if</span>(nums[beg] +nums[i] + nums[end] &gt; <span class="number">0</span>)&#123;<span class="comment">//偏大，减小</span></span><br><span class="line">                    --end;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[beg] + nums[i] + nums[end] &lt; <span class="number">0</span>)&#123;<span class="comment">//偏小，增大</span></span><br><span class="line">                    ++beg;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;<span class="comment">//刚好，同时移动</span></span><br><span class="line">                    <span class="type">int</span> a[<span class="number">3</span>] = &#123;nums[beg], nums[i], nums[end]&#125;;</span><br><span class="line">                    vector&lt;<span class="type">int</span>&gt;<span class="built_in">tmp</span>(a, a + <span class="number">3</span>);</span><br><span class="line">                    res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                    <span class="keyword">while</span>(beg &lt; i &amp;&amp; nums[beg + <span class="number">1</span>] == nums[beg]) ++beg;<span class="comment">//去重</span></span><br><span class="line">                    <span class="keyword">while</span>(end &gt; i &amp;&amp; nums[end - <span class="number">1</span>] == nums[end]) --end;<span class="comment">//去重</span></span><br><span class="line">                    ++beg;</span><br><span class="line">                    --end;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//未AC，去重太麻烦了，针对[0, 0, 0, 0]有问题。</span></span><br></pre></td></tr></table></figure>
<h2 id="再再优化"><a href="#再再优化" class="headerlink" title="再再优化"></a>再再优化</h2><p>换个思路，考虑排序后，固定a，两指针分别指向b和c，判断方式仍然相同，当然可以有更多优化，比如a&gt;0时，a+b+c一定大于0，可以直接跳过。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>(), beg, end, sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;<span class="comment">//去重</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            beg = i + <span class="number">1</span>, end = len <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(beg &lt; end)&#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[i] + nums[beg] + nums[end];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    --end;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    ++beg;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i], nums[beg], nums[end]&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(beg &lt; end &amp;&amp; nums[beg] == nums[beg + <span class="number">1</span>])&#123;<span class="comment">//去重</span></span><br><span class="line">                        ++beg;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(beg &lt; end &amp;&amp; nums[end] == nums[end - <span class="number">1</span>])&#123;<span class="comment">//去重</span></span><br><span class="line">                        --end;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++beg;</span><br><span class="line">                    --end;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//AC</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>16. 最接近的三数之和 - 力扣（LeetCode）</title>
    <url>/2019/09/03/16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-%E5%8A%9B%E6%89%A3%EF%BC%88leetcode%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1. 与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最容易想到的方法，肯定是三重循环，暴力求解，但是时间复杂度过高为[latex] O(n^3) [/latex]。 这里借鉴昨天三数之和那一题的解题思路，采用排序+双指针的方法来求解，同样a固定，然后首尾指针分别指向b与c，当a+b+c=target，则最优解就是target。若a+b+c&gt;target，指向c的指针向左移动；若a+b+c&lt;target，指向b的指针向右移动。当两指针相遇本次循环结束，然后更改a的位置，重复上述操作，直到找到最优解。 起初，天真的以为当sum(a+b+c)由大于target转为小于target或者由小于target转为大于target时，就能找到本次循环的最优解，就能跳出循环，后来提交才发现并不是，所以还是老老实实的判断吧。</p>
<h2 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>(), beg, end, sum, res;</span><br><span class="line">        <span class="type">bool</span> posFlag = <span class="literal">false</span>, negFlag = <span class="literal">false</span>, flag = <span class="literal">false</span>;;</span><br><span class="line">        <span class="type">int</span> posSum, negSum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; len - <span class="number">2</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;<span class="comment">//去重</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            beg = i + <span class="number">1</span>, end = len - <span class="number">1</span>;</span><br><span class="line">            posFlag = <span class="literal">false</span>, negFlag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(beg &lt; end)&#123;</span><br><span class="line">                sum = nums[i] + nums[beg] + nums[end];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                    --end;</span><br><span class="line">                    posFlag = <span class="literal">true</span>;</span><br><span class="line">                    posSum = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                    ++beg;</span><br><span class="line">                    negFlag = <span class="literal">true</span>;</span><br><span class="line">                    negSum = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    res = target;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(posFlag &amp;&amp; negFlag)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                        flag = <span class="literal">true</span>;</span><br><span class="line">                        res = posSum - target &gt; target - negSum?negSum:posSum; </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="type">int</span> tmp = posSum - target &gt; target - negSum?negSum:posSum; </span><br><span class="line">                        res = <span class="built_in">abs</span>(tmp - target) &gt; <span class="built_in">abs</span>(res - target)?res:tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag &amp;&amp; res == target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">if</span>(posFlag &amp;&amp; !negFlag)&#123;<span class="comment">//全大于target，取最小</span></span><br><span class="line">                <span class="keyword">if</span>(i + <span class="number">2</span> &lt; len)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                        flag = <span class="literal">true</span>;</span><br><span class="line">                        res = nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="type">int</span> tmp = nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>];</span><br><span class="line">                        res = <span class="built_in">abs</span>(tmp - target) &gt; <span class="built_in">abs</span>(res - target)?res:tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(negFlag &amp;&amp; !posFlag)&#123;<span class="comment">//全小于target，取最大</span></span><br><span class="line">                <span class="keyword">if</span>(i + <span class="number">2</span> &lt; len)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                        flag = <span class="literal">true</span>;</span><br><span class="line">                        res = nums[i] + nums[len - <span class="number">1</span>] + nums[len - <span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="type">int</span> tmp = nums[i] + nums[len - <span class="number">1</span>] + nums[len - <span class="number">2</span>];</span><br><span class="line">                        res = <span class="built_in">abs</span>(tmp - target) &gt; <span class="built_in">abs</span>(res - target)?res:tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag &amp;&amp; res == target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">///未ac</span></span><br></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>(), beg, end, sum, res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; len - <span class="number">2</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                res = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] +nums[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            beg = i + <span class="number">1</span>, end = len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(beg &lt; end)&#123;</span><br><span class="line">                sum = nums[i] + nums[beg] + nums[end];</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(sum - target) &lt; <span class="built_in">abs</span>(res - target))&#123;<span class="comment">//取距离较小的</span></span><br><span class="line">                        res = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sum &gt; target)&#123;<span class="comment">//偏大，减小end</span></span><br><span class="line">                    --end;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;<span class="comment">//偏小，增大beg</span></span><br><span class="line">                    ++beg;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;<span class="comment">//相等，找到最优解，直接返回</span></span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><a href="https://i.loli.net/2019/09/02/r43GOILgJKDQp7s.png"><img src="https://i.loli.net/2019/09/02/r43GOILgJKDQp7s.png" alt=""></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>18. 四数之和 - 力扣（LeetCode）</title>
    <url>/2019/09/03/18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C-%E5%8A%9B%E6%89%A3%EF%BC%88leetcode%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最直接的想法当然是四重循环，暴力求解，复杂度为[latex] O(n^4) [/latex]，直接拉进小黑屋。 因为做过二数之和，三数之和等题，想着能否题目转成已知的问题。因此下面的一个想法就诞生了，固定一个数a，然后问题转成求b + c + d = target - a三数之和的解，使用的方法是排序 + 双指针。然后再改变a找到所有解。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>时间复杂度为$o(n^3)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//先排序</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>(),beg, end, sum;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;<span class="comment">//去重</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len - <span class="number">2</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])&#123;<span class="comment">//去重</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                beg = j + <span class="number">1</span>, end = len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(beg &lt; end)&#123;</span><br><span class="line">                    sum = nums[i] + nums[j] + nums[beg] + nums[end];</span><br><span class="line">                    <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                        --end;</span><br><span class="line">                        <span class="keyword">while</span>(beg &lt; end &amp;&amp; nums[end] == nums[end + <span class="number">1</span>])&#123;</span><br><span class="line">                            --end;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                        ++beg;</span><br><span class="line">                        <span class="keyword">while</span>(beg &lt; end &amp;&amp; nums[beg] == nums[beg - <span class="number">1</span>])&#123;</span><br><span class="line">                            ++beg;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[beg], nums[end]&#125;);</span><br><span class="line">                        ++beg;</span><br><span class="line">                        <span class="keyword">while</span>(beg &lt; end &amp;&amp; nums[beg] == nums[beg - <span class="number">1</span>])&#123;</span><br><span class="line">                            ++beg;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><a href="https://i.loli.net/2019/09/03/qONaTJRtvwUZ9Ao.png"><img src="https://i.loli.net/2019/09/03/qONaTJRtvwUZ9Ao.png" alt=""></a></p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>借助大佬的思路，加入两个if判断，用时瞬间超过90%！ 1. 如果tmp = a + min{b + c + d}仍然大于target，则整个循环没有继续下去的必要了，后面的四数之和不小于tmp，即大于target。 2. 如果tmp = a + max{b + c + d}仍然小于target，则此趟循环可以continue。 具体见代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//先排序</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>(),beg, end, sum;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;<span class="comment">//去重</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当数组最小值和都大于target 跳出</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[i+<span class="number">1</span>] + nums[i+<span class="number">2</span>] + nums[i+<span class="number">3</span>] &gt; target)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//当数组最大值和都小于target,说明i这个数还是太小,遍历下一个</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[len<span class="number">-1</span>] + nums[len<span class="number">-2</span>] + nums[len<span class="number">-3</span>] &lt; target)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len - <span class="number">2</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])&#123;<span class="comment">//去重</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                beg = j + <span class="number">1</span>, end = len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(beg &lt; end)&#123;</span><br><span class="line">                    sum = nums[i] + nums[j] + nums[beg] + nums[end];</span><br><span class="line">                    <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                        --end;</span><br><span class="line">                        <span class="keyword">while</span>(beg &lt; end &amp;&amp; nums[end] == nums[end + <span class="number">1</span>])&#123;</span><br><span class="line">                            --end;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                        ++beg;</span><br><span class="line">                        <span class="keyword">while</span>(beg &lt; end &amp;&amp; nums[beg] == nums[beg - <span class="number">1</span>])&#123;</span><br><span class="line">                            ++beg;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[beg], nums[end]&#125;);</span><br><span class="line">                        ++beg;</span><br><span class="line">                        <span class="keyword">while</span>(beg &lt; end &amp;&amp; nums[beg] == nums[beg - <span class="number">1</span>])&#123;</span><br><span class="line">                            ++beg;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h2><p><a href="https://i.loli.net/2019/09/03/SOZdBcaohL47iys.png"><img src="https://i.loli.net/2019/09/03/SOZdBcaohL47iys.png" alt=""></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>1. 两数之和 - 力扣（LeetCode）</title>
    <url>/2019/08/29/1%E3%80%81%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-%E5%8A%9B%E6%89%A3%EF%BC%88leetcode%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最初的思路：双重循环，判断2个数之和是否为目标值，如果是则直接找到解，跳出循环；否则，继续循环。</p>
<h2 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;<span class="comment">//用于标记是否找到题解</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123; <span class="comment">//双重循环，暴力判断。</span></span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                        res.<span class="built_in">push_back</span>(j);</span><br><span class="line">                        flag = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><a href="https://i.loli.net/2019/08/28/63hCvmMyJjPYBk4.png"><img src="https://i.loli.net/2019/08/28/63hCvmMyJjPYBk4.png" alt=""></a></p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>有效判断数组中是否存在目标元素，并且能返回下标的快速方法是哈希表 将值及索引添加到哈希表中，建立索引。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;myMap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(myMap.<span class="built_in">find</span>(nums[i]) != myMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(myMap[nums[i]]);</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            myMap[target - nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h3><p><a href="https://i.loli.net/2019/08/29/AlMcLFwp4ZrOiab.png"><img src="https://i.loli.net/2019/08/29/AlMcLFwp4ZrOiab.png" alt=""></a></p>
<h3 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h3><p>unordered_map对元素的查询速度要比map快，这里可以用unordered_map代替map。</p>
<h3 id="优化代码如下："><a href="#优化代码如下：" class="headerlink" title="优化代码如下："></a>优化代码如下：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;myMap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(myMap.<span class="built_in">find</span>(nums[i]) != myMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(myMap[nums[i]]);</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            myMap[target - nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="优化代码执行结果"><a href="#优化代码执行结果" class="headerlink" title="优化代码执行结果"></a>优化代码执行结果</h3><p><a href="https://i.loli.net/2019/08/29/JAWcU79snLzrNqh.png"><img src="https://i.loli.net/2019/08/29/JAWcU79snLzrNqh.png" alt=""></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>26. 删除排序数组中的重复项 - 力扣（LeetCode）</title>
    <url>/2019/09/04/26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-%E5%8A%9B%E6%89%A3%EF%BC%88leetcode%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 <strong>示例1</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定数组 nums = [1,1,2], </span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p><strong>示例2</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先数组是有序的，若相邻两元素相等，则存在重复元素（计数器cnt加1）那么移除重复元素后，原位置i的元素现在应在i-cnt处，即nums[i - cnt] = nums[i]。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>(); <span class="comment">//获取数组长度</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;<span class="comment">//统计重复元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i - <span class="number">1</span>])&#123;<span class="comment">//元素重复</span></span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                nums[i - cnt] = nums[i];<span class="comment">//元素前移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len - cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><a href="https://i.loli.net/2019/09/04/cDoZepkx2jGEIgH.png"><img src="https://i.loli.net/2019/09/04/cDoZepkx2jGEIgH.png" alt=""></a></p>
<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>采用双指针，一个快指针j，一个慢指针i，如果相邻元素相等，j++；如果不等，则i++，并把不等的元素复制到i处即 nums[i] = nums[j]，重复相同过程，直到j指向数组末尾。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>(); <span class="comment">//获取数组长度</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;<span class="comment">//数组长度为0直接返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; len; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] != nums[i])&#123;<span class="comment">//元素不等时，移动指针i，并进行复制操作。</span></span><br><span class="line">                ++i;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><a href="https://i.loli.net/2019/09/04/VTWJMdLhB7KymIq.png"><img src="https://i.loli.net/2019/09/04/VTWJMdLhB7KymIq.png" alt=""></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>27. 移除元素 - 力扣（LeetCode）</title>
    <url>/2019/09/04/27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8A%9B%E6%89%A3%EF%BC%88leetcode%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定 nums = [3,2,2,3], val = 3,</span><br><span class="line">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定 nums = [0,1,2,2,3,0,4,2], val = 2,</span><br><span class="line">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>和上一题的思路基本相似 统计val元素的个数，对于不等于val的元素(nums[i])找到删除val其位置（i - cnt）。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;<span class="comment">//数组长度为0直接返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)&#123;<span class="comment">//统计val出现的次数</span></span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                nums[i - cnt] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len - cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><a href="https://i.loli.net/2019/09/04/AV9FakEzUimSCec.png"><img src="https://i.loli.net/2019/09/04/AV9FakEzUimSCec.png" alt=""></a></p>
<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>同样可以采用双指针。同上一题</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;<span class="comment">//数组长度为0直接返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; len; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] != val)&#123;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h2><p><a href="https://i.loli.net/2019/09/04/vaxUksIRzgCjnui.png"><img src="https://i.loli.net/2019/09/04/vaxUksIRzgCjnui.png" alt=""></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>31. 下一个排列 - 力扣（LeetCode）</title>
    <url>/2019/09/05/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97-%E5%8A%9B%E6%89%A3%EF%BC%88leetcode%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这里借用<a href="https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-by-leetcode/">官方题解</a>的一张动图来加深理解解法。 <a href="https://i.loli.net/2019/09/05/t2CfmOXZgQuGvIw.gif"><img src="https://i.loli.net/2019/09/05/t2CfmOXZgQuGvIw.gif" alt=""></a> 如果整个序列是降序的，则它是排列中最大字典序，没有其它排列的字典序比它还要大。那么我们第一步就是从右往左循环一遍，看是否存在nums[i - 1] &lt; nums[i]；不存在，则直接按题意将整个序列逆序；存在，则再从右往左扫一遍，找第一个比nums[i - 1]大的数nums[j]，交换nums[i - 1]与nums[j]的位置。再把nums[i - 1]后的序列(降序)逆序为升序。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>(), i = len - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> j = len - <span class="number">1</span>, tmp;</span><br><span class="line">        <span class="keyword">while</span>(i &gt; <span class="number">0</span> &amp;&amp;nums[i] &lt;= nums[i - <span class="number">1</span>]) --i;<span class="comment">//寻找满足升序的相邻两个数</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &lt;= nums[i - <span class="number">1</span>]) --j;<span class="comment">//找第一个比nums[i - 1]大的数，然后交换位置</span></span><br><span class="line">            tmp = nums[i - <span class="number">1</span>];</span><br><span class="line">            nums[i - <span class="number">1</span>] = nums[j];</span><br><span class="line">            nums[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + i, nums.<span class="built_in">end</span>());<span class="comment">//将nums[i - 1]后的序列逆序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><a href="https://i.loli.net/2019/09/05/8Zx6thCKoqaQWBR.png"><img src="https://i.loli.net/2019/09/05/8Zx6thCKoqaQWBR.png" alt=""></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>33. 搜索旋转排序数组 - 力扣（LeetCode）</title>
    <url>/2019/09/06/33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-%E5%8A%9B%E6%89%A3%EF%BC%88leetcode%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1: 输入: nums = [4,5,6,7,0,1,2], target = 0 输出: 4 示例 2: 输入: nums = [4,5,6,7,0,1,2], target = 3 输出: -1</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>看到题目要求的复杂度为[latex] o(log_2n) [/latex],首先想到的二分查找法，但一般的适用场景是整体有序，对于这种情况，如果我们能确定旋转位置rotate_idx，则整个序列分成两部分：[0, rotate_idx)和[rotate_idx, nums.size())。当target &gt;= nums[0]时target只可能出现前一部分，反之，则出现后一部分。 如何确定rotate_idx？借鉴官方题解，这里也采用二分法。 [0, rotate_idx)和[rotate_idx, nums.size())有以下特点： [latex] \\begin {split} nums[0] &lt; nums[1] &lt; \\cdots&lt; nums[rotate\\_idx - 1] &gt; \\\\ nums[rotate\\_idx] &lt;\\cdots nums[rotate_idx]即可。 具体二分的方式查看代码。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一步：寻找旋转点,最小元素的下标</span></span><br><span class="line">        <span class="type">int</span> beg = <span class="number">0</span>, end = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid = (beg + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> rotate_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;<span class="comment">//特殊情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(beg &lt;= end)&#123;</span><br><span class="line">            mid = (beg + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; nums[mid] &gt; nums[mid + <span class="number">1</span>])&#123;</span><br><span class="line">                rotate_index = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt;= nums[beg])&#123;<span class="comment">//搜索右边序列</span></span><br><span class="line">                beg = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//搜索左边序列</span></span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二步：确认target会出现在哪个区域[0, rotate_index)或[rotate_index, nums.size())</span></span><br><span class="line">        <span class="keyword">if</span>(target &gt;= nums[<span class="number">0</span>])&#123;<span class="comment">//目标值大于nums[0]，左边查找</span></span><br><span class="line">            beg = <span class="number">0</span>, end = (rotate_index == <span class="number">0</span>?nums.<span class="built_in">size</span>() - <span class="number">1</span>:rotate_index - <span class="number">1</span>);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            beg = rotate_index;</span><br><span class="line">            end = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(beg &lt;= end)&#123;<span class="comment">//第三步：二分查找目标值</span></span><br><span class="line">            mid = (beg + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                beg = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(beg &gt; end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><a href="https://i.loli.net/2019/09/06/aOJQU1euWzblorP.png"><img src="https://i.loli.net/2019/09/06/aOJQU1euWzblorP.png" alt=""></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</title>
    <url>/2019/09/08/34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 示例 1: 输入: nums = [5,7,7,8,8,10], target = 8 输出: [3,4] 示例 2: 输入: nums = [5,7,7,8,8,10], target = 6 输出: [-1,-1]</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先想到的是二分法找到一个target的值，然后再以此为起点，分别往前和往后找，确定target出现的开始位置和结束位置。 但这样做的是时间度是O(logn + n)即O(n)，不符合题目中O(logn)的要求。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> beg = <span class="number">0</span>, end = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid, l_idx = <span class="number">-1</span>, r_idx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(beg &lt;= end)&#123;<span class="comment">//二分法先找到一个target的位置</span></span><br><span class="line">            mid = (beg + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                beg = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(beg &gt; end)&#123;</span><br><span class="line">            l_idx = r_idx = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//寻找起始位置</span></span><br><span class="line">            l_idx = mid;</span><br><span class="line">            <span class="keyword">while</span>(l_idx &gt;= <span class="number">0</span> &amp;&amp; nums[l_idx] == target)&#123;</span><br><span class="line">                --l_idx;</span><br><span class="line">            &#125;</span><br><span class="line">            ++l_idx;</span><br><span class="line">            <span class="comment">//寻找终点位置</span></span><br><span class="line">            r_idx = mid;</span><br><span class="line">            <span class="keyword">while</span>(r_idx &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[r_idx] == target)&#123;</span><br><span class="line">                ++r_idx;</span><br><span class="line">            &#125;</span><br><span class="line">            --r_idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;l_idx, r_idx&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><a href="https://i.loli.net/2019/09/08/95lpweYCIO4kxTL.png"><img src="https://i.loli.net/2019/09/08/95lpweYCIO4kxTL.png" alt=""></a></p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>两次二分，第一次二分找到某个target的位置pos，将l_idx与r_idx的值更新为pos,然后第二次二分分为两部分：左半边二分找到target更新l_idx,beg1 &gt; end1结束；右半边找到target更新r_idx，beg2 &gt; end2结束。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> beg = <span class="number">0</span>, end = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid, l_idx = <span class="number">-1</span>, r_idx = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> beg1, end1, beg2, end2, mid1, mid2;</span><br><span class="line">        <span class="keyword">while</span>(beg &lt;= end)&#123;</span><br><span class="line">            mid = (beg + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                beg = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(beg &lt;= end)&#123;</span><br><span class="line">            l_idx = mid;</span><br><span class="line">            r_idx = mid;</span><br><span class="line">            beg1 = beg;</span><br><span class="line">            end1 = mid - <span class="number">1</span>;</span><br><span class="line">            beg2 = mid + <span class="number">1</span>;</span><br><span class="line">            end2 = end;</span><br><span class="line">            <span class="keyword">while</span>(beg1 &lt;= end1)&#123;</span><br><span class="line">                mid1 = (beg1 + end1) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid1] &lt; target)&#123;</span><br><span class="line">                    beg1 = mid1 + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    l_idx = mid1;</span><br><span class="line">                    end1 = mid1 - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(beg2 &lt;= end2)&#123;</span><br><span class="line">                mid2 = (beg2 + end2) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid2] &gt; target)&#123;</span><br><span class="line">                    end2 = mid2 - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    r_idx = mid2;</span><br><span class="line">                    beg2 = mid2 + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;l_idx, r_idx&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h2><p><a href="https://i.loli.net/2019/09/08/KYcen6ZsjlRdahS.png"><img src="https://i.loli.net/2019/09/08/KYcen6ZsjlRdahS.png" alt=""></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>35. 搜索插入位置 - 力扣（LeetCode）</title>
    <url>/2019/09/09/35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE-%E5%8A%9B%E6%89%A3%EF%BC%88leetcode%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>二分法查找，不用多说，具体见代码</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> beg = <span class="number">0</span>, end = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid = (beg + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(beg &lt;= end)&#123;<span class="comment">//二分查找法</span></span><br><span class="line">            mid = (beg + end ) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                beg = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><a href="https://i.loli.net/2019/09/09/XWfRiHkwx7zGQTc.png"><img src="https://i.loli.net/2019/09/09/XWfRiHkwx7zGQTc.png" alt=""></a></p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>将mid=(beg+end) / 2改成位移运算，运算效率会高得多。另外看到一篇<a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/">题解</a>,发现自己写的二分查找还是存在许多问题，比如，这次我就在返回beg还是end犹豫了一下，虽然凭直觉选对了，但还是把循环条件改成beg &lt; end来得好。有时间要抽空看看那篇题解，应该会受益匪浅。</p>
<h2 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h2><p><a href="https://i.loli.net/2019/09/09/fDUpFTSCWzBcrYb.png"><img src="https://i.loli.net/2019/09/09/fDUpFTSCWzBcrYb.png" alt=""></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>39. 组合总和 - 力扣（LeetCode）</title>
    <url>/2019/09/11/39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E5%8A%9B%E6%89%A3%EF%BC%88leetcode%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1: 输入: candidates = [2,3,6,7], target = 7, 所求解集为: [ [7], [2,2,3] ] 示例 2: 输入: candidates = [2,3,5], target = 8, 所求解集为: [   [2,2,2,2],   [2,3,3],   [3,5] ]</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>递归搜索+剪枝 详细见<a href="https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">下图</a>，图是以示例1为例的。 <a href="https://i.loli.net/2019/09/11/U2uTlmXCpS4oB5M.png"><img src="https://i.loli.net/2019/09/11/U2uTlmXCpS4oB5M.png" alt=""></a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//递归+剪枝</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;sol;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> beg, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = beg; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            sol.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(target - nums[i] &gt; <span class="number">0</span>)&#123;<span class="comment">//继续向下搜索</span></span><br><span class="line">                <span class="built_in">dfs</span>(nums, i, target - nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target - nums[i] == <span class="number">0</span>)&#123;<span class="comment">//将符合题意的解放到res中</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(sol);</span><br><span class="line">            &#125;</span><br><span class="line">            sol.<span class="built_in">pop_back</span>();<span class="comment">//回溯的时候记得弹出最后一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(target - nums[i] &lt; <span class="number">0</span>)&#123;<span class="comment">//剪枝，如果当前的sol中所有元素之和大于target,则直接return</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><a href="https://i.loli.net/2019/09/11/ozlH1JCfxpEYIOd.png"><img src="https://i.loli.net/2019/09/11/ozlH1JCfxpEYIOd.png" alt=""></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>回溯</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>4. 寻找两个有序数组的中位数 - 力扣（LeetCode）</title>
    <url>/2019/08/30/4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-%E5%8A%9B%E6%89%A3%EF%BC%88leetcode%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line">则中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>自己能够想到的是将两个有序数组进行归并排序，然后根据奇偶取中位数。但这样做的时间复杂度为o(m+n)，是不符合题意。 最后参考官方题解，写出了时间复杂度为o(log(m+n))的程序。 首先回顾中位数定义是对于n个数据，求取中位数首先将其排序，若n为奇数，则中位数为第(n+1)/2个数；若n为偶数，则中位数是第n/2个数和第n/2 + 1个数之和的平均数。 现在我们换种思路，已知两个有序数组和nums1（元素个数为n）和nums2(元素个数为m)。对于nums1，将其从位置i处划分成两部分，我们有n+1种划分方式。i的取值为[0, n]。当i=0，左边有0个元素，右边有n个元素；当i=n，左边有n个元素，右边有0个元素；当i介于0到n之间，左边有i个元素，右边有n-i个元素。划分的左边区域的最大值记为lmax1，划分的右边区域的最小值记为rmin1。lmax1 = nums1[i - 1]，rmin1 = nums1[i]。 同理对于nums2数组，我们在位置j处划分。有lmax2 = nums2[j - 1]，rmin2 = nums2[j]。 现在若我们能保证i + j = (n + m + 1) / 2且lmax1 &lt;= rmin2，lmax2 &lt;= rmin1，则nums1与nums2的左边区域和nums1与nums2的右边区域元素个数相等，且左边 &lt;= 右边。 这种情况下，很容易找到中位数，当n+m为偶数时，中位数为max(lmax1, lmax2)与min(rmin1,rmin2)的平均数；当n+m为奇数，中位数为max(lmax1, lmax2)。 位置i的调整采用二分的方式，当lmax1 &gt; rmin2时，说明nums1左边元素偏大，需将i减小，此时j增大（j = (n + m + 1) / 2 - i）,当lmax2 &gt; rmin1时，说明num2左边元素偏大，需将j减小，此时i增大。</p>
<h2 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m &gt; n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findMedianSortedArrays</span>(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> low = <span class="number">0</span>, high = m;</span><br><span class="line">            <span class="type">int</span> lmax1, lmax2, rmin1, rmin2, i, j;</span><br><span class="line">            <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">                i = (low + high) / <span class="number">2</span>;</span><br><span class="line">                j = (m + n + <span class="number">1</span>) / <span class="number">2</span> - i;</span><br><span class="line">                lmax1 = i == <span class="number">0</span>?INT_MIN:nums1[i - <span class="number">1</span>];</span><br><span class="line">                rmin1 = i == m?INT_MAX:nums1[i];</span><br><span class="line">                lmax2 = j == <span class="number">0</span>?INT_MIN:nums2[j - <span class="number">1</span>];</span><br><span class="line">                rmin2 = j == n?INT_MAX:nums2[j];</span><br><span class="line">                <span class="keyword">if</span>(lmax1 &gt; rmin2)&#123;</span><br><span class="line">                    high = i - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(lmax2 &gt; rmin1)&#123;</span><br><span class="line">                    low = i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>((m + n) % <span class="number">2</span> == <span class="number">0</span>)&#123;<span class="comment">//偶数</span></span><br><span class="line">                        <span class="built_in">return</span> (<span class="built_in">max</span>(lmax1, lmax2) + <span class="built_in">min</span>(rmin1, rmin2)) / <span class="number">2.0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;<span class="comment">//奇数</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">max</span>(lmax1, lmax2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><a href="https://i.loli.net/2019/08/30/ZnSI7WKOrLufMYs.png"><img src="https://i.loli.net/2019/08/30/ZnSI7WKOrLufMYs.png" alt=""></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>40. 组合总和 II - 力扣（LeetCode）</title>
    <url>/2019/09/13/40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-ii-%E5%8A%9B%E6%89%A3%EF%BC%88leetcode%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。  示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] 示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [   [1,2,2],   [5] ]</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>此题与“组合之和”一题有两个不同：一是该题数组中的数字可能会重复；二是每个数字在每个组合中只能使用一次。 数字重复带来的一个问题是组合可能会重复，所以需要做去重处理。 同“组合之和”一题一样，这里使用的也是递归+剪枝，这里首先对数据进行排序，方便剪枝和去重。 每个数字只能使用一次，可以修改递归的起点，之前是i，这里可以修改为i + 1。 其它细节具体见代码。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;sol;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> beg, <span class="type">int</span> target)</span></span>&#123;<span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = beg; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target - nums[i] &lt; <span class="number">0</span>)&#123;<span class="comment">//之和大于则直接return</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; beg &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;<span class="comment">//去重</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sol.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(target == nums[i])&#123;<span class="comment">//满足条件 放到题解中</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(sol);</span><br><span class="line">                sol.<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>, target - nums[i]);<span class="comment">//之和小于target，则继续向下递归，注意此时beg是从i+1开始的</span></span><br><span class="line">                sol.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><a href="https://i.loli.net/2019/09/13/Uu6FY3HoNKxnqgd.png"><img src="https://i.loli.net/2019/09/13/Uu6FY3HoNKxnqgd.png" alt=""></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>递归</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>41. 缺失的第一个正数 - 力扣（LeetCode）</title>
    <url>/2019/09/14/41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0-%E5%8A%9B%E6%89%A3%EF%BC%88leetcode%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 示例 1: 输入: [1,2,0] 输出: 3 示例 2: 输入: [3,4,-1,1] 输出: 2 示例 3: 输入: [7,8,9,11,12] 输出: 1 说明: <strong>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。</strong></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>看到时间复杂度为[latex]o(n)[/latex]，空间复杂度为[latex]o(1)[/latex]。之前抱有哈希表的想法顿时烟消云散。 然后查看第一个提示，假如在非常量的情况下，你会怎么做？能否将这种思路应用在常量空间中。 恕我愚钝，写完非常量下的做法后，还是没有任何思路，只能查看官方<a href="https://leetcode-cn.com/problems/first-missing-positive/solution/que-shi-de-di-yi-ge-zheng-shu-by-leetcode/">题解</a>。 大体思路如下： 对于nums数组，其缺失的第一个正数只可能出现在1-nums.size()+1中。而对于负数和0并不影响结果。 1. 首先判断当前数组中是否存在1，若没有1，则缺失的第一个正数就是1；如果存在，则进行第二步。 2. 将负数，0和大于nums.size()变成1。 3. 借助哈希标记的思路，这里采用拿自己当bitmap的绝妙思路，如果i出现，则改变nums[i]的符号，如果nums.size()出现则改变nums[0]的符号，重复元素只改变一次符号。 4. 首个出现的正元素其下标为本题解，均为负，则解为nums.size() + 1。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt;my_set;</span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;<span class="comment">//哈希表标记</span></span><br><span class="line">            my_set.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums.<span class="built_in">size</span>() + <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(my_set.<span class="built_in">find</span>(i) == my_set.<span class="built_in">end</span>())&#123;</span><br><span class="line">                res = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><a href="https://i.loli.net/2019/09/14/lT2VzAwmMvdtCfx.png"><img src="https://i.loli.net/2019/09/14/lT2VzAwmMvdtCfx.png" alt=""></a></p>
<h2 id="官方题解代码"><a href="#官方题解代码" class="headerlink" title="官方题解代码"></a>官方题解代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;<span class="comment">//判断是否存在1</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;<span class="comment">//将非正数和大于nums.size()的数替换为1</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt;= <span class="number">0</span>  nums[i] &gt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">                    nums[i] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;nums.<span class="built_in">size</span>(); ++i)&#123;<span class="comment">//符号标记</span></span><br><span class="line">                idx = <span class="built_in">abs</span>(nums[i]);</span><br><span class="line">                <span class="keyword">if</span>(idx == nums.<span class="built_in">size</span>() &amp;&amp; nums[<span class="number">0</span>] &gt; <span class="number">0</span>)&#123;<span class="comment">//仅为正的时候才改变符号是为了保证修改一次。</span></span><br><span class="line">                    nums[<span class="number">0</span>] = -nums[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(idx != nums.<span class="built_in">size</span>() &amp;&amp; nums[idx] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    nums[idx] = -nums[idx];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>] &gt; <span class="number">0</span>)&#123;<span class="comment">//如果后面全为负，nums[0]为正,则返回nums.size()</span></span><br><span class="line">                <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//如果都为负，则返回nums.size() + 1</span></span><br><span class="line">                <span class="keyword">return</span> nums.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h2><p><a href="https://i.loli.net/2019/09/14/MATkrdKaUHNEsFm.png"><img src="https://i.loli.net/2019/09/14/MATkrdKaUHNEsFm.png" alt=""></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>42. 接雨水 - 力扣（LeetCode）</title>
    <url>/2019/09/15/42-%E6%8E%A5%E9%9B%A8%E6%B0%B4-%E5%8A%9B%E6%89%A3%EF%BC%88leetcode%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 <a href="https://i.loli.net/2019/09/15/9BTUe5k7boLmIht.png"><img src="https://i.loli.net/2019/09/15/9BTUe5k7boLmIht.png" alt=""></a> 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。 示例: 输入: [0,1,0,2,1,0,1,3,2,1,2,1] 输出: 6</p>
<h2 id="题解（暴力法）"><a href="#题解（暴力法）" class="headerlink" title="题解（暴力法）"></a>题解（暴力法）</h2><p>这里的题解参考的是官方<a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode/">题解</a>，自己太菜了! 首先使用的是暴力求解法，每个柱子能接的雨水量取决于它前面柱子最高的与后面柱子最高的，两者的较小值。这个想想应该就能明白。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">时间复杂度为：o(n^2)</span><br><span class="line">空间复杂度为：o(1)</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trap(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int len = height.size();</span><br><span class="line">        int l_max, r_max, ans = 0;</span><br><span class="line">        for(int i = 1; i &lt; len - 1; ++i)&#123;</span><br><span class="line">            l_max = 0, r_max = 0;</span><br><span class="line">            for(int j = i; j &gt;= 0; --j)&#123;//寻找左边柱子的最高值</span><br><span class="line">                if(height[j] &gt; l_max)&#123;</span><br><span class="line">                    l_max = height[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = i; j &lt; len; ++j)&#123;//寻找右边柱子的最高值</span><br><span class="line">                if(height[j] &gt; r_max)&#123;</span><br><span class="line">                    r_max = height[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += min(l_max, r_max) - height[i];//接到的雨水量 = 能达到的高度 - height[i]。</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><a href="https://i.loli.net/2019/09/15/I4CNAprHB9aL1oF.png"><img src="https://i.loli.net/2019/09/15/I4CNAprHB9aL1oF.png" alt=""></a></p>
<h2 id="题解（动态规划）"><a href="#题解（动态规划）" class="headerlink" title="题解（动态规划）"></a>题解（动态规划）</h2><p>暴力法中第二重循环是用来寻找当前柱子左边的最高柱子和右边的最高柱子，我们是否可以维护一个数组来存储其左边最高柱子，另外一个数组存储其右边最高柱子?答案显然可以，只需从左向右扫描一次，从右向左扫描一次即可。相比暴力解法，多了两个数组来存储一些信息，但时间复杂度却从o(n^2)降为o(n)。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">时间复杂度为：o(n)</span></span><br><span class="line"><span class="comment">空间复杂度为：o(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = height.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">l_max_arr</span>(len, <span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">r_max_arr</span>(len, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                l_max_arr[i] = <span class="built_in">max</span>(l_max_arr[<span class="number">0</span>], height[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                l_max_arr[i] = <span class="built_in">max</span>(l_max_arr[i - <span class="number">1</span>], height[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == len - <span class="number">1</span>)&#123;</span><br><span class="line">                r_max_arr[i] = <span class="built_in">max</span>(r_max_arr[len - <span class="number">1</span>],  height[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                r_max_arr[i] = <span class="built_in">max</span>(r_max_arr[i + <span class="number">1</span>], height[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            res += (<span class="built_in">min</span>(l_max_arr[i], r_max_arr[i]) - height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h2><p><a href="https://i.loli.net/2019/09/15/isHaKf1ed2mTySo.png"><img src="https://i.loli.net/2019/09/15/isHaKf1ed2mTySo.png" alt=""></a></p>
<h2 id="题解（栈的应用）"><a href="#题解（栈的应用）" class="headerlink" title="题解（栈的应用）"></a>题解（栈的应用）</h2><p>有点巧妙，只是列出来，打死也想不出来。 我们在遍历数组时维护一个栈。如果当前的条形块小于或等于栈顶的条形块，我们将条形块的索引入栈，意思是当前的条形块被栈中的前一个条形块界定。如果我们发现一个条形块长于栈顶，我们可以确定栈顶的条形块被当前条形块和栈的前一个条形块界定，因此我们可以弹出栈顶元素并且累加答案到ans 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">时间复杂度为o(n)</span></span><br><span class="line"><span class="comment">空间复杂度为o(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, current = <span class="number">0</span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">while</span> (current &lt; height.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; height[current] &gt; height[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">            <span class="type">int</span> top = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">empty</span>())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> distance = current - st.<span class="built_in">top</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> bounded_height = <span class="built_in">min</span>(height[current], height[st.<span class="built_in">top</span>()]) - height[top];</span><br><span class="line">            ans += distance * bounded_height;</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">push</span>(current++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题解（双指针）"><a href="#题解（双指针）" class="headerlink" title="题解（双指针）"></a>题解（双指针）</h2><p>分左右两边计算，一次完成遍历。当height[left] &lt; height[right]，两边最大中较小的只可能出现在左边，不可能在右边。两指针移动时，需不断更新l_max与r_max。</p>
<h1 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">时间复杂度为：o(n)</span></span><br><span class="line"><span class="comment">空间复杂度为：o(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l_max = <span class="number">0</span>, r_max = <span class="number">0</span>;<span class="comment">//记录左右两边最大的</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])&#123;</span><br><span class="line">                l_max &lt;= height[left]?l_max = height[left]:res += l_max - height[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                r_max &lt;= height[right]?r_max = height[right]:res += r_max - height[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="执行结果-2"><a href="#执行结果-2" class="headerlink" title="执行结果"></a>执行结果</h2><p><a href="https://i.loli.net/2019/09/15/QisbyFAGXMHS7cd.png"><img src="https://i.loli.net/2019/09/15/QisbyFAGXMHS7cd.png" alt=""></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>数组</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>45. 跳跃游戏 II  - 力扣（LeetCode）</title>
    <url>/2019/09/16/45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-ii-%E5%8A%9B%E6%89%A3%EF%BC%88leetcode%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 示例: 输入: [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。   从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 说明: 假设你总是可以到达数组的最后一个位置。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最初的想法是用动态规划，steps数组用来存储从0跳到i处所需的最少步数。然后steps[len - 1]就是我们想要的答案。 当求steps[i]时，我们需要考虑从0-i-1哪个地方跳所需的步数最少，这里如果从某处k一次不能跳到i，则此处一定不用考虑，因为它一次最远跳到的位置是i前的某个位置j，我们完全可以从j开始跳，用的步数肯定不大于从k处跳所需的最小步数。 这里的时间复杂度为$latex o(n^2)$，空间复杂度为o(n)。具体见代码。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">动态规划：</span></span><br><span class="line"><span class="comment">时间复杂度：o(n^2)</span></span><br><span class="line"><span class="comment">空间复杂度：o(n)</span></span><br><span class="line"><span class="comment">未AC，执行超时！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">steps</span>(len, INT_MAX);</span><br><span class="line">        <span class="comment">// steps数组表存储从起点跳到i处所需要的最小步数</span></span><br><span class="line">        steps[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]==<span class="number">25000</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()) - nums.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i)&#123;</span><br><span class="line">            <span class="type">int</span> beg = i - nums[idx] &lt; <span class="number">0</span>?<span class="number">0</span>:i - nums[idx];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = beg; j &lt; i; ++j)&#123;<span class="comment">//求steps[i]</span></span><br><span class="line">                <span class="keyword">if</span>(nums[j] + j &gt;= i)&#123;</span><br><span class="line">                    steps[i] = <span class="built_in">min</span>(steps[i], steps[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps[len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//有趣的是，评论区中有大神面向测试用例编程，加了一名 `if(nums[0]==25000)return 2;`就过了，执行用时还比较短</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p>加上 if(nums[0]==25000)return 2; 后的执行结果 <a href="https://i.loli.net/2019/09/16/kL6IgyTEo27DMYS.png"><img src="https://i.loli.net/2019/09/16/kL6IgyTEo27DMYS.png" alt=""></a></p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>求每一跳能跳到的最远位置，当第res跳的最远位置到达或超过终点，则认为从起点到终点，只需要res跳。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">求每一跳所能达到的最远位置</span></span><br><span class="line"><span class="comment">时间复杂度：o(n)</span></span><br><span class="line"><span class="comment">空间复杂度：o(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> beg = <span class="number">0</span>, end = <span class="number">0</span>, max_pos = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> step = <span class="number">0</span>, len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(end &lt; len - <span class="number">1</span>)&#123;</span><br><span class="line">            max_pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = beg; i &lt;= end; ++i)&#123;<span class="comment">//求取该跳能达到的最远位置</span></span><br><span class="line">                max_pos = <span class="built_in">max</span>(max_pos, i + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新下一跳的起始位置的范围</span></span><br><span class="line">            beg = end + <span class="number">1</span>;</span><br><span class="line">            end = max_pos;</span><br><span class="line">            ++step;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h2><p><a href="https://i.loli.net/2019/09/16/iS1Xo7KF8tEUPfk.png"><img src="https://i.loli.net/2019/09/16/iS1Xo7KF8tEUPfk.png" alt=""></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>动态规划</tag>
        <tag>贪婪</tag>
      </tags>
  </entry>
  <entry>
    <title>Macos 10.15.7系统下，Tuxera无法挂载NTFS移动盘解决方案</title>
    <url>/2022/05/30/Macos-10-15-7%E7%B3%BB%E7%BB%9F%E4%B8%8B%EF%BC%8CTuxera%E6%97%A0%E6%B3%95%E6%8C%82%E8%BD%BDNTFS%E7%A7%BB%E5%8A%A8%E7%9B%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/346106923">知乎-Mac的移动硬盘不能装载该如何解决?</a></li>
<li><a href="https://macsupport.tuxera.com/hc/en-gb/articles/360021236379">命令行卸载Tuxera</a>与<a href="https://macsupport.tuxera.com/hc/en-gb/articles/360020954620-How-to-uninstall-NTFS-for-Mac-using-System-Preferences">使用系统偏好卸载Tuxera</a></li>
<li><a href="https://www.ntfsformac.cn/changjianwenti/paragon-qoiw.html#:~:text=Mac%20os%2010.15.7%E7%B3%BB%E7%BB%9F%E6%97%A0%E6%B3%95%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%9B%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%201%E3%80%81%E6%89%93%E5%BC%80%E5%90%AF%E5%8A%A8%E5%8F%B0%EF%BC%8C%E4%B8%8A%E6%96%B9%E8%BE%93%E5%85%A5%EF%BC%9A%E7%BB%88%E7%AB%AF%EF%BC%88%E6%88%96%E8%80%85%E6%A1%8C%E9%9D%A2%E7%82%B9%E5%87%BB%E5%89%8D%E5%BE%80-%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F-%E7%BB%88%E7%AB%AF%EF%BC%89%20%E5%9B%BE2%EF%BC%9A%E7%BB%88%E7%AB%AF,2%E3%80%81%E8%BE%93%E5%85%A5%EF%BC%9A%20sudo%20mkdir%20%2FVolumes%2Fntfs-disk%20%E5%9B%9E%E8%BD%A6%E5%90%8E%E4%BC%9A%E5%87%BA%E7%8E%B0Password%EF%BC%8C%E7%9B%B4%E6%8E%A5%E8%BE%93%E5%85%A5%E7%94%B5%E8%84%91%E5%BC%80%E6%9C%BA%E5%AF%86%E7%A0%81%EF%BC%88%E6%B2%A1%E6%9C%89%E5%A1%AB%E5%86%99%E6%A1%86%EF%BC%8C%E8%BE%93%E5%85%A5%E5%AE%8C%E6%88%90%E5%90%8E%EF%BC%8C%E5%9B%9E%E8%BD%A6%E5%8D%B3%E5%8F%AF%EF%BC%89%20%E5%9B%BE3%EF%BC%9A%E8%BE%93%E5%85%A5%E5%BC%80%E6%9C%BA%E5%AF%86%E7%A0%81">Macos 10.15.7系统无法挂载移动盘解决方案</a></li>
<li><a href="https://i.mairuan.com/support/faq/id/648">Tuxera NTFS在Mac os 10.15.7系统用命令挂载盘</a></li>
</ol>
<h2 id="解决轨迹"><a href="#解决轨迹" class="headerlink" title="解决轨迹"></a>解决轨迹</h2><p>最开始以为是错误插拔导致硬盘无法挂载。参考资料<a href="https://zhuanlan.zhihu.com/p/346106923">1</a>，执行相关命令，但发现仍然无法挂载硬盘。然后去苹果社区查相关信息，有人提是因为Tuxera不是最新版本，就按照资料2卸载旧版本，重启电脑。这时发现可以挂载硬盘，但只能读不能写，此时，内心窃喜。安装最新版本Tuxera，重启电脑，发现又无法挂载硬盘，回到了最初的起点。我有点怀疑是因为软件与系统不兼容导致的，因为我在卸载掉软件后，是可以正常挂载。所以，我使用“Macos10.15.7无法挂载移动盘”去google找到材料<a href="https://www.ntfsformac.cn/changjianwenti/paragon-qoiw.html#:~:text=Mac%20os%2010.15.7%E7%B3%BB%E7%BB%9F%E6%97%A0%E6%B3%95%E6%8C%82%E8%BD%BD%E7%A7%BB%E5%8A%A8%E7%9B%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%201%E3%80%81%E6%89%93%E5%BC%80%E5%90%AF%E5%8A%A8%E5%8F%B0%EF%BC%8C%E4%B8%8A%E6%96%B9%E8%BE%93%E5%85%A5%EF%BC%9A%E7%BB%88%E7%AB%AF%EF%BC%88%E6%88%96%E8%80%85%E6%A1%8C%E9%9D%A2%E7%82%B9%E5%87%BB%E5%89%8D%E5%BE%80-%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F-%E7%BB%88%E7%AB%AF%EF%BC%89%20%E5%9B%BE2%EF%BC%9A%E7%BB%88%E7%AB%AF,2%E3%80%81%E8%BE%93%E5%85%A5%EF%BC%9A%20sudo%20mkdir%20%2FVolumes%2Fntfs-disk%20%E5%9B%9E%E8%BD%A6%E5%90%8E%E4%BC%9A%E5%87%BA%E7%8E%B0Password%EF%BC%8C%E7%9B%B4%E6%8E%A5%E8%BE%93%E5%85%A5%E7%94%B5%E8%84%91%E5%BC%80%E6%9C%BA%E5%AF%86%E7%A0%81%EF%BC%88%E6%B2%A1%E6%9C%89%E5%A1%AB%E5%86%99%E6%A1%86%EF%BC%8C%E8%BE%93%E5%85%A5%E5%AE%8C%E6%88%90%E5%90%8E%EF%BC%8C%E5%9B%9E%E8%BD%A6%E5%8D%B3%E5%8F%AF%EF%BC%89%20%E5%9B%BE3%EF%BC%9A%E8%BE%93%E5%85%A5%E5%BC%80%E6%9C%BA%E5%AF%86%E7%A0%81">3</a>，发现Paragon软件可以通过命令来手动挂载以解决不兼容的问题。那Tuxera是否也可以手动挂载那？加上Tuxera关键词，找到材料<a href="https://i.mairuan.com/support/faq/id/648">4</a>，问题终于得到解决了。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="3条命令"><a href="#3条命令" class="headerlink" title="3条命令"></a>3条命令</h3><ol>
<li>终端输入<code>sudo mkdir /Volumes/ntfs-disk</code>，需输入开机密码。</li>
<li><code>diskutil list</code>查看硬盘信息，找到对应条目。我这里对应的是 <em>/dev/disk2s1</em>。</li>
</ol>
<p>​        <img src="https://raw.githubusercontent.com/onwaiers/Picture/master/img/image-20220530151450204.png" alt="image-20220530151450204"></p>
<ol>
<li><code>sudo /Library/Filesystems/tuxera_ntfs.fs/Contents/Resources/mount_tuxera_ntfs -o nodev -o noowners -o nosuid /dev/diskXsY /Volumes/ntfs-disk</code>，需将这里diskXsY替换掉，对应上图，这里就替换成 <em>disk2s1</em>。等待片刻，即可成功挂载，此时可正常读写。</li>
</ol>
<p>​        注意：<strong>退出硬盘需重新挂载，为了方便下面提供了脚本方便执行</strong></p>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tuxera 挂载ntfs硬盘（适用于zsh，bash不知是否可以）</span></span><br><span class="line"><span class="function"><span class="title">tuxera_mount</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    sudo <span class="built_in">mkdir</span> /Volumes/ntfs-disk</span><br><span class="line">    <span class="keyword">if</span> [ ! <span class="variable">$#</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">        sudo /Library/Filesystems/tuxera_ntfs.fs/Contents/Resources/mount_tuxera_ntfs -o nodev -o noowners -o nosuid /dev/<span class="variable">$1</span> /Volumes/ntfs-disk</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;先用diskutil list，查看需要挂载盘的信息&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>tuxera_mount</code>需要接收一个参数。比如对应上图，此参数应为 <em>disk2s1</em>。挂载时，执行命令<code>tuxera_mount disk2s1</code>即可。</p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>AttributeError: &#39;NoneType&#39; object has no attribute &#39;data&#39;</title>
    <url>/2020/02/07/attributeerror-nonetype-object-has-no-attribute-data/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://github.com/WuJie1010/Facial-Expression-Recognition.Pytorch/issues/24">issue</a></li>
<li><a href="https://blog.csdn.net/leogo17/article/details/79970938">pytorch: grad is None while training</a></li>
<li><a href="https://blog.csdn.net/qq_21997625/article/details/90369838">pytorch冻结部分参数训练另一部分</a></li>
</ol>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>将别人模型替换成自己的模型，训练过程中出现错误<code>param.grad.data.clamp_(-grad_clip, grad_clip) AttributeError: &#39;NoneType&#39; object has no attribute &#39;data&#39;</code></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>上网查询这个问题，大部分回答都是模型中定义的某个层没有参与到前向传播，所以反向传播，计算loss时，<code>grad is None</code>。主要是要找到未参与计算的层，并注释掉。 这个问题困扰我很久，因为始终觉得没有多余的层。 下面的代码定义一个AttentionResNet模型。后来才发现罪魁祸首是<code>self.encoder</code>，这所以前面一直没有注意到它，是因为后面的层的定义用到<code>self.encoder</code>中的某个层或某几个层组合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AttentionResNet</span>(nn.Module):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_channels=<span class="number">3</span>, out_channels=<span class="number">1</span>, num_filters=<span class="number">32</span>, encoder_depth=<span class="number">34</span>, pretrained=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(AttentionResNet, self).__init__()</span><br><span class="line">        self.in_channels  = in_channels</span><br><span class="line">        self.out_channels = out_channels </span><br><span class="line">        self.num_filters = num_filters</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> encoder_depth == <span class="number">34</span>:</span><br><span class="line">            self.encoder = torchvision.models.resnet34(pretrained=pretrained)</span><br><span class="line">            bottom_channel_nr = <span class="number">512</span></span><br><span class="line">        <span class="keyword">elif</span> encoder_depth == <span class="number">101</span>:</span><br><span class="line">            self.encoder = torchvision.models.resnet101(pretrained=pretrained)</span><br><span class="line">            bottom_channel_nr = <span class="number">2048</span></span><br><span class="line">        <span class="keyword">elif</span> encoder_depth == <span class="number">152</span>:</span><br><span class="line">            self.encoder = torchvision.models.resnet152(pretrained=pretrained)</span><br><span class="line">            bottom_channel_nr = <span class="number">2048</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> NotImplementedError(<span class="string">&#x27;only 34, 101, 152 version of Resnet are implemented&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#attention module</span></span><br><span class="line">        self.pool  = nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        self.relu  = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">        self.conv1 = nn.Sequential(self.encoder.conv1, self.encoder.bn1, self.encoder.relu, self.pool)</span><br><span class="line">        self.conv2 = self.encoder.layer1</span><br><span class="line">        self.conv3 = self.encoder.layer2</span><br><span class="line">        self.conv4 = self.encoder.layer3</span><br><span class="line">        self.conv5 = self.encoder.layer4  </span><br><span class="line"></span><br><span class="line">        self.center = DecoderBlockV2(bottom_channel_nr,                        num_filters * <span class="number">8</span> * <span class="number">2</span>, num_filters * <span class="number">8</span>)</span><br><span class="line">        self.dec5   = DecoderBlockV2(bottom_channel_nr + num_filters * <span class="number">8</span>,      num_filters * <span class="number">8</span> * <span class="number">2</span>, num_filters * <span class="number">8</span>)</span><br><span class="line">        self.dec4   = DecoderBlockV2(bottom_channel_nr // <span class="number">2</span> + num_filters * <span class="number">8</span>, num_filters * <span class="number">8</span> * <span class="number">2</span>, num_filters * <span class="number">8</span>)</span><br><span class="line">        self.dec3   = DecoderBlockV2(bottom_channel_nr // <span class="number">4</span> + num_filters * <span class="number">8</span>, num_filters * <span class="number">4</span> * <span class="number">2</span>, num_filters * <span class="number">2</span>)</span><br><span class="line">        self.dec2   = DecoderBlockV2(bottom_channel_nr // <span class="number">8</span> + num_filters * <span class="number">2</span>, num_filters * <span class="number">2</span> * <span class="number">2</span>, num_filters * <span class="number">2</span> * <span class="number">2</span>)</span><br><span class="line">        self.dec1   = DecoderBlockV2(num_filters * <span class="number">2</span> * <span class="number">2</span>,                      num_filters * <span class="number">2</span> * <span class="number">2</span>, num_filters)</span><br><span class="line"></span><br><span class="line">        self.attention_map = nn.Sequential(</span><br><span class="line">            ConvRelu(num_filters, num_filters),</span><br><span class="line">            nn.Conv2d(num_filters, <span class="number">1</span>, kernel_size=<span class="number">1</span>)  </span><br><span class="line">        )  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):        </span><br><span class="line"></span><br><span class="line">        <span class="comment">#attention module</span></span><br><span class="line">        conv1 = self.conv1(x)</span><br><span class="line">        conv2 = self.conv2(conv1)</span><br><span class="line">        conv3 = self.conv3(conv2)</span><br><span class="line">        conv4 = self.conv4(conv3)</span><br><span class="line">        conv5 = self.conv5(conv4)</span><br><span class="line"></span><br><span class="line">        pool = self.pool(conv5)</span><br><span class="line">        center = self.center( pool )  </span><br><span class="line">        dec5 = self.dec5(torch.cat([center, conv5], <span class="number">1</span>))        </span><br><span class="line">        dec4 = self.dec4(torch.cat([dec5, conv4], <span class="number">1</span>))</span><br><span class="line">        dec3 = self.dec3(torch.cat([dec4, conv3], <span class="number">1</span>))</span><br><span class="line">        dec2 = self.dec2(torch.cat([dec3, conv2], <span class="number">1</span>))</span><br><span class="line">        dec1 = self.dec1(dec2)           </span><br><span class="line"></span><br><span class="line">        <span class="comment">#attention map</span></span><br><span class="line">        x = self.attention_map( dec1 ) </span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>找到了出错的位置，如何修改呢？参照资料3，首先将self.encoder中的参数的<code>requires_grad</code>都置为False，然后在优化器中加入过滤器，只更新<code>requires_grad = True</code>的参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> net.encoder.parameters():</span><br><span class="line">    param.requires_grad = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">optimizer = optim.SGD(<span class="built_in">filter</span>(<span class="keyword">lambda</span> p: p.requires_grad, net.parameters()), lr=opt.lr, momentum=<span class="number">0.9</span>, weight_decay=<span class="number">5e-4</span>)</span><br></pre></td></tr></table></figure>
<p>找了2天，终于找到错误的位置，太难了。</p>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Conda使用</title>
    <url>/2019/09/02/condaw%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>conda是一款可以运行在windows，macOS和Liunx多系统的开源包管理系统和环境管理系统。Conda能快速安装、运行和更新包及其依赖。Conda能容易在你的电脑上创建、保存、加载和切换运行环境。如果你需要一个满足另一不同版本的Python。你不需要切换到一个不同的环境，因为conda也是一个环境管理器，使用一小段命令，你就可以设置一个完全独立的环境来运行不同版本的Python，然后在一般环境中运行你常用的Python版本。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="创建conda环境"><a href="#创建conda环境" class="headerlink" title="创建conda环境"></a>创建conda环境</h3><p><code>conda env list</code>或者<code>conda info --envs</code>可以查看当前已经存在的环境列表。 默认情况下只有一个base。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda create -n 环境名 python=python版本号 包名=包版本号</span><br><span class="line"># -n用来设置环境名</span><br></pre></td></tr></table></figure>
<p>如<code>conda create -n py36 python3.6</code>创建一个名为py36的新环境。</p>
<h3 id="激活（启动）环境"><a href="#激活（启动）环境" class="headerlink" title="激活（启动）环境"></a>激活（启动）环境</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda activate 环境名</span><br><span class="line"># 如conda activate py36</span><br></pre></td></tr></table></figure>
<h3 id="退出环境"><a href="#退出环境" class="headerlink" title="退出环境"></a>退出环境</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure>
<h3 id="删除环境"><a href="#删除环境" class="headerlink" title="删除环境"></a>删除环境</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda remove -n 环境名 --all</span><br><span class="line"># 如conda remove -n py36 --all</span><br></pre></td></tr></table></figure>
<h3 id="重名命环境"><a href="#重名命环境" class="headerlink" title="重名命环境"></a>重名命环境</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 分2步：先复制环境，再删除</span><br><span class="line"># 这里把刚才创建的pyt36重命名为python36</span><br><span class="line">conda create -n python36 --clone py36</span><br><span class="line">conda remove -n py36 --all</span><br></pre></td></tr></table></figure>
<h3 id="更新环境"><a href="#更新环境" class="headerlink" title="更新环境"></a>更新环境</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 更新所有包</span><br><span class="line">conda update</span><br><span class="line"># 更新指定包</span><br><span class="line">conda update package_name</span><br></pre></td></tr></table></figure>
<h3 id="共享环境"><a href="#共享环境" class="headerlink" title="共享环境"></a>共享环境</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将你的环境导出给别人使用</span></span><br><span class="line"><span class="comment"># 1. 进行激活环境</span></span><br><span class="line">conda activate 环境名</span><br><span class="line"><span class="comment"># 2. 导出环境</span></span><br><span class="line">conda env export  &gt; environment.yml</span><br><span class="line"><span class="comment"># 将上面文件copy给别人（默认在安装 anaconda的文件夹中）</span></span><br><span class="line"><span class="comment"># 上面命令会安装在conda默认的环境路径</span></span><br><span class="line"><span class="comment"># 如果要指定其它安装路径，使用-p选项</span></span><br><span class="line"><span class="comment"># conda env create -f environment.yml -p /home/user/anaconda3/envs/env_name</span></span><br><span class="line"><span class="comment"># 3. 创建环境</span></span><br><span class="line">conda env create -f environment.yml</span><br><span class="line">```python</span><br><span class="line">```python</span><br><span class="line"><span class="comment"># 也可以导出到txt文件中</span></span><br><span class="line"><span class="comment"># 用pip的方法如下：</span></span><br><span class="line">pip freeze  &gt; requirements.txt</span><br><span class="line">pip install -r requirements.txt</span><br><span class="line"><span class="comment"># 用conda的方法</span></span><br><span class="line">conda <span class="built_in">list</span> -e  &gt; requirements.txt</span><br><span class="line">conda install --yes --file requirements.txt</span><br></pre></td></tr></table></figure>
<h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 未指定环境安装在当前激活的环境下</span><br><span class="line">conda install -n 环境名 package_name</span><br><span class="line"># 如conda install -n py36 keras</span><br><span class="line">conda install package_name</span><br><span class="line"># 使用某pip进行安装包</span><br><span class="line">python.exe -m pip install package_name</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="删除包"><a href="#删除包" class="headerlink" title="删除包"></a>删除包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除指定环境中package</span><br><span class="line">conda remove -n 环境名 package_name</span><br></pre></td></tr></table></figure>
<h3 id="显示包列表"><a href="#显示包列表" class="headerlink" title="显示包列表"></a>显示包列表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure>
<h3 id="搜索包"><a href="#搜索包" class="headerlink" title="搜索包"></a>搜索包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda search package_name</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>conda使用</tag>
      </tags>
  </entry>
  <entry>
    <title>dlib实现脸部分割与人脸对齐</title>
    <url>/2020/01/29/dlib%E5%AE%9E%E7%8E%B0%E8%84%B8%E9%83%A8%E5%88%86%E5%89%B2%E4%B8%8E%E4%BA%BA%E8%84%B8%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://blog.csdn.net/liuxiao214/article/details/83411820">【Dlib】人脸检测、特征点检测、人脸对齐、人脸识别</a></li>
<li><a href="https://blog.csdn.net/wujuxkkoolerter/article/details/86152586">深度学习与人脸识别之-脸部分割与校正</a></li>
<li><a href="https://github.com/AIfaceLab/FaceSegmentation">github项目FaceSegmentation</a></li>
<li><a href="http://dlib.net/face_alignment.py.html">http://dlib.net/face_alignment.py.html</a></li>
<li><a href="https://www.zhihu.com/question/268307551">知乎问答</a></li>
</ol>
<h2 id="关键点检测"><a href="#关键点检测" class="headerlink" title="关键点检测"></a>关键点检测</h2><p>首先获取模型，下载地址在<a href="http://dlib.net/files/">这</a>，我使用的是获取脸部68个关键点的<a href="http://onwaier.com:7777/share/e9FOpQTO">模型<code>shape_predictor_68_face_landmarks.dat</code></a> 68关键点位置示意图如下： <img src="/images/2020/01/bc388216b03bc751c8a6505207243e59.png" alt=""> 首先贴出python代码 ` ```python<br>“””<br>代码功能：</p>
<ol>
<li>用dlib人脸检测器检测出人脸，返回的人脸矩形框</li>
<li>对检测出的人脸进行关键点检测并用圈进行标记</li>
<li>将检测出的人脸关键点信息写到txt文本中<br>“””<br>import cv2<br>import dlib<br>import numpy as np</li>
</ol>
<p>predictor_model = ‘shape_predictor_68_face_landmarks.dat’<br>detector = dlib.get_frontal_face_detector()# dlib人脸检测器<br>predictor = dlib.shape_predictor(predictor_model)</p>
<h1 id="cv2读取图像"><a href="#cv2读取图像" class="headerlink" title="cv2读取图像"></a>cv2读取图像</h1><p>test_img_path = “input/Messi.jpg”<br>output_pos_info = “output_pos_info/Messi.txt”<br>img = cv2.imread(test_img_path)<br>file_handle = open(output_pos_info, ‘a’)</p>
<h1 id="取灰度"><a href="#取灰度" class="headerlink" title="取灰度"></a>取灰度</h1><p>img_gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)</p>
<h1 id="人脸数rects（rectangles）"><a href="#人脸数rects（rectangles）" class="headerlink" title="人脸数rects（rectangles）"></a>人脸数rects（rectangles）</h1><p>rects = detector(img_gray, 0)</p>
<p>for i in range(len(rects)):<br>    landmarks = np.matrix([[p.x, p.y] for p in predictor(img,rects[i]).parts()])<br>    for idx, point in enumerate(landmarks):</p>
<pre><code>    # 68点的坐标
    pos = (point[0, 0], point[0, 1])
    print(idx+1, pos)
    pos_info = str(point[0, 0]) + &#39; &#39; + str(point[0, 1]) + &#39;\n&#39;
    file_handle.write(pos_info)
    # 利用cv2.circle给每个特征点画一个圈，共68个
    cv2.circle(img, pos, 3, color=(0, 255, 0))
    # 利用cv2.putText输出1-68
    #font = cv2.FONT_HERSHEY_SIMPLEX
    #cv2.putText(img, str(idx+1), pos, font, 0.5, (0, 0, 255), 1, cv2.LINE_AA)
</code></pre><p>file_handle.close()<br>cv2.imwrite(“output/Messi_keypoints.png”, img)<br><figure class="highlight plaintext"><figcaption><span>大致过程如下：先用人脸检测器获取到人脸矩形框rectangles，再用68点shape模型获取`full_object_detection`对象。最后将关键点标记出来，并写入文本中。 `rects </span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line">predictor = dlib.shape_predictor(predictor_model)</span><br><span class="line">predictor(img,rects[i]).parts()</span><br><span class="line">predictor(img, rects[i]).part(1)</span><br></pre></td></tr></table></figure></p>
<p>predictor返回的是一个<code>full_object_detection</code>对象，通过<code>parts()</code>可以获得所有关键点的位置，通过<code>part(idx)</code>idx从0开始，可以获取某个关键点的信息。 <img src="/images/2020/01/0b76bab4c8876e791592ab1ba4bfb760.png" alt=""> 测试图片的原图与标注关键点后图片如下图所示。 <img src="/images/2020/01/63d16c7784509d2f8880da7e92b37d9c.png" alt=""> <img src="/images/2020/01/a8fc125fa7af4ec67798e3ba6ee2290e.png" alt=""></p>
<h2 id="脸部分割"><a href="#脸部分割" class="headerlink" title="脸部分割"></a>脸部分割</h2><p>两种方式：矩形框分割人脸和 不规则形状分割人脸</p>
<h3 id="矩形框分割人脸"><a href="#矩形框分割人脸" class="headerlink" title="矩形框分割人脸"></a>矩形框分割人脸</h3><p>可以采用<code>dlib.get_face_chip()</code>来分割人脸</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">代码功能：</span></span><br><span class="line"><span class="string">1. 用dlib人脸检测器检测出人脸，返回的人脸矩形框</span></span><br><span class="line"><span class="string">2. 对检测出的人脸进行关键点检测并切割出人脸</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> dlib</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">predictor_model = <span class="string">&#x27;shape_predictor_68_face_landmarks.dat&#x27;</span></span><br><span class="line">detector = dlib.get_frontal_face_detector()<span class="comment"># dlib人脸检测器</span></span><br><span class="line">predictor = dlib.shape_predictor(predictor_model)</span><br><span class="line"></span><br><span class="line"><span class="comment"># cv2读取图像</span></span><br><span class="line">test_img_path = <span class="string">&quot;input/Messi.jpg&quot;</span></span><br><span class="line">img = cv2.imread(test_img_path)</span><br><span class="line">img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line"><span class="comment"># 人脸数rects</span></span><br><span class="line">rects = detector(img, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># faces存储full_object_detection对象</span></span><br><span class="line">faces = dlib.full_object_detections()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(rects)):</span><br><span class="line">    faces.append(predictor(img,rects[i]))</span><br><span class="line"></span><br><span class="line">face_images = dlib.get_face_chips(img, faces, size=<span class="number">320</span>)</span><br><span class="line"><span class="keyword">for</span> image <span class="keyword">in</span> face_images:</span><br><span class="line">    cv_bgr_img = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;output/Messi_clip.png&#x27;</span>, cv_bgr_img)</span><br></pre></td></tr></table></figure>
<p>Dlib检测出的脸部区域对于下巴和额头区域会做过多的裁剪，并且分割使用的是矩形框。 分割结果如图 <img src="/images/2020/01/41bcb607dddb2e1b274cfa79516723c8.png" alt=""></p>
<h3 id="不规则形状分割人脸"><a href="#不规则形状分割人脸" class="headerlink" title="不规则形状分割人脸"></a>不规则形状分割人脸</h3><blockquote>
<p>先用dlib等打点工具把人脸最外层的landmark点打出来，然后利用opencv的convexhull得到凸包然后就可以抠出人脸区域了.</p>
</blockquote>
<p>python代码(获取人脸的掩模)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_image_hull_mask</span>(<span class="params">image_shape, image_landmarks, ie_polys=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># get the mask of the image</span></span><br><span class="line">    <span class="keyword">if</span> image_landmarks.shape[<span class="number">0</span>] != <span class="number">68</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(</span><br><span class="line">            <span class="string">&#x27;get_image_hull_mask works only with 68 landmarks&#x27;</span>)</span><br><span class="line">    int_lmrks = np.array(image_landmarks, dtype=np.<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#hull_mask = np.zeros(image_shape[0:2]+(1,), dtype=np.float32)</span></span><br><span class="line">    hull_mask = np.full(image_shape[<span class="number">0</span>:<span class="number">2</span>] + (<span class="number">1</span>,), <span class="number">0</span>, dtype=np.float32)</span><br><span class="line"></span><br><span class="line">    cv2.fillConvexPoly(hull_mask, cv2.convexHull(</span><br><span class="line">        np.concatenate((int_lmrks[<span class="number">0</span>:<span class="number">9</span>],</span><br><span class="line">                        int_lmrks[<span class="number">17</span>:<span class="number">18</span>]))), (<span class="number">1</span>,))</span><br><span class="line"></span><br><span class="line">    cv2.fillConvexPoly(hull_mask, cv2.convexHull(</span><br><span class="line">        np.concatenate((int_lmrks[<span class="number">8</span>:<span class="number">17</span>],</span><br><span class="line">                        int_lmrks[<span class="number">26</span>:<span class="number">27</span>]))), (<span class="number">1</span>,))</span><br><span class="line"></span><br><span class="line">    cv2.fillConvexPoly(hull_mask, cv2.convexHull(</span><br><span class="line">        np.concatenate((int_lmrks[<span class="number">17</span>:<span class="number">20</span>],</span><br><span class="line">                        int_lmrks[<span class="number">8</span>:<span class="number">9</span>]))), (<span class="number">1</span>,))</span><br><span class="line"></span><br><span class="line">    cv2.fillConvexPoly(hull_mask, cv2.convexHull(</span><br><span class="line">        np.concatenate((int_lmrks[<span class="number">24</span>:<span class="number">27</span>],</span><br><span class="line">                        int_lmrks[<span class="number">8</span>:<span class="number">9</span>]))), (<span class="number">1</span>,))</span><br><span class="line"></span><br><span class="line">    cv2.fillConvexPoly(hull_mask, cv2.convexHull(</span><br><span class="line">        np.concatenate((int_lmrks[<span class="number">19</span>:<span class="number">25</span>],</span><br><span class="line">                        int_lmrks[<span class="number">8</span>:<span class="number">9</span>],</span><br><span class="line">                        ))), (<span class="number">1</span>,))</span><br><span class="line"></span><br><span class="line">    cv2.fillConvexPoly(hull_mask, cv2.convexHull(</span><br><span class="line">        np.concatenate((int_lmrks[<span class="number">17</span>:<span class="number">22</span>],</span><br><span class="line">                        int_lmrks[<span class="number">27</span>:<span class="number">28</span>],</span><br><span class="line">                        int_lmrks[<span class="number">31</span>:<span class="number">36</span>],</span><br><span class="line">                        int_lmrks[<span class="number">8</span>:<span class="number">9</span>]</span><br><span class="line">                        ))), (<span class="number">1</span>,))</span><br><span class="line"></span><br><span class="line">    cv2.fillConvexPoly(hull_mask, cv2.convexHull(</span><br><span class="line">        np.concatenate((int_lmrks[<span class="number">22</span>:<span class="number">27</span>],</span><br><span class="line">                        int_lmrks[<span class="number">27</span>:<span class="number">28</span>],</span><br><span class="line">                        int_lmrks[<span class="number">31</span>:<span class="number">36</span>],</span><br><span class="line">                        int_lmrks[<span class="number">8</span>:<span class="number">9</span>]</span><br><span class="line">                        ))), (<span class="number">1</span>,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># nose</span></span><br><span class="line">    cv2.fillConvexPoly(</span><br><span class="line">        hull_mask, cv2.convexHull(int_lmrks[<span class="number">27</span>:<span class="number">36</span>]), (<span class="number">1</span>,))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ie_polys <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        ie_polys.overlay_mask(hull_mask)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    <span class="keyword">return</span> hull_mask</span><br></pre></td></tr></table></figure>
<p>方法利用的就是opencv的convexhull得到凸包然后就可以抠出人脸区域。 得到掩模，这里使用两种方式来得到人脸区域 1. 将mask作为$\\alpha$通道，来控制图片区域的透明度，最后得到图片是4通道的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_add_alpha</span>(<span class="params">img_1, mask</span>):</span><br><span class="line">    <span class="comment"># merge rgb and mask into a rgba image</span></span><br><span class="line">    r_channel, g_channel, b_channel = cv2.split(img_1)</span><br><span class="line">    <span class="keyword">if</span> mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        alpha_channel = np.ones(mask.shape, dtype=img_1.dtype)</span><br><span class="line">        alpha_channel *= mask*<span class="number">255</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        alpha_channel = np.zeros(img_1.shape[:<span class="number">2</span>], dtype=img_1.dtype)</span><br><span class="line">    img_BGRA = cv2.merge((b_channel, g_channel, r_channel, alpha_channel))</span><br><span class="line">    <span class="keyword">return</span> img_BGRA</span><br></pre></td></tr></table></figure>
<p>分割结果 <img src="/images/2020/01/fac8463e6dfcc01af5f1f95560df7787.png" alt=""></p>
<ol>
<li>掩模与原始图像进行与运算，返回图像是三通道。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_add_mask</span>(<span class="params">img_1, mask</span>):</span><br><span class="line">    <span class="keyword">if</span> mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        height = mask.shape[<span class="number">0</span>]</span><br><span class="line">        width = mask.shape[<span class="number">1</span>]</span><br><span class="line">        channel_num = mask.shape[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(channel_num):</span><br><span class="line">                    <span class="keyword">if</span> mask[row, col, c] == <span class="number">0</span>:</span><br><span class="line">                        mask[row, col, c] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        mask[row, col, c] = <span class="number">255</span></span><br><span class="line"></span><br><span class="line">        r_channel, g_channel, b_channel = cv2.split(img_1)</span><br><span class="line">        r_channel = cv2.bitwise_and(r_channel, mask)</span><br><span class="line">        g_channel = cv2.bitwise_and(g_channel, mask)</span><br><span class="line">        b_channel = cv2.bitwise_and(b_channel, mask)</span><br><span class="line">        res_img = cv2.merge((b_channel, g_channel, r_channel))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res_img = img_1</span><br><span class="line">    <span class="keyword">return</span> res_img</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>分割结果为 <img src="/images/2020/01/1f008f4ffc9f58946de4579a8e71e2fd.png" alt=""></p>
<h2 id="人脸对齐"><a href="#人脸对齐" class="headerlink" title="人脸对齐"></a>人脸对齐</h2><p>思路比较简单，计算两眼连线与水平线的夹角，然后通过角度得到对应的旋转矩阵。对图片进行相应的变换。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">single_face_alignment</span>(<span class="params">face, landmarks</span>):</span><br><span class="line">    eye_center = ((landmarks[<span class="number">36</span>, <span class="number">0</span>] + landmarks[<span class="number">45</span>, <span class="number">0</span>]) * <span class="number">1.</span> / <span class="number">2</span>,  <span class="comment"># 计算两眼的中心坐标</span></span><br><span class="line">                  (landmarks[<span class="number">36</span>, <span class="number">1</span>] + landmarks[<span class="number">45</span>, <span class="number">1</span>]) * <span class="number">1.</span> / <span class="number">2</span>)</span><br><span class="line">    dx = (landmarks[<span class="number">45</span>, <span class="number">0</span>] - landmarks[<span class="number">36</span>, <span class="number">0</span>])  <span class="comment"># note: right - right</span></span><br><span class="line">    dy = (landmarks[<span class="number">45</span>, <span class="number">1</span>] - landmarks[<span class="number">36</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    angle = math.atan2(dy, dx) * <span class="number">180.</span> / math.pi  <span class="comment"># 计算角度</span></span><br><span class="line">    RotateMatrix = cv2.getRotationMatrix2D(eye_center, angle, scale=<span class="number">1</span>)  <span class="comment"># 计算仿射矩阵</span></span><br><span class="line">    align_face = cv2.warpAffine(face, RotateMatrix, (face.shape[<span class="number">0</span>], face.shape[<span class="number">1</span>]))  <span class="comment"># 进行放射变换，即旋转</span></span><br><span class="line">    <span class="keyword">return</span> align_face</span><br></pre></td></tr></table></figure>
<p>人脸对齐后如图 <img src="/images/2020/01/d371e91bffc8b8158b282a0d5115bc00.png" alt=""> 这样就完成人脸检测—&gt;人脸关键点检测—&gt;人脸分割—&gt;人脸对齐。 具体代码参照<a href="https://github.com/Onwaier/SegfaceAndAlignByDlib">github</a> 可以用以上方法对fer2013数据集进行预处理，如图所示。 <img src="/images/2020/01/9b242c562a1fb5a0b059ae1bf4218aa6.png" alt=""></p>
]]></content>
      <categories>
        <category>人脸表情识别</category>
      </categories>
      <tags>
        <tag>dlib</tag>
        <tag>人脸对齐</tag>
        <tag>脸部分割</tag>
      </tags>
  </entry>
  <entry>
    <title>Facial Expression Recognition by De-expression Residue Learning阅读笔记</title>
    <url>/2020/01/06/facial-expression-recognition-by-de-expression-residue-learning%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>这是一篇CVPR2018关于表情识别的论文，作者可谓是独辟蹊径，从“De-expression”这一角度进行表情识别的研究。作者通过一些事实和文献发现，人的表情可以分解为Neutral Compoent和Expressive Componet两部分。作者的想法是将人脸经过一个GAN网络得到一张与之对应的中性表情，然后对residue(残余特征)进行训练学习，进一步进行表情分类。</p>
<h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h2><p><a href="http://openaccess.thecvf.com/content_cvpr_2018/papers/Yang_Facial_Expression_Recognition_CVPR_2018_paper.pdf">原文地址</a> 没有相应的源代码:sweat:</p>
<h2 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h2><p>现在的大部分研究关注的都是光照，姿态，遮挡等对表情识别的影响。作者关注的是个体差异像年龄，性别，种族背景等因素对表情识别的影响（the current main challenge comes from the large variations of individuals in attributes such as: age, gender, ethnic background and personality.）</p>
<h2 id="Inspriation"><a href="#Inspriation" class="headerlink" title="Inspriation"></a>Inspriation</h2><ol>
<li>people are capable of recognizing facial expressions by comparing a subject’s expression with a reference expression (i.e., neutral expression) of the same subject<a href="http://www.academia.edu/download/32367381/Haxby2000.pdf" title="The distributed human neural system for face perception.">[1]</a>.</li>
<li>a facial expression can be decomposed to an expressive component and neutral component<a href="https://www.researchgate.net/profile/Hongcheng_Wang2/publication/4038318_Facial_expression_decomposition/links/0c96052f2b6d962b9c000000/Facial-expression-decomposition.pdf" title="Facial expression decomposition">[2]</a> 人们可以通过一个参考表情来识别其它表情（这里参考表情用的是中性表情）；一个人脸表情可以分为中性部分和表情部分。如图所示。 <img src="/images/2020/01/330fe14bd634a07382f8b24ff992be00.png" alt=""></li>
</ol>
<h2 id="Network-architecture"><a href="#Network-architecture" class="headerlink" title="Network architecture"></a>Network architecture</h2><p><img src="/images/2020/01/caf5bfe3ca0b7862d75b8a454ccfed3e.png" alt=""> 网络结构大体可分为两部分：GAN(Generator)用来生成中性表情，并保存有residue，用于训练学习；第二部分是学习残余特征，然后进行表情分类。 网络结构有很多细节没有体现，比如説学习残余特征的网络结构还有5个损失函数都没详细说明，论文中也没有细说。这里主要是学习的是它分解表情的思想。</p>
<h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><p>cGAN<a href="https://arxiv.org/pdf/1411.1784" title="Conditional generative adversarial">[3]</a>被用来从一个给定的图片生成一个中性人脸表情。 cGAN训练的输入是一个图像对$<I\_{input}, I\_{target}>$，而生成器的输出为$I_{output}$。其中$I_{target}$是图片的中性表情的ground truth。$I_{output}$输出的是GAN生成的中性表情 The discriminator tries to distinguish the $&lt; I_{input}, I_{target} &gt;$ from the $&lt; I_{input}, I_{output} &gt;$ 判别器是为了尽力区分输出表情与ground truth之间的差别 the generator tries to not only maximally confuse the discriminator but also generate an image as close to the target image as possible. 而生成器则是尽可能使输出与ground truth足够接近，进而混淆视听。 Generator的目标函数 <img src="/images/2020/01/7419a9100f38f46d614c2643c42ae617.png" alt=""> Discriminator的目标函数 <img src="/images/2020/01/3c6757160eacbcb5b418621905b3bb7a.png" alt=""> cGAN的目标函数 <img src="/images/2020/01/e591d5785c462248fa2f8a506e873217.png" alt=""></p>
<h2 id="Classification"><a href="#Classification" class="headerlink" title="Classification"></a>Classification</h2><p>直接将ganerator的中间层的De-Expression Residue作为CNN分类器的输入进行表情分类。 具体是将Generator中所有尺寸大小一样的特征图合并在一起，分别输入到4个local的CNN分类器</p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p><img src="/images/2020/01/b09ef0ff83bbd52c4a985cb4d5207bc1.png" alt=""> 单个loss的系数大小取决于local classifier的表情分类效果 <img src="/images/2020/01/179cc1cf06a0448c1af0d393b471b81e.png" alt=""></p>
<h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><h3 id="Visualization-of-Expressive-Component"><a href="#Visualization-of-Expressive-Component" class="headerlink" title="Visualization of Expressive Component"></a>Visualization of Expressive Component</h3><p><img src="/images/2020/01/5fc4d9ff3ea64c9aacbfc75bc7b7344d.png" alt=""> 各个表情的残余特征可视化（从左到右是愤怒，厌恶，害怕，高兴，悲伤，惊讶）</p>
<h3 id="Visualization-of-Regenerated-Neutral-Faces"><a href="#Visualization-of-Regenerated-Neutral-Faces" class="headerlink" title="Visualization of Regenerated Neutral Faces"></a>Visualization of Regenerated Neutral Faces</h3><p>实验中采用的数据集CK+, MMI, Oulu-CASIA, BP4D+, BU-3DFE , BP4D, BU-4DFE.后2个用于预训练，前面5个方法用于比较实验，体现方法性能 生成器由输入图片得到中性图片 <img src="/images/2020/01/2e507c2dec1d94c8fcbf43b1306e08b6.png" alt=""> <img src="/images/2020/01/0420c28ac92d2dc0ebc90876819f3655.png" alt=""></p>
<h3 id="Accuracy-on-the-CK-database"><a href="#Accuracy-on-the-CK-database" class="headerlink" title="Accuracy on the CK+ database"></a>Accuracy on the CK+ database</h3><p>CK+与各个方法准确率比较 <img src="/images/2020/01/6e28a3360dfcb01d1eac8f122be6983a.png" alt=""> CK+混淆矩阵 <img src="/images/2020/01/f269360322cf23fb6266a44753a427a7.png" alt=""> 作者后面还在4个数据集上进行相同的实验，都取得比较好的性能，实验结果都处于前2的位置。</p>
]]></content>
      <categories>
        <category>人脸表情识别</category>
      </categories>
  </entry>
  <entry>
    <title>FERAtt: Facial Expression Recognition with Attention Net阅读笔记</title>
    <url>/2020/01/06/feratt-facial-expression-recognition-with-attention-net%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>这是一篇CVPRW2019的论文，作者将Attention机制引入到人脸表情识别中。提出Attention model，并写出了一个合成图片的生成器，模型对噪声有较强的鲁棒性，并在CK+，BU-3DFE数据集上有一定的性能提升。</p>
<h2 id="原文地址和github源码地址"><a href="#原文地址和github源码地址" class="headerlink" title="原文地址和github源码地址"></a>原文地址和github源码地址</h2><p><a href="http://openaccess.thecvf.com/content_CVPRW_2019/papers/MBCCV/Fernandez_FERAtt_Facial_Expression_Recognition_With_Attention_Net_CVPRW_2019_paper.pdf">原文地址</a> <a href="https://github.com/pedrodiamel/ferattention">github源码地址</a></p>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><blockquote>
<p>Recent developments for the facial expression recognition problem consider processing the entire image regardless of the face crop location within the image. Such developments bring in extraneous artifacts, including noise,which might be harmful for classification as well as incur in unnecessary additional computational cost. This is problematic as the minutiae that characterizes facial expressions can be affected by elements such as hair, jewelry, and other environmental objects not defining the actual face and as part of the image background.</p>
</blockquote>
<p>作者认为现在存在的很多研究关注在整张人脸，带来不必要的计算，并引入了一些噪声可能对识别性能产生影响，引入的一些因素像头发，珠宝等并不能决定表情识别的结果，应该作为图片的背景。</p>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>引入Attention机制，像人类的视觉感知一样，只关注目标区域的处理，与之无关的信息直接丢弃。如图所示。 <img src="/images/2020/01/98f0ed8bc463b9a20b4782c4b6a68fb8.png" alt=""><img src="/images/2020/01/505ffabc6a64bcbd5c26e320570eafad.png" alt=""></p>
<h2 id="Network-architecture"><a href="#Network-architecture" class="headerlink" title="Network architecture"></a>Network architecture</h2><p><img src="/images/2020/01/fdcd31b5324549e3bdefbcd6330fe65d.png" alt=""> 网络结构由4部分组成：注意力模块，特征提取模块，重建模块和分类表示模块。</p>
<h3 id="Attention-Module"><a href="#Attention-Module" class="headerlink" title="Attention Module"></a>Attention Module</h3><p><img src="/images/2020/01/f76e64e1b7af96ed39806180bd5dde21.png" alt=""> Attention模块将传统的人脸检测来用图像分割来代替。用了U-net来对图片进行分割，输出的是人脸的掩模。如图所示 <img src="/images/2020/01/86bcf19e0523e7fe72f5e1d3471112ec.png" alt=""><img src="/images/2020/01/ee75c94c91828d1209e92a61b9664428.png" alt=""></p>
<h3 id="Feature-extration-Module"><a href="#Feature-extration-Module" class="headerlink" title="Feature extration Module"></a>Feature extration Module</h3><blockquote>
<p>Four ResBlocks were used to extract high-dimensional features for image attention and to maintain spatial information; no pooling or strided convolutional layers were used.</p>
</blockquote>
<p>使用4个ResBlocks来提取高维度特征，保留空间信息。如图所示。 <img src="/images/2020/01/86bcf19e0523e7fe72f5e1d3471112ec.png" alt=""><img src="/images/2020/01/822c0cf06bd22a1e5900a56743403fa8.png" alt=""></p>
<h3 id="Reconstruction-Module"><a href="#Reconstruction-Module" class="headerlink" title="Reconstruction Module"></a>Reconstruction Module</h3><blockquote>
<p>The reconstruction layer adjusts the attention map to create an enhanced input to the representation module. This module has two convolutional layers, a Relu layer, and an Average Pooling layer which, by design choice, resizes the input image of 128 × 128 to 32 × 32.</p>
</blockquote>
<p><img src="/images/2020/01/f92f5b8b65b3e763a49f6851932497e0.png" alt=""></p>
<h3 id="Representation-and-classification-module"><a href="#Representation-and-classification-module" class="headerlink" title="Representation and classification module"></a>Representation and classification module</h3><p><img src="/images/2020/01/e50c646b0345a85f896b26abe0d35d53.png" alt=""> the network function, builds a representation for a sample image $x \\in R^D$ 主要是建立一个网络，对图片进行再表示，它的分类结果要与原图的分类结果足够接近。 <img src="/images/2020/01/78f82671a69914be48da83ffecfbb42e.png" alt=""> 详细过程参照论文，比较复杂。</p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p><img src="/images/2020/01/6b39eaeebf9d845f73242cdb60004a80.png" alt=""></p>
<h2 id="expriments"><a href="#expriments" class="headerlink" title="expriments"></a>expriments</h2><p>实验部分主要进行Rep模块的对照实验，数据集上的性能比较及算法对噪声的鲁棒性实验。</p>
<h3 id="Datasets"><a href="#Datasets" class="headerlink" title="Datasets"></a>Datasets</h3><blockquote>
<p>Our image renderer R creates a synthetic larger dataset using real face datasets by making background changes and geometric transformations of face images.</p>
</blockquote>
<p>将真实的人脸数据背景进行更换，然后再对人脸图片进行几何变换得到合成数据集。具体过程如图所示。 <img src="/images/2020/01/4dc600a7167dd01e6dc50a7f50030a47.png" alt=""> 使用的数据集有CK+、BU-3DFE、COCO dataset.其中COCO dataset 用作背景图。最后合成的数据集部分如图所示。 <img src="/images/2020/01/129c6e7ef5e4c4a5e564afc3ce255b20.png" alt=""></p>
<h3 id="Expression-recognition-results"><a href="#Expression-recognition-results" class="headerlink" title="Expression recognition results"></a>Expression recognition results</h3><p><img src="/images/2020/01/3d26de5c4ae9e4adf798e7906e823288.png" alt=""> Baseline为PreActResNet18，将其与FERAtt+Cls 和FERAtt + Rep + Cls两种方法进行性能比较，发现再表示对性能的提升有明显的效果。 <img src="/images/2020/01/2effcfe6a06fe696e4ba74dcc1cfa929.png" alt=""> <img src="/images/2020/01/28bdc6ed1023a7ad8320ca781d4fcf3c.png" alt=""></p>
<h3 id="Rebustness-to-noise"><a href="#Rebustness-to-noise" class="headerlink" title="Rebustness to noise"></a>Rebustness to noise</h3><p><img src="/images/2020/01/ca160a0a38b6391f62903167d8ac154b.png" alt=""> <img src="/images/2020/01/0645fc08ae449ba1ad4afe6bca0fb918.png" alt=""><img src="/images/2020/01/94cff341025800dc28d02de14269eba8.png" alt=""> FERAtt + Rep + Cls算法对噪声的鲁棒性较好，在$\\sigma = 0 - 0.10$对于识别性能几乎无影响，继续增大$\\sigma$的值时，它的识别的精度也一直处于其它算法之上。</p>
<h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2><ol>
<li>Attention model</li>
<li>A generator of synthetic images</li>
<li>Gaussian Manifold Loss</li>
</ol>
]]></content>
      <categories>
        <category>人脸表情识别</category>
      </categories>
      <tags>
        <tag>Attention</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/02/12/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>LeetCode 2019年第163场周赛</title>
    <url>/2019/11/26/leetcode-2019%E5%B9%B4%E7%AC%AC163%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="1260-二维网格迁移"><a href="#1260-二维网格迁移" class="headerlink" title="1260. 二维网格迁移"></a><a href="https://leetcode-cn.com/problems/shift-2d-grid/">1260. 二维网格迁移</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个 n 行 m 列的二维网格 grid 和一个整数 k。你需要将 grid 迁移 k 次。 每次「迁移」操作将会引发下述活动： 位于 grid[i][j] 的元素将会移动到 grid[i][j + 1]。 位于 grid[i][m - 1] 的元素将会移动到 grid[i + 1][0]。 位于 grid[n - 1][m - 1] 的元素将会移动到 grid[0][0]。 请你返回 k 次迁移操作后最终得到的 二维网格。 示例 1： <a href="https://i.loli.net/2019/11/23/2orHBzp5tOAvcku.png"><img src="https://i.loli.net/2019/11/23/2orHBzp5tOAvcku.png" alt=""></a> 输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1 输出：[[9,1,2],[3,4,5],[6,7,8]] 示例 2： <a href="https://i.loli.net/2019/11/23/XAE2bzdtPO6nhLU.png"><img src="https://i.loli.net/2019/11/23/XAE2bzdtPO6nhLU.png" alt=""></a> 输入：grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4 输出：[[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]] 示例 3： 输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9 输出：[[1,2,3],[4,5,6],[7,8,9]] 提示： 1 &lt;= grid.length &lt;= 50 1 &lt;= grid[i].length &lt;= 50 -1000 &lt;= grid[i][j] &lt;= 1000 0 &lt;= k &lt;= 100</p>
<h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>之前做过一个一维数组元素平移，最后面的移到前面。比赛时首先想到的是先把二维数组转成一维数组，然后平移元素。注意平移周期为数组长度。可以先对平移长度取模。</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">时间复杂度为o(m * n)</span></span><br><span class="line"><span class="comment">空间复杂度为o(m * n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">shiftGrid</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> k) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;tmp;</span><br><span class="line">        <span class="type">int</span> rows = grid.<span class="built_in">size</span>(), cols = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i)&#123;<span class="comment">//将二维数组转成一维数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[i].<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(grid[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = tmp.<span class="built_in">size</span>();</span><br><span class="line">        k = k % len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;<span class="comment">//对元素进行平移，不过这里是逆向思维</span></span><br><span class="line">            grid[i / cols][i % cols] = tmp[(i - k + len) % len];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="1261-在受污染的二叉树中查找元素"><a href="#1261-在受污染的二叉树中查找元素" class="headerlink" title="1261. 在受污染的二叉树中查找元素"></a><a href="https://leetcode-cn.com/problems/find-elements-in-a-contaminated-binary-tree/">1261. 在受污染的二叉树中查找元素</a></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个满足下述规则的二叉树： root.val == 0 如果 treeNode.val == x 且 treeNode.left != null，那么 treeNode.left.val == 2 * x + 1 如果 treeNode.val == x 且 treeNode.right != null，那么 treeNode.right.val == 2 * x + 2 现在这个二叉树受到「污染」，所有的 treeNode.val 都变成了 -1。 请你先还原二叉树，然后实现 FindElements 类： FindElements(TreeNode* root) 用受污染的二叉树初始化对象，你需要先把它还原。 bool find(int target) 判断目标值 target 是否存在于还原后的二叉树中并返回结果。 示例 1： <a href="https://i.loli.net/2019/11/23/EnSBGjdxgfKOuQt.jpg"><img src="https://i.loli.net/2019/11/23/EnSBGjdxgfKOuQt.jpg" alt=""></a> 输入： [“FindElements”,”find”,”find”] [[[-1,null,-1]],[1],[2]] 输出： [null,false,true] 解释： FindElements findElements = new FindElements([-1,null,-1]); findElements.find(1); // return False findElements.find(2); // return True 示例 2： <a href="https://i.loli.net/2019/11/23/cqVMmel29TdQ4YW.jpg"><img src="https://i.loli.net/2019/11/23/cqVMmel29TdQ4YW.jpg" alt=""></a> 输入： [“FindElements”,”find”,”find”,”find”] [[[-1,-1,-1,-1,-1]],[1],[3],[5]] 输出： [null,true,true,false] 解释： FindElements findElements = new FindElements([-1,-1,-1,-1,-1]); findElements.find(1); // return True findElements.find(3); // return True findElements.find(5); // return False 示例 3： <a href="https://i.loli.net/2019/11/23/tLzRWBQbChTl8y7.jpg"><img src="https://i.loli.net/2019/11/23/tLzRWBQbChTl8y7.jpg" alt=""></a> 输入： [“FindElements”,”find”,”find”,”find”,”find”] [[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]] 输出： [null,true,false,false,true] 解释： FindElements findElements = new FindElements([-1,null,-1,-1,null,-1]); findElements.find(2); // return True findElements.find(3); // return False findElements.find(4); // return False findElements.find(5); // return True 提示： TreeNode.val == -1 二叉树的高度不超过 20 节点的总数在 [1, 10^4] 之间 调用 find() 的总次数在 [1, 10^4] 之间 0 &lt;= target &lt;= 10^6</p>
<h2 id="题解1-1"><a href="#题解1-1" class="headerlink" title="题解1"></a>题解1</h2><p>题目大意是已经给出二叉树的结构，但是结点值不正确，首先根据给定的规则，对二叉树节点重新赋值。然后写出find函数。 对于二叉树的构建及find函数常见的方法是递归的方式，但是后来我发现find的传入参数不是没有root。实现有点麻烦，后来用的是队列实现的。类似于BFS</p>
<h2 id="代码1-1"><a href="#代码1-1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FindElements</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *res;</span><br><span class="line">    <span class="built_in">FindElements</span>(TreeNode* root) &#123;</span><br><span class="line">        res = root;</span><br><span class="line">        <span class="keyword">if</span>(res == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt;que;</span><br><span class="line">        TreeNode* frt;</span><br><span class="line">        res-&gt;val = <span class="number">0</span>;</span><br><span class="line">        que.<span class="built_in">push</span>(res);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;<span class="comment">//BFS为节点赋值</span></span><br><span class="line">            frt = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(frt-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                frt-&gt;left-&gt;val = frt-&gt;val * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                que.<span class="built_in">push</span>(frt-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(frt-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                frt-&gt;right-&gt;val = frt-&gt;val * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">                que.<span class="built_in">push</span>(frt-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt;que;</span><br><span class="line">            TreeNode* frt;</span><br><span class="line">            que.<span class="built_in">push</span>(res);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;<span class="comment">//BFS遍历节点，来寻找节点</span></span><br><span class="line">                frt = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(frt-&gt;val == target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(frt-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(frt-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(frt-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(frt-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FindElements object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FindElements* obj = new FindElements(root);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;find(target);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="1262-可被三整除的最大和"><a href="#1262-可被三整除的最大和" class="headerlink" title="1262. 可被三整除的最大和"></a><a href="https://leetcode-cn.com/problems/greatest-sum-divisible-by-three/">1262. 可被三整除的最大和</a></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。 示例 1： 输入：nums = [3,6,5,1,8] 输出：18 解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。 示例 2： 输入：nums = [4] 输出：0 解释：4 不能被 3 整除，所以无法选出数字，返回 0。 示例 3： 输入：nums = [1,2,3,4,4] 输出：12 解释：选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。 提示： 1 &lt;= nums.length &lt;= 4 * 10^4 1 &lt;= nums[i] &lt;= 10^4</p>
<h2 id="题解1-2"><a href="#题解1-2" class="headerlink" title="题解1"></a>题解1</h2><p>这个题比赛的时候，思路没理清，导致写出来的代码bug多，赛后想了感觉很简单。 1. 所有元素排序 2. 求所有元素之和对3的余数res，期间各存下余数为1和余数为2的最小的2个数（4个数） 3. res = 0的话，被三整除的最大和为元素和。res=1的话需要去除1个余数为1的数或2个余数为2的数，需要比较一个，选择和大的一个。res=2的话需要去除2个余数为1的数或1个余数为2的数，同样比较取和较大的一种方案</p>
<h2 id="代码1-2"><a href="#代码1-2" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSumDivThree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span> , mod = <span class="number">0</span>, len = nums.<span class="built_in">size</span>(), res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;v1, v2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">            sum = sum + nums[i];</span><br><span class="line">            mod = (mod + nums[i]) % <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span>(v1.<span class="built_in">size</span>() &lt; <span class="number">2</span> &amp;&amp; nums[i] % <span class="number">3</span> == <span class="number">1</span>)&#123;<span class="comment">//存储至多2个最小的余数为1的</span></span><br><span class="line">                v1.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(v2.<span class="built_in">size</span>() &lt; <span class="number">2</span> &amp;&amp; nums[i] % <span class="number">3</span> == <span class="number">2</span>)&#123;<span class="comment">//存储至多2个最小的余数为2的</span></span><br><span class="line">                v2.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mod == <span class="number">0</span>)&#123;<span class="comment">//刚好余数为0</span></span><br><span class="line">            res = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(mod == <span class="number">1</span>)&#123;<span class="comment">//需去除1个余数为1的或2个余数为2的</span></span><br><span class="line">            <span class="type">int</span> num1 = sum - (v1.<span class="built_in">size</span>() &gt; <span class="number">0</span>?v1[<span class="number">0</span>]:sum);</span><br><span class="line">            <span class="type">int</span> num2 = sum - (v2.<span class="built_in">size</span>() &gt; <span class="number">1</span>?v2[<span class="number">0</span>] + v2[<span class="number">1</span>]:sum);</span><br><span class="line">            res = <span class="built_in">max</span>(num1, num2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//需去除2个余数为1的或者1个余数为2的</span></span><br><span class="line">            <span class="type">int</span> num1 = sum - (v1.<span class="built_in">size</span>() &gt; <span class="number">1</span>?v1[<span class="number">0</span>] + v1[<span class="number">1</span>]:sum);</span><br><span class="line">            <span class="type">int</span> num2 = sum - (v2.<span class="built_in">size</span>() &gt; <span class="number">0</span>?v2[<span class="number">0</span>]:sum);</span><br><span class="line">            res = <span class="built_in">max</span>(num1, num2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="1263-推箱子"><a href="#1263-推箱子" class="headerlink" title="1263. 推箱子"></a><a href="https://leetcode-cn.com/problems/minimum-moves-to-move-a-box-to-their-target-location/">1263. 推箱子</a></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>「推箱子」是一款风靡全球的益智小游戏，玩家需要将箱子推到仓库中的目标位置。 游戏地图用大小为 n * m 的网格 grid 表示，其中每个元素可以是墙、地板或者是箱子。 现在你将作为玩家参与游戏，按规则将箱子 ‘B’ 移动到目标位置 ‘T’ ： 玩家用字符 ‘S’ 表示，只要他在地板上，就可以在网格中向上、下、左、右四个方向移动。 地板用字符 ‘.’ 表示，意味着可以自由行走。 墙用字符 ‘#’ 表示，意味着障碍物，不能通行。  箱子仅有一个，用字符 ‘B’ 表示。相应地，网格上有一个目标位置 ‘T’。 玩家需要站在箱子旁边，然后沿着箱子的方向进行移动，此时箱子会被移动到相邻的地板单元格。记作一次「推动」。 玩家无法越过箱子。 返回将箱子推到目标位置的最小 推动 次数，如果无法做到，请返回 -1。 示例 1： <img src="http://onwaier.com/wp-content/uploads/2019/11/e6a45f2f849776d3b3f691a9c3738854.png" alt=""> 输入：grid = [[“#”,”#”,”#”,”#”,”#”,”#”], [“#”,”T”,”#”,”#”,”#”,”#”],   [“#”,”.”,”.”,”B”,”.”,”#”],   [“#”,”.”,”#”,”#”,”.”,”#”],   [“#”,”.”,”.”,”.”,”S”,”#”],   [“#”,”#”,”#”,”#”,”#”,”#”]] 输出：3 解释：我们只需要返回推箱子的次数。 示例 2： 输入：grid = [[“#”,”#”,”#”,”#”,”#”,”#”], [“#”,”T”,”#”,”#”,”#”,”#”],   [“#”,”.”,”.”,”B”,”.”,”#”],   [“#”,”#”,”#”,”#”,”.”,”#”],   [“#”,”.”,”.”,”.”,”S”,”#”],   [“#”,”#”,”#”,”#”,”#”,”#”]] 输出：-1 示例 3： 输入：grid = [[“#”,”#”,”#”,”#”,”#”,”#”],   [“#”,”T”,”.”,”.”,”#”,”#”],   [“#”,”.”,”#”,”B”,”.”,”#”],   [“#”,”.”,”.”,”.”,”.”,”#”],   [“#”,”.”,”.”,”.”,”S”,”#”],   [“#”,”#”,”#”,”#”,”#”,”#”]] 输出：5 解释：向下、向左、向左、向上再向上。 示例 4： 输入：grid = [[“#”,”#”,”#”,”#”,”#”,”#”,”#”],   [“#”,”S”,”#”,”.”,”B”,”T”,”#”],   [“#”,”#”,”#”,”#”,”#”,”#”,”#”]] 输出：-1 提示： 1 &lt;= grid.length &lt;= 20 1 &lt;= grid[i].length &lt;= 20 grid 仅包含字符 ‘.’, ‘#’,  ‘S’ , ‘T’, 以及 ‘B’。 grid 中 ‘S’, ‘B’ 和 ‘T’ 各只能出现一个。</p>
<h2 id="题解1-3"><a href="#题解1-3" class="headerlink" title="题解1"></a>题解1</h2><p>参照<a href="https://leetcode-cn.com/problems/minimum-moves-to-move-a-box-to-their-target-location/solution/1263-by-ikaruga/">题解</a> 如果只有箱子没有人，只是将箱子移到目标位置，就是常见的BFS问题。而这个题有两个对象，箱子和人，要保证箱子能被推到目标位置。加入队列的信息除了箱子的坐标还有人的坐标，随着人的移动来判断人是否能走到箱子的位置，能表示箱子移动，步数加1；否则只是人的位置发生移动，此时步数并未增加。此外，标记对象也发生改变，以前只是箱子这个二元组，现在变成了人和箱子这个四元组。因为人移动带来的步数并不一定增长，这里需要用到优先队列，每次选取步数最小的来移动。</p>
<h2 id="代码1-3"><a href="#代码1-3" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(vector&lt;<span class="type">int</span>&gt;v1, vector&lt;<span class="type">int</span>&gt;v2)</span></span>&#123;<span class="comment">//定义优先级别</span></span><br><span class="line">        <span class="keyword">return</span> v1[<span class="number">0</span>] &gt; v2[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;<span class="comment">//定义移动方向</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPushBox</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        set&lt;vector&lt;<span class="type">int</span>&gt; &gt;mark;<span class="comment">//用set来标记</span></span><br><span class="line">        <span class="type">int</span> rows = grid.<span class="built_in">size</span>(), cols = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> x1, x2, y1, y2, x3, y3, next_x, next_y, dist;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">        priority_queue&lt;vector&lt;<span class="type">int</span>&gt;, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;, cmp&gt;que;<span class="comment">//定义优先队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;S&#x27;</span>)&#123;<span class="comment">//玩家</span></span><br><span class="line">                    x1 = i;</span><br><span class="line">                    y1 = j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;B&#x27;</span>)&#123;<span class="comment">//箱子</span></span><br><span class="line">                    x2 = i;</span><br><span class="line">                    y2 = j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;T&#x27;</span>)&#123;<span class="comment">//目标</span></span><br><span class="line">                    x3 = i;</span><br><span class="line">                    y3 = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">push</span>(&#123;<span class="number">0</span>, x1, y1, x2, y2&#125;);<span class="comment">//初始化</span></span><br><span class="line">        mark.<span class="built_in">insert</span>(&#123;x1, y1, x2, y2&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            v = que.<span class="built_in">top</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(v[<span class="number">3</span>] == x3 &amp;&amp; v[<span class="number">4</span>] == y3)&#123;</span><br><span class="line">                <span class="keyword">return</span> v[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">                x1 = v[<span class="number">1</span>] + dir[i][<span class="number">0</span>];</span><br><span class="line">                y1 = v[<span class="number">2</span>] + dir[i][<span class="number">1</span>];</span><br><span class="line">                dist = v[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(x1 &lt; <span class="number">0</span>  x1 &gt;= rows  y1 &lt; <span class="number">0</span>  y1 &gt;= cols)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(grid[x1][y1] != <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(x1 == v[<span class="number">3</span>] &amp;&amp; y1 == v[<span class="number">4</span>])&#123;</span><br><span class="line">                        x2 = v[<span class="number">3</span>] + dir[i][<span class="number">0</span>];</span><br><span class="line">                        y2 = v[<span class="number">4</span>] + dir[i][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(x2 &gt;= <span class="number">0</span> &amp;&amp; x2 &lt; rows &amp;&amp; y2 &gt;= <span class="number">0</span> &amp;&amp; y2 &lt; cols &amp;&amp; grid[x2][y2] != <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(mark.<span class="built_in">find</span>(&#123;x1, y1, x2, y2&#125;) == mark.<span class="built_in">end</span>())&#123;<span class="comment">//未访问过</span></span><br><span class="line">                                mark.<span class="built_in">insert</span>(&#123;x1, y1, x2, y2&#125;);</span><br><span class="line">                                que.<span class="built_in">push</span>(&#123;dist + <span class="number">1</span>, x1, y1, x2, y2&#125;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(mark.<span class="built_in">find</span>(&#123;x1, y1, v[<span class="number">3</span>], v[<span class="number">4</span>]&#125;) == mark.<span class="built_in">end</span>())&#123;<span class="comment">//未访问过</span></span><br><span class="line">                            mark.<span class="built_in">insert</span>(&#123;x1, y1, v[<span class="number">3</span>], v[<span class="number">4</span>]&#125;);</span><br><span class="line">                            que.<span class="built_in">push</span>(&#123;dist, x1, y1, v[<span class="number">3</span>], v[<span class="number">4</span>]&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode2019年第165场周赛</title>
    <url>/2019/12/02/leetcode2019%E5%B9%B4%E7%AC%AC165%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="1275-找出井字棋的获胜者"><a href="#1275-找出井字棋的获胜者" class="headerlink" title="1275. 找出井字棋的获胜者"></a><a href="https://leetcode-cn.com/problems/find-winner-on-a-tic-tac-toe-game/">1275. 找出井字棋的获胜者</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>A 和 B 在一个 3 x 3 的网格上玩井字棋。 井字棋游戏的规则如下： 玩家轮流将棋子放在空方格 (“ “) 上。 第一个玩家 A 总是用 “X” 作为棋子，而第二个玩家 B 总是用 “O” 作为棋子。 “X” 和 “O” 只能放在空方格中，而不能放在已经被占用的方格上。 只要有 3 个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。 如果所有方块都放满棋子（不为空），游戏也会结束。 游戏结束后，棋子无法再进行任何移动。 给你一个数组 moves，其中每个元素是大小为 2 的另一个数组（元素分别对应网格的行和列），它按照 A 和 B 的行动顺序（先 A 后 B）记录了两人各自的棋子位置。 如果游戏存在获胜者（A 或 B），就返回该游戏的获胜者；如果游戏以平局结束，则返回 “Draw”；如果仍会有行动（游戏未结束），则返回 “Pending”。 你可以假设 moves 都 有效（遵循井字棋规则），网格最初是空的，A 将先行动。 示例 1： 输入：moves = [[0,0],[2,0],[1,1],[2,1],[2,2]] 输出：”A” 解释：”A” 获胜，他总是先走。 “X “ “X “ “X “ “X “ “X “ “ “ -&gt; “ “ -&gt; “ X “ -&gt; “ X “ -&gt; “ X “ “ “ “O “ “O “ “OO “ “OOX” 示例 2： 输入：moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]] 输出：”B” 解释：”B” 获胜。 “X “ “X “ “XX “ “XXO” “XXO” “XXO” “ “ -&gt; “ O “ -&gt; “ O “ -&gt; “ O “ -&gt; “XO “ -&gt; “XO “ “ “ “ “ “ “ “ “ “ “ “O “ 示例 3： 输入：moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]] 输出：”Draw” 输出：由于没有办法再行动，游戏以平局结束。 “XXO” “OOX” “XOX” 示例 4： 输入：moves = [[0,0],[1,1]] 输出：”Pending” 解释：游戏还没有结束。 “X “ “ O “ “ “   提示： 1 &lt;= moves.length &lt;= 9 moves[i].length == 2 0 &lt;= moves[i][j] &lt;= 2 moves 里没有重复的元素。 moves 遵循井字棋的规则。</p>
<h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>模拟即可，判断横，竖，及对角线只否有连线成功，有则返回对应的胜利者，没有的话，就看还有没有空位可以继续行动，有的话，表示仍可以行动，没有的话，就是平局。</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">deal</span><span class="params">(<span class="type">int</span> arr[<span class="number">3</span>][<span class="number">3</span>])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i][<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; arr[i][<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; arr[i][<span class="number">2</span>] == <span class="number">0</span>)&#123;<span class="comment">//行  - A</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[i][<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; arr[i][<span class="number">1</span>] == <span class="number">1</span> &amp;&amp; arr[i][<span class="number">2</span>] == <span class="number">1</span>)&#123;<span class="comment">//行 - B</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">0</span>][i] == <span class="number">0</span> &amp;&amp; arr[<span class="number">1</span>][i] == <span class="number">0</span> &amp;&amp; arr[<span class="number">2</span>][i] == <span class="number">0</span>)&#123;<span class="comment">// 列 - A</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">0</span>][i] == <span class="number">1</span> &amp;&amp; arr[<span class="number">1</span>][i] == <span class="number">1</span> &amp;&amp; arr[<span class="number">2</span>][i] == <span class="number">1</span>)&#123;<span class="comment">// 列 － B</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(arr[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; arr[<span class="number">1</span>][<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; arr[<span class="number">2</span>][<span class="number">2</span>] == <span class="number">0</span>)&#123;<span class="comment">//主 对角线 - A</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(arr[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; arr[<span class="number">1</span>][<span class="number">1</span>] == <span class="number">1</span> &amp;&amp; arr[<span class="number">2</span>][<span class="number">2</span>] == <span class="number">1</span>)&#123;<span class="comment">//主对角线 - B </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(arr[<span class="number">0</span>][<span class="number">2</span>] == <span class="number">0</span> &amp;&amp; arr[<span class="number">1</span>][<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; arr[<span class="number">2</span>][<span class="number">0</span>] == <span class="number">0</span>)&#123;<span class="comment">//副对角线 - A</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(arr[<span class="number">0</span>][<span class="number">2</span>] == <span class="number">1</span> &amp;&amp; arr[<span class="number">1</span>][<span class="number">1</span>] == <span class="number">1</span> &amp;&amp; arr[<span class="number">2</span>][<span class="number">0</span>] == <span class="number">1</span>)&#123;<span class="comment">//副对角线 - B</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">tictactoe</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; moves)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>  j = <span class="number">0</span>;j &lt; <span class="number">3</span>; ++j)&#123;</span><br><span class="line">                arr[i][j] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; moves.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &amp; <span class="number">1</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                arr[moves[i][<span class="number">0</span>]][moves[i][<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                arr[moves[i][<span class="number">0</span>]][moves[i][<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">deal</span>(arr);</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>  j = <span class="number">0</span>;j &lt; <span class="number">3</span>; ++j)&#123;</span><br><span class="line">                cout &lt;&lt; arr[i][i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[i][j] == <span class="number">-1</span>)&#123;<span class="comment">//有空格</span></span><br><span class="line">                        flag = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Pending&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Draw&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">deal</span>(arr) == <span class="number">0</span>?<span class="string">&quot;A&quot;</span>:<span class="string">&quot;B&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="1276-不浪费原料的汉堡制作方案"><a href="#1276-不浪费原料的汉堡制作方案" class="headerlink" title="1276. 不浪费原料的汉堡制作方案"></a><a href="https://leetcode-cn.com/problems/number-of-burgers-with-no-waste-of-ingredients/">1276. 不浪费原料的汉堡制作方案</a></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>圣诞活动预热开始啦，汉堡店推出了全新的汉堡套餐。为了避免浪费原料，请你帮他们制定合适的制作计划。 给你两个整数 tomatoSlices 和 cheeseSlices，分别表示番茄片和奶酪片的数目。不同汉堡的原料搭配如下： 巨无霸汉堡：4 片番茄和 1 片奶酪 小皇堡：2 片番茄和 1 片奶酪 请你以 [total_jumbo, total_small]（[巨无霸汉堡总数，小皇堡总数]）的格式返回恰当的制作方案，使得剩下的番茄片 tomatoSlices 和奶酪片 cheeseSlices 的数量都是 0。 如果无法使剩下的番茄片 tomatoSlices 和奶酪片 cheeseSlices 的数量为 0，就请返回 []。 示例 1： 输入：tomatoSlices = 16, cheeseSlices = 7 输出：[1,6] 解释：制作 1 个巨无霸汉堡和 6 个小皇堡需要 4_1 + 2_6 = 16 片番茄和 1 + 6 = 7 片奶酪。不会剩下原料。 示例 2： 输入：tomatoSlices = 17, cheeseSlices = 4 输出：[] 解释：只制作小皇堡和巨无霸汉堡无法用光全部原料。 示例 3： 输入：tomatoSlices = 4, cheeseSlices = 17 输出：[] 解释：制作 1 个巨无霸汉堡会剩下 16 片奶酪，制作 2 个小皇堡会剩下 15 片奶酪。 示例 4： 输入：tomatoSlices = 0, cheeseSlices = 0 输出：[0,0] 示例 5： 输入：tomatoSlices = 2, cheeseSlices = 1 输出：[0,1]</p>
<h2 id="题解1-1"><a href="#题解1-1" class="headerlink" title="题解1"></a>题解1</h2><p>解二元一次方程组即可，注意两个变量的解均为非负值。</p>
<h2 id="代码1-1"><a href="#代码1-1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">numOfBurgers</span><span class="params">(<span class="type">int</span> tom, <span class="type">int</span> che)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="type">int</span> tmp = tom - <span class="number">2</span> * che;</span><br><span class="line">        <span class="keyword">if</span>(tmp &lt; <span class="number">0</span>  tmp &amp; <span class="number">1</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(tmp &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        res.<span class="built_in">push_back</span>(che - (tmp &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(res[<span class="number">0</span>] &lt; <span class="number">0</span>  res[<span class="number">1</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            res.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="1277-统计全为-1-的正方形子矩阵"><a href="#1277-统计全为-1-的正方形子矩阵" class="headerlink" title="1277. 统计全为 1 的正方形子矩阵"></a><a href="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/">1277. 统计全为 1 的正方形子矩阵</a></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。 示例 1： 输入：matrix = [   [0,1,1,1],   [1,1,1,1],   [0,1,1,1] ] 输出：15 解释： 边长为 1 的正方形有 10 个。 边长为 2 的正方形有 4 个。 边长为 3 的正方形有 1 个。 正方形的总数 = 10 + 4 + 1 = 15. 示例 2： 输入：matrix = [ [1,0,1], [1,1,0], [1,1,0] ] 输出：7 解释： 边长为 1 的正方形有 6 个。 边长为 2 的正方形有 1 个。 正方形的总数 = 6 + 1 = 7. 提示： 1 &lt;= arr.length &lt;= 300 1 &lt;= arr[0].length &lt;= 300 0 &lt;= arr[i][j] &lt;= 1</p>
<h2 id="题解1-2"><a href="#题解1-2" class="headerlink" title="题解1"></a>题解1</h2><p>模拟，固定正方形的左上角，改变它的边长，直接求解的时间复杂度为$o(n^4)$，可以用$o(n^2)$的空间来存储行和与列和，只需要判断序列和是否与边长相等即可。具体实现见代码。</p>
<h2 id="代码1-2"><a href="#代码1-2" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> rowSum[<span class="number">305</span>][<span class="number">305</span>];</span><br><span class="line"><span class="type">int</span> colSum[<span class="number">305</span>][<span class="number">305</span>];</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSquares</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(rowSum, <span class="number">0</span>, <span class="built_in">sizeof</span>(rowSum));</span><br><span class="line">        <span class="built_in">memset</span>(rowSum, <span class="number">0</span>, <span class="built_in">sizeof</span>(rowSum));</span><br><span class="line">        <span class="type">int</span> len1 = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len2 = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len1; ++i)&#123;<span class="comment">//行和</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; len2; ++j)&#123;</span><br><span class="line">                rowSum[i][j] = matrix[i][j] + (j == <span class="number">0</span>?<span class="number">0</span>:rowSum[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len1; ++i)&#123;<span class="comment">//列和</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; len2; ++j)&#123;</span><br><span class="line">                colSum[i][j] = matrix[i][j] + (i == <span class="number">0</span>?<span class="number">0</span>:colSum[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> res = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len1; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; len2; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    ++num;</span><br><span class="line">                    <span class="type">int</span> tmp1, tmp2;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> m = i, n = j;m &lt; len1, n &lt; len2; m = m+<span class="number">1</span>, n = n+<span class="number">1</span>)&#123;<span class="comment">//固定左上角顶，扩大边长</span></span><br><span class="line">                        <span class="keyword">if</span>(j - <span class="number">1</span> &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                            tmp1 = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            tmp1 = rowSum[m][j - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(i - <span class="number">1</span> &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                            tmp2 = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            tmp2 = colSum[i - <span class="number">1</span>][n];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>((rowSum[m][n] - tmp1 == n - j + <span class="number">1</span>) &amp;&amp; (colSum[m][n] - tmp2 == m - i + <span class="number">1</span>))&#123;</span><br><span class="line">                            ++res;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="1278-分割回文串-III"><a href="#1278-分割回文串-III" class="headerlink" title="1278. 分割回文串 III"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning-iii/submissions/">1278. 分割回文串 III</a></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个由小写字母组成的字符串 s，和一个整数 k。 请你按下面的要求分割字符串： 首先，你可以将 s 中的部分字符修改为其他的小写英文字母。 接着，你需要把 s 分割成 k 个非空且不相交的子串，并且每个子串都是回文串。 请返回以这种方式分割字符串所需修改的最少字符数。 示例 1： 输入：s = “abc”, k = 2 输出：1 解释：你可以把字符串分割成 “ab” 和 “c”，并修改 “ab” 中的 1 个字符，将它变成回文串。 示例 2： 输入：s = “aabbc”, k = 3 输出：0 解释：你可以把字符串分割成 “aa”、”bb” 和 “c”，它们都是回文串。 示例 3： 输入：s = “leetcode”, k = 8 输出：0   提示： 1 &lt;= k &lt;= s.length &lt;= 100 s 中只含有小写英文字母。</p>
<h2 id="题解1-3"><a href="#题解1-3" class="headerlink" title="题解1"></a>题解1</h2><p>动态规划 dp[i][j]表示长度为j的字符串，划成i个回文串所需最少替换次数。 其中dp[i][j]的状态转换方程为 $dp[i][j] = min(dp[i][j], dp[i - 1][k] + deal(k, j - 1))\space k=i-1, \dots, j - 1$</p>
<h2 id="代码1-3"><a href="#代码1-3" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX (1 &lt;&lt; 30)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(string s, <span class="type">int</span> beg, <span class="type">int</span> end)</span></span>&#123;<span class="comment">//计算变成回文串的步数</span></span><br><span class="line">    <span class="type">int</span> len = end - beg + <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(len &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = beg, j = end; i &lt; beg + (end - beg + <span class="number">1</span>) / <span class="number">2</span>; ++i, --j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != s[j])&#123;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">palindromePartition</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">105</span>][<span class="number">105</span>];<span class="comment">//dp[i][j]表示将长为j的字符串分成i段</span></span><br><span class="line">        <span class="type">int</span> len =  s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; ++i)&#123;<span class="comment">//初始化</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">100</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i  &gt;=  j)&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = MAX;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)&#123;<span class="comment">//分段</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= len; ++j)&#123;<span class="comment">//j的长度</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = i - <span class="number">1</span>; k &lt;= j; ++k)&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i - <span class="number">1</span>][k] + <span class="built_in">cal</span>(s, k, j - <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k][len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode2019第 164 场周赛</title>
    <url>/2019/11/27/leetcode2019%E7%AC%AC-164-%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="1266-访问所有点的最小时间"><a href="#1266-访问所有点的最小时间" class="headerlink" title="1266. 访问所有点的最小时间"></a><a href="https://leetcode-cn.com/problems/minimum-time-visiting-all-points/">1266. 访问所有点的最小时间</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>平面上有 n 个点，点的位置用整数坐标表示 points[i] = [xi, yi]。请你计算访问所有这些点需要的最小时间（以秒为单位）。 你可以按照下面的规则在平面上移动： 每一秒沿水平或者竖直方向移动一个单位长度，或者跨过对角线（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。 必须按照数组中出现的顺序来访问这些点。 示例 1： <img src="/images/2019/11/df66aa01420aca6ff3b64ace60f4a805.png" alt=""> 输入：points = [[1,1],[3,4],[-1,0]] 输出：7 解释：一条最佳的访问路径是： [1,1] -&gt; [2,2] -&gt; [3,3] -&gt; [3,4] -&gt; [2,3] -&gt; [1,2] -&gt; [0,1] -&gt; [-1,0] 从 [1,1] 到 [3,4] 需要 3 秒 从 [3,4] 到 [-1,0] 需要 4 秒 一共需要 7 秒 示例 2： 输入：points = [[3,2],[-2,2]] 输出：5  提示： points.length == n 1 &lt;= n &lt;= 100 points[i].length == 2 -1000 &lt;= points[i][0], points[i][1] &lt;= 1000</p>
<h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>相邻两点间访问时，如果横坐标相等或者纵坐标相等，直接沿竖直方向或水平方向移动一个单位长度。如果不相等，则先沿对角线移动使横坐标或纵坐标相等，然后再水平或垂直移动。</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minTimeToVisitAllPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, len = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>] == points[i - <span class="number">1</span>][<span class="number">0</span>])&#123;<span class="comment">//横坐标相等</span></span><br><span class="line">                sum += <span class="built_in">abs</span>(points[i][<span class="number">1</span>] - points[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(points[i][<span class="number">1</span>] == points[i - <span class="number">1</span>][<span class="number">1</span>])&#123;<span class="comment">//纵坐标相等</span></span><br><span class="line">                sum += <span class="built_in">abs</span>(points[i][<span class="number">0</span>] - points[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(points[i][<span class="number">0</span>] - points[i - <span class="number">1</span>][<span class="number">0</span>]) &lt; <span class="built_in">abs</span>(points[i][<span class="number">1</span>] - points[i - <span class="number">1</span>][<span class="number">1</span>]))&#123;<span class="comment">//纵</span></span><br><span class="line">                    sum = sum + <span class="built_in">abs</span>(points[i][<span class="number">1</span>] - points[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    sum = sum + <span class="built_in">abs</span>(points[i][<span class="number">0</span>] - points[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h2><p>仔细观察代码1发现，相邻两点的访问时间等于横纵坐标差值的绝对值较大的一个。</p>
<h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minTimeToVisitAllPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, len = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i)&#123;</span><br><span class="line">            sum = sum + <span class="built_in">max</span>(<span class="built_in">abs</span>(points[i][<span class="number">0</span>] - points[i - <span class="number">1</span>][<span class="number">0</span>]), <span class="built_in">abs</span>(points[i][<span class="number">1</span>] - points[i - <span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="1267-统计参与通信的服务器"><a href="#1267-统计参与通信的服务器" class="headerlink" title="1267. 统计参与通信的服务器"></a><a href="https://leetcode-cn.com/problems/count-servers-that-communicate/">1267. 统计参与通信的服务器</a></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>这里有一幅服务器分布图，服务器的位置标识在 m * n 的整数矩阵网格 grid 中，1 表示单元格上有服务器，0 表示没有。 如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。 请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。 示例 1： <img src="/images/2019/11/a96d7db2b101e8527d55bda773645f97.png" alt=""> 输入：grid = [[1,0],[0,1]] 输出：0 解释：没有一台服务器能与其他服务器进行通信。 示例 2： <img src="/images/2019/11/fd62279ac67a882b4852014db8fb414d.png" alt=""> 输入：grid = [[1,0],[1,1]] 输出：3 解释：所有这些服务器都至少可以与一台别的服务器进行通信。 示例 3： <img src="/images/2019/11/870f2bf7033033c201c65bf6f25d2753.png" alt=""> 输入：grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]] 输出：4 解释：第一行的两台服务器互相通信，第三列的两台服务器互相通信，但右下角的服务器无法与其他服务器通信。   提示： m == grid.length n == grid[i].length 1 &lt;= m &lt;= 250 1 &lt;= n &lt;= 250 grid[i][j] == 0 or 1</p>
<h2 id="题解1-1"><a href="#题解1-1" class="headerlink" title="题解1"></a>题解1</h2><p>判断每台服务器所在行或者列除了它自己外，有没有其它的服务器，有的话表示可以通信，计数+1。否则，无法通信。</p>
<h2 id="代码1-1"><a href="#代码1-1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countServers</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rows = grid.<span class="built_in">size</span>(), cols = grid[<span class="number">0</span>].<span class="built_in">size</span>(), cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j])&#123;</span><br><span class="line">                    <span class="comment">//行</span></span><br><span class="line">                    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; cols; ++k)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(k != j &amp;&amp; grid[i][k])&#123;</span><br><span class="line">                            flag = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//列</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; rows; ++k)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(k != i &amp;&amp; grid[k][j])&#123;</span><br><span class="line">                            flag = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                        ++cnt;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="1268-搜索推荐系统"><a href="#1268-搜索推荐系统" class="headerlink" title="1268. 搜索推荐系统"></a><a href="https://leetcode-cn.com/problems/search-suggestions-system/">1268. 搜索推荐系统</a></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个产品数组 products 和一个字符串 searchWord ，products  数组中每个产品都是一个字符串。 请你设计一个推荐系统，在依次输入单词 searchWord 的每一个字母后，推荐 products 数组中前缀与 searchWord 相同的最多三个产品。如果前缀相同的可推荐产品超过三个，请按字典序返回最小的三个。 请你以二维列表的形式，返回在输入 searchWord 每个字母后相应的推荐产品的列表。 示例 1： 输入：products = [“mobile”,”mouse”,”moneypot”,”monitor”,”mousepad”], searchWord = “mouse” 输出：[ [“mobile”,”moneypot”,”monitor”], [“mobile”,”moneypot”,”monitor”], [“mouse”,”mousepad”], [“mouse”,”mousepad”], [“mouse”,”mousepad”] ] 解释：按字典序排序后的产品列表是 [“mobile”,”moneypot”,”monitor”,”mouse”,”mousepad”] 输入 m 和 mo，由于所有产品的前缀都相同，所以系统返回字典序最小的三个产品 [“mobile”,”moneypot”,”monitor”] 输入 mou， mous 和 mouse 后系统都返回 [“mouse”,”mousepad”] 示例 2： 输入：products = [“havana”], searchWord = “havana” 输出：[[“havana”],[“havana”],[“havana”],[“havana”],[“havana”],[“havana”]] 示例 3： 输入：products = [“bags”,”baggage”,”banner”,”box”,”cloths”], searchWord = “bags” 输出：[[“baggage”,”bags”,”banner”],[“baggage”,”bags”,”banner”],[“baggage”,”bags”],[“bags”]] 示例 4： 输入：products = [“havana”], searchWord = “tatiana” 输出：[[],[],[],[],[],[],[]] 提示： 1 &lt;= products.length &lt;= 1000 1 &lt;= products[i].length &lt;= 2 * 10^4 products[i] 中所有的字符都是小写英文字母。 1 &lt;= searchWord.length &lt;= 1000 searchWord 中所有字符都是小写英文字母。</p>
<h2 id="题解1-2"><a href="#题解1-2" class="headerlink" title="题解1"></a>题解1</h2><p>首先需将products中的字符串按照字典序排序，然后依次寻找seachWord每个字母后与之匹配的product（最多三个）。</p>
<h2 id="代码1-2"><a href="#代码1-2" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">suggestedProducts</span>(vector&lt;string&gt;&amp; prod, string searchWord) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(prod.<span class="built_in">begin</span>(), prod.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt;res;</span><br><span class="line">        vector&lt;string&gt;tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; searchWord.<span class="built_in">size</span>(); ++i)&#123;<span class="comment">//以每个字母前的子串进行匹配</span></span><br><span class="line">            string s = searchWord.<span class="built_in">substr</span>(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">            tmp.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; prod.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt &lt; <span class="number">3</span> &amp;&amp; prod[j].<span class="built_in">substr</span>(<span class="number">0</span>, i + <span class="number">1</span>) == s)&#123;<span class="comment">//匹配且最多只能有三个</span></span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(prod[j]);</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="1269-停在原地的方案数"><a href="#1269-停在原地的方案数" class="headerlink" title="1269. 停在原地的方案数"></a><a href="https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/">1269. 停在原地的方案数</a></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。 每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。 给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。 由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。  示例 1： 输入：steps = 3, arrLen = 2 输出：4 解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。 向右，向左，不动 不动，向右，向左 向右，不动，向左 不动，不动，不动 示例  2： 输入：steps = 2, arrLen = 4 输出：2 解释：2 步后，总共有 2 种不同的方法可以停在索引 0 处。 向右，向左 不动，不动 示例 3： 输入：steps = 4, arrLen = 2 输出：8 提示： 1 &lt;= steps &lt;= 500 1 &lt;= arrLen &lt;= 10^6</p>
<h2 id="题解1-3"><a href="#题解1-3" class="headerlink" title="题解1"></a>题解1</h2><p>如果进行dfs搜索，会超时。我们进行记忆化搜索，将已经计算过的存储下来，避免重复遍历与计算， 大大减少时间。</p>
<h2 id="代码1-3"><a href="#代码1-3" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MOD (1000000007)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">记忆化搜索</span></span><br><span class="line"><span class="comment">dp[j][i] = dp[j - 1][i - 1]  + dp[j - 1][j] + dp[j - 1][i + 1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">map&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt;mark;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> steps, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(steps == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> pos == <span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mark.<span class="built_in">find</span>(<span class="built_in">make_pair</span>(pos, steps - <span class="number">1</span>))!= mark.<span class="built_in">end</span>())&#123;</span><br><span class="line">        mark[<span class="built_in">make_pair</span>(pos, steps)] =  mark[<span class="built_in">make_pair</span>(pos, steps - <span class="number">1</span>)] % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">       mark[<span class="built_in">make_pair</span>(pos, steps)] = <span class="built_in">dfs</span>(pos, steps - <span class="number">1</span>, n) % MOD;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">if</span>(pos - <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;<span class="comment">//左移</span></span><br><span class="line">        <span class="keyword">if</span>(mark.<span class="built_in">find</span>(<span class="built_in">make_pair</span>(pos - <span class="number">1</span>, steps - <span class="number">1</span>)) != mark.<span class="built_in">end</span>())&#123;</span><br><span class="line">            mark[<span class="built_in">make_pair</span>(pos, steps)] = (mark[<span class="built_in">make_pair</span>(pos, steps)] + mark[<span class="built_in">make_pair</span>(pos - <span class="number">1</span>, steps - <span class="number">1</span>)]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            mark[<span class="built_in">make_pair</span>(pos, steps)] = (mark[<span class="built_in">make_pair</span>(pos, steps)] + <span class="built_in">dfs</span>(pos - <span class="number">1</span>, steps - <span class="number">1</span>, n)) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pos + <span class="number">1</span> &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mark.<span class="built_in">find</span>(<span class="built_in">make_pair</span>(pos + <span class="number">1</span>, steps - <span class="number">1</span>)) != mark.<span class="built_in">end</span>())&#123;</span><br><span class="line">            mark[<span class="built_in">make_pair</span>(pos, steps)] = (mark[<span class="built_in">make_pair</span>(pos, steps)] + mark[<span class="built_in">make_pair</span>(pos + <span class="number">1</span>, steps - <span class="number">1</span>)]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            mark[<span class="built_in">make_pair</span>(pos, steps)] = (mark[<span class="built_in">make_pair</span>(pos, steps)] + <span class="built_in">dfs</span>(pos + <span class="number">1</span>, steps - <span class="number">1</span>, n)) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mark[<span class="built_in">make_pair</span>(pos, steps)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numWays</span><span class="params">(<span class="type">int</span> steps, <span class="type">int</span> arrLen)</span> </span>&#123;</span><br><span class="line">        mark.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, steps, arrLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="题解2-1"><a href="#题解2-1" class="headerlink" title="题解2"></a>题解2</h2><p>动态规划 $dp(pos, steps) = dp(pos- 1, steps - 1) + dp(pos. steps - 1) + dp(pos + 1, steps - 1)$ 其中dp(pos, steps)表示从0出发，最后经过steps步回到pos的方案数，而对于每一步有三种方案：向左移，停在原地，向右移。由此得到转移方程。</p>
<h2 id="代码2-1"><a href="#代码2-1" class="headerlink" title="代码2"></a>代码2</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MOD (1000000007)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numWays</span><span class="params">(<span class="type">int</span> steps, <span class="type">int</span> arrLen)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(<span class="number">505</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">505</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= steps; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="built_in">min</span>(arrLen - <span class="number">1</span>, i); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[j][i] = (dp[j][i] + dp[j - <span class="number">1</span>][i - <span class="number">1</span>]) % MOD; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j + <span class="number">1</span> &lt;= i)&#123;</span><br><span class="line">                    dp[j][i] = (dp[j][i] + dp[j + <span class="number">1</span>][i - <span class="number">1</span>]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[j][i] = (dp[j][i] + dp[j][i - <span class="number">1</span>]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][steps];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode2019第 168 场周赛</title>
    <url>/2019/12/22/leetcode2019%E7%AC%AC-168-%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="5291-统计位数为偶数的数字"><a href="#5291-统计位数为偶数的数字" class="headerlink" title="5291. 统计位数为偶数的数字"></a><a href="https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits/">5291. 统计位数为偶数的数字</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 nums，请你返回其中位数为 偶数 的数字的个数。 示例 1： 输入：nums = [12,345,2,6,7896] 输出：2 解释： 12 是 2 位数字（位数为偶数）  345 是 3 位数字（位数为奇数）   2 是 1 位数字（位数为奇数）  6 是 1 位数字 位数为奇数）  7896 是 4 位数字（位数为偶数）   因此只有 12 和 7896 是位数为偶数的数字 示例 2： 输入：nums = [555,901,482,1771] 输出：1 解释： 只有 1771 是位数为偶数的数字。 提示： 1 &lt;= nums.length &lt;= 500 1 &lt;= nums[i] &lt;= 10^5</p>
<h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>我用<code>to_string</code>将数字先转成字符串，然后判断字符串的长度是否为偶数。</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//to_string</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">to_string</span>(num).<span class="built_in">size</span>()% <span class="number">2</span> == <span class="number">0</span>)&#123;<span class="comment">//判断num对应的字符串的长度是否为偶数</span></span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="5292-划分数组为连续数字的集合"><a href="#5292-划分数组为连续数字的集合" class="headerlink" title="5292. 划分数组为连续数字的集合"></a><a href="https://leetcode-cn.com/problems/divide-array-in-sets-of-k-consecutive-numbers/">5292. 划分数组为连续数字的集合</a></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 nums 和一个正整数 k，请你判断是否可以把这个数组划分成一些由 k 个连续数字组成的集合。 如果可以，请返回 True；否则，返回 False。 示例 1： 输入：nums = [1,2,3,3,4,4,5,6], k = 4 输出：true 解释：数组可以分成 [1,2,3,4] 和 [3,4,5,6]。 示例 2： 输入：nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3 输出：true 解释：数组可以分成 [1,2,3] , [2,3,4] , [3,4,5] 和 [9,10,11]。 示例 3： 输入：nums = [3,3,2,2,1,1], k = 3 输出：true 示例 4： 输入：nums = [1,2,3,4], k = 3 输出：false 解释：数组不能分成几个大小为 3 的子数组。  提示： 1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i] &lt;= 10^9 1 &lt;= k &lt;= nums.length</p>
<h2 id="题解1-1"><a href="#题解1-1" class="headerlink" title="题解1"></a>题解1</h2><p>先用map统计每个数字出现的次数。然而遍历map(key已自动从小到大排列)，当发现某个数的个数cnt不为0，则连续k个数字(含当前数)都减去cnt，如果出现负数，则表示不能划分。 最后再遍历一次map,检查是否每一个数的个数都为0。（这步其实不需要）</p>
<h2 id="代码1-1"><a href="#代码1-1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPossibleDivide</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;myMap;</span><br><span class="line">        <span class="keyword">if</span>(len % k != <span class="number">0</span>)&#123;<span class="comment">//数字的个数不能将每组都划分成k个</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)&#123;<span class="comment">//统计每个数字出现的次数</span></span><br><span class="line">            <span class="keyword">if</span>(myMap.<span class="built_in">find</span>(num) == myMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">                myMap[num] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ++myMap[num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = myMap.<span class="built_in">begin</span>(); iter != myMap.<span class="built_in">end</span>(); ++iter)&#123;<span class="comment">//遍历map</span></span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;second != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> num = iter-&gt;first;</span><br><span class="line">                <span class="type">int</span> cnt = myMap[num];</span><br><span class="line">                myMap[num] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = num + <span class="number">1</span>; i &lt; num + k; ++i)&#123;<span class="comment">//分组，一个数不为0，连续k个数字一组，个数不足表示不能划分</span></span><br><span class="line">                    <span class="keyword">if</span>(myMap[i] &lt; cnt)&#123;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        myMap[i] = myMap[i] - cnt;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*这步其实不需要</span></span><br><span class="line"><span class="comment">        for(auto iter = myMap.begin(); iter != myMap.end(); ++iter)&#123;</span></span><br><span class="line"><span class="comment">            if(iter-&gt;second != 0)&#123;//表示有多余数字</span></span><br><span class="line"><span class="comment">                flag = false;</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="5293-子串的最大出现次数"><a href="#5293-子串的最大出现次数" class="headerlink" title="5293. 子串的最大出现次数"></a><a href="https://leetcode-cn.com/problems/maximum-number-of-occurrences-of-a-substring/">5293. 子串的最大出现次数</a></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s ，请你返回满足以下条件且出现次数最大的 任意 子串的出现次数： 子串中不同字母的数目必须小于等于 maxLetters 。 子串的长度必须大于等于 minSize 且小于等于 maxSize 。 示例 1： 输入：s = “aababcaab”, maxLetters = 2, minSize = 3, maxSize = 4 输出：2 解释：子串 “aab” 在原字符串中出现了 2 次。 它满足所有的要求：2 个不同的字母，长度为 3 （在 minSize 和 maxSize 范围内）。 示例 2： 输入：s = “aaaa”, maxLetters = 1, minSize = 3, maxSize = 3 输出：2 解释：子串 “aaa” 在原字符串中出现了 2 次，且它们有重叠部分。 示例 3： 输入：s = “aabcabcab”, maxLetters = 2, minSize = 2, maxSize = 3 输出：3 示例 4： 输入：s = “abcde”, maxLetters = 2, minSize = 3, maxSize = 3 输出：0   提示： 1 &lt;= s.length &lt;= 10^5 1 &lt;= maxLetters &lt;= 26 1 &lt;= minSize &lt;= maxSize &lt;= min(26, s.length) s 只包含小写英文字母。</p>
<h2 id="题解1-2"><a href="#题解1-2" class="headerlink" title="题解1"></a>题解1</h2><h2 id="代码1-2"><a href="#代码1-2" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxFreq</span><span class="params">(string s, <span class="type">int</span> maxLetters, <span class="type">int</span> minSize, <span class="type">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        map&lt;string, <span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="type">bool</span> mark[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i + minSize - <span class="number">1</span> &lt; len)&#123;</span><br><span class="line">                <span class="built_in">memset</span>(mark, <span class="literal">false</span>, <span class="built_in">sizeof</span>(mark));</span><br><span class="line">                <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; i + minSize; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!mark[s[j] - <span class="string">&#x27;a&#x27;</span>])&#123;</span><br><span class="line">                        ++cnt;</span><br><span class="line">                        mark[s[j] - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cnt &lt;= maxLetters)&#123;</span><br><span class="line">                    res[s.<span class="built_in">substr</span>(i, minSize)]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;iter:res)&#123;</span><br><span class="line">            maxLen = <span class="built_in">max</span>(maxLen, iter.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="5294-你能从盒子里获得的最大糖果数"><a href="#5294-你能从盒子里获得的最大糖果数" class="headerlink" title="5294. 你能从盒子里获得的最大糖果数"></a><a href="https://leetcode-cn.com/problems/maximum-candies-you-can-get-from-boxes/">5294. 你能从盒子里获得的最大糖果数</a></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你 n 个盒子，每个盒子的格式为 [status, candies, keys, containedBoxes] ，其中： 状态字 status[i]：整数，如果 box[i] 是开的，那么是 1 ，否则是 0 。 糖果数 candies[i]: 整数，表示 box[i] 中糖果的数目。 钥匙 keys[i]：数组，表示你打开 box[i] 后，可以得到一些盒子的钥匙，每个元素分别为该钥匙对应盒子的下标。 内含的盒子 containedBoxes[i]：整数，表示放在 box[i] 里的盒子所对应的下标。 给你一个 initialBoxes 数组，表示你现在得到的盒子，你可以获得里面的糖果，也可以用盒子里的钥匙打开新的盒子，还可以继续探索从这个盒子里找到的其他盒子。 请你按照上述规则，返回可以获得糖果的 最大数目 。 示例 1： 输入：status = [1,0,1,0], candies = [7,5,4,100], keys = [[],[],[1],[]], containedBoxes = [[1,2],[3],[],[]], initialBoxes = [0] 输出：16 解释： 一开始你有盒子 0 。你将获得它里面的 7 个糖果和盒子 1 和 2。 盒子 1 目前状态是关闭的，而且你还没有对应它的钥匙。所以你将会打开盒子 2 ，并得到里面的 4 个糖果和盒子 1 的钥匙。 在盒子 1 中，你会获得 5 个糖果和盒子 3 ，但是你没法获得盒子 3 的钥匙所以盒子 3 会保持关闭状态。 你总共可以获得的糖果数目 = 7 + 4 + 5 = 16 个。 示例 2： 输入：status = [1,0,0,0,0,0], candies = [1,1,1,1,1,1], keys = [[1,2,3,4,5],[],[],[],[],[]], containedBoxes = [[1,2,3,4,5],[],[],[],[],[]], initialBoxes = [0] 输出：6 解释： 你一开始拥有盒子 0 。打开它你可以找到盒子 1,2,3,4,5 和它们对应的钥匙。 打开这些盒子，你将获得所有盒子的糖果，所以总糖果数为 6 个。 示例 3： 输入：status = [1,1,1], candies = [100,1,100], keys = [[],[0,2],[]], containedBoxes = [[],[],[]], initialBoxes = [1] 输出：1 示例 4： 输入：status = [1], candies = [100], keys = [[]], containedBoxes = [[]], initialBoxes = [] 输出：0 示例 5： 输入：status = [1,1,1], candies = [2,3,2], keys = [[],[],[]], containedBoxes = [[],[],[]], initialBoxes = [2,1,0] 输出：7  提示： 1 &lt;= status.length &lt;= 1000 status.length == candies.length == keys.length == containedBoxes.length == n status[i] 要么是 0 要么是 1 。 1 &lt;= candies[i] &lt;= 1000 0 &lt;= keys[i].length &lt;= status.length 0 &lt;= keys[i][j] &lt; status.length keys[i] 中的值都是互不相同的。 0 &lt;= containedBoxes[i].length &lt;= status.length 0 &lt;= containedBoxes[i][j] &lt; status.length containedBoxes[i] 中的值都是互不相同的。 每个盒子最多被一个盒子包含。 0 &lt;= initialBoxes.length &lt;= status.length 0 &lt;= initialBoxes[i] &lt; status.length</p>
<h2 id="题解1-3"><a href="#题解1-3" class="headerlink" title="题解1"></a>题解1</h2><p>这个题很好理解，第一反应是个递归，写完才发现爆栈了。然后又把程序改成了循环判断boxs(拥有的盒子)是否存在能够打开的，打开后，如果有新钥匙，则将对应盒子的状态修改为1，有新盒子，则添加到boxs中。如此下去，直到boxs中剩下的盒子都已打开或者不存在能够打开的盒子为止。</p>
<h2 id="代码1-3"><a href="#代码1-3" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;boxs;</span><br><span class="line"><span class="type">bool</span> mark[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxCandies</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; status, vector&lt;<span class="type">int</span>&gt;&amp; candies, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; keys, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; contains, vector&lt;<span class="type">int</span>&gt;&amp; init)</span> </span>&#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        boxs.<span class="built_in">clear</span>();<span class="comment">//拥有的盒子</span></span><br><span class="line">        <span class="built_in">memset</span>(mark, <span class="literal">false</span>, <span class="built_in">sizeof</span>(mark));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; init.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            boxs.<span class="built_in">insert</span>(init[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(boxs.<span class="built_in">size</span>() != <span class="number">0</span>)&#123;<span class="comment">//一直循环</span></span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> iter = boxs.<span class="built_in">begin</span>(); iter != boxs.<span class="built_in">end</span>(); ++iter)&#123;</span><br><span class="line">                <span class="type">int</span> idx = *iter;</span><br><span class="line">                <span class="keyword">if</span>(!mark[idx] &amp;&amp; status[idx])&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    mark[idx] = <span class="literal">true</span>;</span><br><span class="line">                    sum += candies[idx];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; keys[idx].<span class="built_in">size</span>(); ++j)&#123;<span class="comment">//更新钥匙，也就是使对应盒子的status值为1。</span></span><br><span class="line">                        status[keys[idx][j]] = <span class="number">1</span>; </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; contains[idx].<span class="built_in">size</span>(); ++j)&#123;<span class="comment">//更新拥有的盒子</span></span><br><span class="line">                        boxs.<span class="built_in">insert</span>(contains[idx][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123;<span class="comment">//flag为true表示盒子都已打开或不存在能够打开的盒子</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode2019第169场周赛</title>
    <url>/2020/01/09/leetcode2019%E7%AC%AC169%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="1304-和为零的N个唯一整数"><a href="#1304-和为零的N个唯一整数" class="headerlink" title="1304. 和为零的N个唯一整数"></a><a href="https://leetcode-cn.com/problems/find-n-unique-integers-sum-up-to-zero/">1304. 和为零的N个唯一整数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数 n，请你返回 任意 一个由 n 个 各不相同 的整数组成的数组，并且这 n 个数相加和为 0 。  示例 1： 输入：n = 5 输出：[-7,-1,1,3,4] 解释：这些数组也是正确的 [-5,-1,1,2,3]，[-3,-1,2,-2,4]。 示例 2： 输入：n = 3 输出：[-1,0,1] 示例 3： 输入：n = 1 输出：[0]  提示： 1 &lt;= n &lt;= 1000</p>
<h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>产生n个不同的数字和为0的方式有很多种，可以对称产生0左右两边的数。具体 如果$n = 2 <em> m$，则结果为：$-m, -(m - 1), \dots, -1, 1, \dots, m - 1, m$。 如果$n = 2 </em> m + 1$，则结果为：$-m, -(m - 1), \dots, -1, 0，1, \dots, m - 1, m$。</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sumZero</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n &gt;&gt; <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            res.<span class="built_in">push_back</span>(-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="1305-两棵二叉搜索树中的所有元素"><a href="#1305-两棵二叉搜索树中的所有元素" class="headerlink" title="1305. 两棵二叉搜索树中的所有元素"></a><a href="https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/">1305. 两棵二叉搜索树中的所有元素</a></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你 root1 和 root2 这两棵二叉搜索树。 请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。. 示例 1： <img src="/images/2020/01/9930a903b02a23f9c9fb6e1122093fda.png" alt=""> 输入：root1 = [2,1,4], root2 = [1,0,3] 输出：[0,1,1,2,3,4] 示例 2： 输入：root1 = [0,-10,10], root2 = [5,1,7,0,2] 输出：[-10,0,0,1,2,5,7,10] 示例 3： 输入：root1 = [], root2 = [5,1,7,0,2] 输出：[0,1,2,5,7] 示例 4： 输入：root1 = [0,-10,10], root2 = [] 输出：[-10,0,10] 示例 5： <img src="/images/2020/01/060ed4aaa3a6736c111b7224a9663f43.png" alt=""> 输入：root1 = [1,null,8], root2 = [8,1] 输出：[1,1,8,8] 提示： 每棵树最多有 5000 个节点。 每个节点的值在 [-10^5, 10^5] 之间。</p>
<h2 id="题解1-1"><a href="#题解1-1" class="headerlink" title="题解1"></a>题解1</h2><p>对于二叉搜索树，中序遍历可以得到有序的序列。分别对两棵二叉搜索树中序遍历，然后再对结果进行归并排序。 但比赛为了求速度，直接将结果用sort排序。</p>
<h2 id="代码1-1"><a href="#代码1-1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;left, res);</span><br><span class="line">    res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;right, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getAllElements</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res1;</span><br><span class="line">        <span class="built_in">inorder</span>(root1, res1);<span class="comment">//中序遍历</span></span><br><span class="line">        <span class="built_in">inorder</span>(root2, res1);<span class="comment">//中序遍历</span></span><br><span class="line">        <span class="built_in">sort</span>(res1.<span class="built_in">begin</span>(), res1.<span class="built_in">end</span>());<span class="comment">//这里可修改为归并排序 </span></span><br><span class="line">        <span class="keyword">return</span> res1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="1306-跳跃游戏-III"><a href="#1306-跳跃游戏-III" class="headerlink" title="1306. 跳跃游戏 III"></a><a href="https://leetcode-cn.com/problems/jump-game-iii/">1306. 跳跃游戏 III</a></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>这里有一个非负整数数组 arr，你最开始位于该数组的起始下标 start 处。当你位于下标 i 处时，你可以跳到 i + arr[i] 或者 i - arr[i]。 请你判断自己是否能够跳到对应元素值为 0 的 任意 下标处。 注意，不管是什么情况下，你都无法跳到数组之外。 示例 1： 输入：arr = [4,2,3,0,3,1,2], start = 5 输出：true 解释： 到达值为 0 的下标 3 有以下可能方案： 下标 5 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3 下标 5 -&gt; 下标 6 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3 示例 2： 输入：arr = [4,2,3,0,3,1,2], start = 0 输出：true 解释： 到达值为 0 的下标 3 有以下可能方案： 下标 0 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3 示例 3 输入：arr = [3,0,2,1,2], start = 2 输出：false 解释：无法到达值为 0 的下标 1 处。 提示： 1 &lt;= arr.length &lt;= 5 * 10^4 0 &lt;= arr[i] &lt; arr.length 0 &lt;= start &lt; arr.length</p>
<h2 id="题解1-2"><a href="#题解1-2" class="headerlink" title="题解1"></a>题解1</h2><p>BFS，判断能否从起始下标到达值为0的下标位置</p>
<h2 id="代码1-2"><a href="#代码1-2" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canReach</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;target;</span><br><span class="line">        <span class="type">int</span> len = arr.<span class="built_in">size</span>(), frt;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>, res = <span class="literal">false</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">mark</span>(len, <span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">mark1</span>(len, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i)&#123;<span class="comment">//将值为0的数字的下标进行标记</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                mark[i] = <span class="number">1</span>;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;<span class="comment">//不存在值为0的数字</span></span><br><span class="line">            res = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//BFS</span></span><br><span class="line">            queue&lt;<span class="type">int</span>&gt;que;</span><br><span class="line">            que.<span class="built_in">push</span>(start);</span><br><span class="line">            mark1[start] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                frt = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(mark[frt])&#123;<span class="comment">//移动值为0的位置，直接break</span></span><br><span class="line">                    res = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(frt + arr[frt] &lt; len &amp;&amp; !mark1[frt + arr[frt]])&#123;<span class="comment">//向前移</span></span><br><span class="line">                    que.<span class="built_in">push</span>(frt + arr[frt]);</span><br><span class="line">                    mark1[frt + arr[frt]] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(frt - arr[frt] &gt;= <span class="number">0</span> &amp;&amp; !mark1[frt - arr[frt]])&#123;<span class="comment">//向后移</span></span><br><span class="line">                    que.<span class="built_in">push</span>(frt - arr[frt]);</span><br><span class="line">                    mark1[frt - arr[frt]] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="1307-口算难题"><a href="#1307-口算难题" class="headerlink" title="1307. 口算难题"></a><a href="https://leetcode-cn.com/problems/verbal-arithmetic-puzzle/">1307. 口算难题</a></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个方程，左边用 words 表示，右边用 result 表示。 你需要根据以下规则检查方程是否可解： 每个字符都会被解码成一位数字（0 - 9）。 每对不同的字符必须映射到不同的数字。 每个 words[i] 和 result 都会被解码成一个没有前导零的数字。 左侧数字之和（words）等于右侧数字（result）。  如果方程可解，返回 True，否则返回 False。 示例 1： 输入：words = [“SEND”,”MORE”], result = “MONEY” 输出：true 解释：映射 ‘S’-&gt; 9, ‘E’-&gt;5, ‘N’-&gt;6, ‘D’-&gt;7, ‘M’-&gt;1, ‘O’-&gt;0, ‘R’-&gt;8, ‘Y’-&gt;’2’ 所以 “SEND” + “MORE” = “MONEY” , 9567 + 1085 = 10652 示例 2： 输入：words = [“SIX”,”SEVEN”,”SEVEN”], result = “TWENTY” 输出：true 解释：映射 ‘S’-&gt; 6, ‘I’-&gt;5, ‘X’-&gt;0, ‘E’-&gt;8, ‘V’-&gt;7, ‘N’-&gt;2, ‘T’-&gt;1, ‘W’-&gt;’3’, ‘Y’-&gt;4 所以 “SIX” + “SEVEN” + “SEVEN” = “TWENTY” , 650 + 68782 + 68782 = 138214 示例 3： 输入：words = [“THIS”,”IS”,”TOO”], result = “FUNNY” 输出：true 示例 4： 输入：words = [“LEET”,”CODE”], result = “POINT” 输出：false 提示： 2 &lt;= words.length &lt;= 5 1 &lt;= words[i].length, results.length &lt;= 7 words[i], result 只含有大写英文字母 表达式中使用的不同字符数最大为 10</p>
<h2 id="题解1-3"><a href="#题解1-3" class="headerlink" title="题解1"></a>题解1</h2><p>因为表达式中使用的不同字符数最大为10，字符的取值0-9（值不能相同）最多为$10!$种情况。思路如下： 首先将不重复的字符统计出来，然后用next_permutation产生不同的取值，判断是否符合情况。 这种暴力方式会超时，因为next_permutation产生取值的时间需要o(n)时间，并且包含重复的情况。</p>
<h2 id="代码1-3"><a href="#代码1-3" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//超时</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deal</span><span class="params">(vector&lt;string&gt;&amp; words, string&amp; result, unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&amp; myMap)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(words[i].<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; myMap[words[i][<span class="number">0</span>]] == <span class="number">0</span>)&#123;<span class="comment">//前导0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; myMap[result[<span class="number">0</span>]] == <span class="number">0</span>)&#123;<span class="comment">//前导0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> lSum = <span class="number">0</span>, rSum = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> word:words)&#123;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch:word)&#123;</span><br><span class="line">            num = num * <span class="number">10</span> + myMap[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        lSum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ch:result)&#123;</span><br><span class="line">        rSum = rSum * <span class="number">10</span> + myMap[ch];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lSum == rSum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSolvable</span><span class="params">(vector&lt;string&gt;&amp; words, string result)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;myMap;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="type">int</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word:words)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> ch:word)&#123;</span><br><span class="line">                <span class="keyword">if</span>(myMap.<span class="built_in">find</span>(ch) == myMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    str.<span class="built_in">push_back</span>(ch);</span><br><span class="line">                    myMap[ch] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        len = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">                myMap[str[i]] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">deal</span>(words, result, myMap))&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(arr, arr + <span class="number">10</span>));</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h2><p>用dfs来代替next_permutation，不会产生重复的情况。加入前导0的标记并将map换成数组。</p>
<h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">myMap</span>(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt;<span class="built_in">mark</span>(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">string str;</span><br><span class="line"><span class="type">bool</span> res = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deal</span><span class="params">(vector&lt;string&gt;&amp; words, string&amp; result)</span></span>&#123;<span class="comment">//判断相加后是否相等</span></span><br><span class="line">    <span class="type">int</span> lSum = <span class="number">0</span>, rSum = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> word:words)&#123;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch:word)&#123;</span><br><span class="line">            num = num * <span class="number">10</span> + myMap[ch - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        lSum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ch:result)&#123;</span><br><span class="line">        rSum = rSum * <span class="number">10</span> + myMap[ch - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lSum == rSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;string&gt;&amp; words, string&amp; result, <span class="type">int</span> pos, <span class="type">int</span> used)</span></span>&#123;<span class="comment">//递归暴力</span></span><br><span class="line">    <span class="keyword">if</span>(res)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pos == str.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">deal</span>(words, result))&#123;</span><br><span class="line">            res = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>((mark[str[pos] - <span class="string">&#x27;A&#x27;</span>] &amp;&amp; i == <span class="number">0</span>)  used &gt;&gt; i &amp; <span class="number">1</span>) <span class="keyword">continue</span>;<span class="comment">//前导0或者数字重复</span></span><br><span class="line">        myMap[str[pos] - <span class="string">&#x27;A&#x27;</span>] = i;</span><br><span class="line">        <span class="built_in">dfs</span>(words, result, pos + <span class="number">1</span>, used  <span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSolvable</span><span class="params">(vector&lt;string&gt;&amp; words, string result)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        myMap.<span class="built_in">clear</span>();</span><br><span class="line">        str.<span class="built_in">clear</span>();</span><br><span class="line">        res = <span class="literal">false</span>;</span><br><span class="line">        mark.<span class="built_in">assign</span>(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        myMap.<span class="built_in">assign</span>(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word:words)&#123;<span class="comment">//统计字符的个数</span></span><br><span class="line">            mark[word[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> ch:word)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!myMap[ch - <span class="string">&#x27;A&#x27;</span>])&#123;</span><br><span class="line">                    str.<span class="built_in">push_back</span>(ch);</span><br><span class="line">                    myMap[ch - <span class="string">&#x27;A&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mark[result[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch:result)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!myMap[ch - <span class="string">&#x27;A&#x27;</span>])&#123;</span><br><span class="line">                str.<span class="built_in">push_back</span>(ch);</span><br><span class="line">                myMap[ch - <span class="string">&#x27;A&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        len = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(words, result, <span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="题解3"><a href="#题解3" class="headerlink" title="题解3"></a>题解3</h2><p>参照<a href="https://leetcode-cn.com/problems/verbal-arithmetic-puzzle/solution/he-bing-tong-lei-xiang-dfsc-100-by-aleix/">圈子</a></p>
<h2 id="代码3"><a href="#代码3" class="headerlink" title="代码3"></a>代码3</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">char</span>&gt; h;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; base;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">coe</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">not_zero</span><span class="params">(<span class="number">26</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span> <span class="params">(<span class="type">int</span> pos,<span class="type">int</span> used, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos == h.<span class="built_in">size</span>()) <span class="keyword">return</span> sum == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(used&gt;&gt;i &amp; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; not_zero[h[pos]-<span class="string">&#x27;A&#x27;</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(pos+<span class="number">1</span>,used  <span class="number">1</span>&lt;&lt;i, sum+i*coe[h[pos]-<span class="string">&#x27;A&#x27;</span>])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSolvable</span><span class="params">(vector&lt;string&gt;&amp; words, string result)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        h.<span class="built_in">clear</span>();</span><br><span class="line">        base.<span class="built_in">clear</span>();</span><br><span class="line">        coe.<span class="built_in">assign</span>(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        not_zero.<span class="built_in">assign</span>(<span class="number">26</span>, <span class="literal">false</span>);</span><br><span class="line">        words.<span class="built_in">push_back</span>(result);</span><br><span class="line">        base.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">8</span> ; i++) base.<span class="built_in">push_back</span>(base.<span class="built_in">back</span>()*<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt; words.<span class="built_in">size</span>() ; j++) &#123;</span><br><span class="line">            string x = words[j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; x.<span class="built_in">size</span>() ; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) not_zero[x[i]-<span class="string">&#x27;A&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">                h.<span class="built_in">push_back</span>(x[i]);</span><br><span class="line">                <span class="type">int</span> flag = j==words.<span class="built_in">size</span>()<span class="number">-1</span>?<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">                coe[x[i]-<span class="string">&#x27;A&#x27;</span>] += flag * base[x.<span class="built_in">size</span>()<span class="number">-1</span>-i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(h.<span class="built_in">begin</span>(),h.<span class="built_in">end</span>());</span><br><span class="line">        h.<span class="built_in">erase</span>(<span class="built_in">unique</span>(h.<span class="built_in">begin</span>(),h.<span class="built_in">end</span>()),h.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode2020第170场周赛</title>
    <url>/2020/01/06/leetcode2020%E7%AC%AC170%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="5303-解码字母到整数映射"><a href="#5303-解码字母到整数映射" class="headerlink" title="5303. 解码字母到整数映射"></a><a href="https://leetcode-cn.com/problems/decrypt-string-from-alphabet-to-integer-mapping/">5303. 解码字母到整数映射</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s，它由数字（’0’ - ‘9’）和 ‘#’ 组成。我们希望按下述规则将 s 映射为一些小写英文字符： 字符（’a’ - ‘i’）分别用（’1’ - ‘9’）表示。 字符（’j’ - ‘z’）分别用（’10#’ - ‘26#’）表示。  返回映射之后形成的新字符串。 题目数据保证映射始终唯一。 示例 1： 输入：s = “10#11#12” 输出：”jkab” 解释：”j” -&gt; “10#” , “k” -&gt; “11#” , “a” -&gt; “1” , “b” -&gt; “2”. 示例 2： 输入：s = “1326#” 输出：”acz” 示例 3： 输入：s = “25#” 输出：”y” 示例 4： 输入：s = “12345678910#11#12#13#14#15#16#17#18#19#20#21#22#23#24#25#26#” 输出：”abcdefghijklmnopqrstuvwxyz”   提示： 1 &lt;= s.length &lt;= 1000 s[i] 只包含数字（’0’-‘9’）和 ‘#’ 字符。 s 是映射始终存在的有效字符串。</p>
<h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>a-i对应的是1-9，即一个字母对应一个字符；j-z对应的是10#-26#即一个字母对应三个字符，且以#结尾。现在我们反向遍历字符串，遇到#，找到其前面2个数字字符对应的字母，否则，直接将对应的字符转成字母即可。最后再将字符串反转即可。</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">freqAlphabets</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>(), num;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;#&#x27;</span>)&#123;<span class="comment">//遇到#，找到其前面的2个字符对应的字母</span></span><br><span class="line">                num = (s[i - <span class="number">2</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (s[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                i = i - <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                num = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span> + num - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());<span class="comment">//反转</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="1310-子数组异或查询"><a href="#1310-子数组异或查询" class="headerlink" title="1310. 子数组异或查询"></a><a href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray/">1310. 子数组异或查询</a></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。 对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor … xor arr[Ri]）作为本次查询的结果。 并返回一个包含给定查询 queries 所有结果的数组。 示例 1： 输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]] 输出：[2,7,14,8] 解释： 数组中元素的二进制表示形式是： 1 = 0001 3 = 0011 4 = 0100 8 = 1000 查询的 XOR 值为： [0,1] = 1 xor 3 = 2 [1,2] = 3 xor 4 = 7 [0,3] = 1 xor 3 xor 4 xor 8 = 14 [3,3] = 8 示例 2： 输入：arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]] 输出：[8,0,4,4] 提示： 1 &lt;= arr.length &lt;= 3 * 10^4 1 &lt;= arr[i] &lt;= 10^9 1 &lt;= queries.length &lt;= 3 * 10^4 queries[i].length == 2 0 &lt;= queries[i][0] &lt;= queries[i][1] &lt; arr.length</p>
<h2 id="题解1-1"><a href="#题解1-1" class="headerlink" title="题解1"></a>题解1</h2><p>思路类似求任意区间的数字和，首先用vec[i]存储从arr[0]到arr[i]这些元素的异或，然后对于区间[a, b]的所有元素异或值为$vec[b] \oplus vec [a - 1]$</p>
<h2 id="代码1-1"><a href="#代码1-1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">xorQueries</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res, vec;</span><br><span class="line">        <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                vec.<span class="built_in">push_back</span>(arr[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                vec.<span class="built_in">push_back</span>(vec[i - <span class="number">1</span>] ^ arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> que:queries)&#123;</span><br><span class="line">            <span class="keyword">if</span>(que[<span class="number">0</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(vec[que[<span class="number">1</span>]]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(vec[que[<span class="number">1</span>]] ^ vec[que[<span class="number">0</span>] - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="1311-获取你好友已观看的视频"><a href="#1311-获取你好友已观看的视频" class="headerlink" title="1311. 获取你好友已观看的视频"></a><a href="https://leetcode-cn.com/problems/get-watched-videos-by-your-friends/">1311. 获取你好友已观看的视频</a></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 n 个人，每个人都有一个  0 到 n-1 的唯一 id 。 给你数组 watchedVideos  和 friends ，其中 watchedVideos[i]  和 friends[i] 分别表示 id = i 的人观看过的视频列表和他的好友列表。 Level 1 的视频包含所有你好友观看过的视频，level 2 的视频包含所有你好友的好友观看过的视频，以此类推。一般的，Level 为 k 的视频包含所有从你出发，最短距离为 k 的好友观看过的视频。 给定你的 id  和一个 level 值，请你找出所有指定 level 的视频，并将它们按观看频率升序返回。如果有频率相同的视频，请将它们按名字字典序从小到大排列。 示例 1： 输入：watchedVideos = [[“A”,”B”],[“C”],[“B”,”C”],[“D”]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 1 输出：[“B”,”C”] 解释： 你的 id 为 0 ，你的朋友包括： id 为 1 -&gt; watchedVideos = [“C”]  id 为 2 -&gt; watchedVideos = [“B”,”C”]  你朋友观看过视频的频率为： B -&gt; 1  C -&gt; 2 示例 2： 输入：watchedVideos = [[“A”,”B”],[“C”],[“B”,”C”],[“D”]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 2 输出：[“D”] 解释： 你的 id 为 0 ，你朋友的朋友只有一个人，他的 id 为 3 。 提示： n == watchedVideos.length == friends.length 2 &lt;= n &lt;= 100 1 &lt;= watchedVideos[i].length &lt;= 100 1 &lt;= watchedVideos[i][j].length &lt;= 8 0 &lt;= friends[i].length &lt; n 0 &lt;= friends[i][j] &lt; n 0 &lt;= id &lt; n 1 &lt;= level &lt; n 如果 friends[i] 包含 j ，那么 friends[j] 包含 i</p>
<h2 id="题解1-2"><a href="#题解1-2" class="headerlink" title="题解1"></a>题解1</h2><p>BFS。首先利用BFS找到和起始id距离为level的所有朋友，然后统计这些朋友的观影情况，按观看频率升率返回，相同的，按字典序从小到大排列。</p>
<h2 id="代码1-2"><a href="#代码1-2" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> id, <span class="type">int</span> level):<span class="built_in">id</span>(id), <span class="built_in">level</span>(level)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">watchedVideosByFriends</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; watchedVideos, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; friends, <span class="type">int</span> id, <span class="type">int</span> level)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;ids;</span><br><span class="line">        vector&lt;string&gt;res;</span><br><span class="line">        map&lt;string, <span class="type">int</span>&gt;myMap;</span><br><span class="line">        queue&lt;Node&gt;que;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">mark</span>(watchedVideos.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        set&lt;pair&lt;<span class="type">int</span>, string&gt;&gt;tmp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        BFS寻找距离为level的朋友们的id</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        que.<span class="built_in">push</span>(<span class="built_in">Node</span>(id, <span class="number">0</span>));</span><br><span class="line">        mark[id] = <span class="number">1</span>;</span><br><span class="line">        <span class="function">Node <span class="title">frt</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span>, <span class="title">next</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            frt = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(frt.level &gt; level)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(frt.level == level)&#123;</span><br><span class="line">                ids.<span class="built_in">push_back</span>(frt.id);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; friends[frt.id].<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">                next.id =friends[frt.id][i];</span><br><span class="line">                next.level = frt.level + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(!mark[next.id])&#123;</span><br><span class="line">                    mark[next.id] = <span class="number">1</span>;</span><br><span class="line">                    que.<span class="built_in">push</span>(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计朋友们的观影频率</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> id:ids)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> video:watchedVideos[id])&#123;</span><br><span class="line">                <span class="keyword">if</span>(myMap.<span class="built_in">find</span>(video) == myMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    myMap[video] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    myMap[video] = myMap[video]+ <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//放入set中自动排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter:myMap)&#123;</span><br><span class="line">            tmp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(iter.second, iter.first));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter:tmp)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(iter.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="1312-让字符串成为回文串的最少插入次数"><a href="#1312-让字符串成为回文串的最少插入次数" class="headerlink" title="1312. 让字符串成为回文串的最少插入次数"></a>1312. 让字符串成为回文串的最少插入次数</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s ，每一次操作你都可以在字符串的任意位置插入任意字符。 请你返回让 s 成为回文串的 最少操作次数 。 「回文串」是正读和反读都相同的字符串。 示例 1： 输入：s = “zzazz” 输出：0 解释：字符串 “zzazz” 已经是回文串了，所以不需要做任何插入操作。 示例 2： 输入：s = “mbadm” 输出：2 解释：字符串可变为 “mbdadbm” 或者 “mdbabdm” 。 示例 3： 输入：s = “leetcode” 输出：5 解释：插入 5 个字符后字符串变为 “leetcodocteel” 。 示例 4： 输入：s = “g” 输出：0 示例 5： 输入：s = “no” 输出：1 提示： 1 &lt;= s.length &lt;= 500 s 中所有字符都是小写字母。</p>
<h2 id="题解1-3"><a href="#题解1-3" class="headerlink" title="题解1"></a>题解1</h2><p>动态规划。 题目实际上是最长回文子序列的变形。求出最长回文子序列的长度，再用原长度len - 回文子序列的长度即可。</p>
<h2 id="代码1-3"><a href="#代码1-3" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">找出s中最长回文子序列len1</span></span><br><span class="line"><span class="comment">题目中要求的是len - len1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minInsertions</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(len + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(len + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;<span class="comment">//长度为1的串，最长回文序列就是它本身即长度为1</span></span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j + i &lt; len)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[j] == s[j + i])&#123;</span><br><span class="line">                        dp[j][j + i] = dp[j + <span class="number">1</span>][j + i - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[j][j + i] = <span class="built_in">max</span>(dp[j + <span class="number">1</span>][j + i], dp[j][j + i - <span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len - dp[<span class="number">0</span>][len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode2020第176场周赛</title>
    <url>/2020/02/17/leetcode2020%E7%AC%AC176%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="5340-统计有序矩阵中的负数"><a href="#5340-统计有序矩阵中的负数" class="headerlink" title="5340. 统计有序矩阵中的负数"></a><a href="https://leetcode-cn.com/problems/count-negative-numbers-in-a-sorted-matrix/">5340. 统计有序矩阵中的负数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个 <code>m * n</code> 的矩阵 <code>grid</code>，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。  请你统计并返回 <code>grid</code> 中 <strong>负数</strong> 的数目。   <strong>示例 1：</strong></p>
<p><strong>输入：</strong>grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]<br><strong>输出：</strong>8<br><strong>解释：</strong>矩阵中共有 8 个负数。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>grid = [[3,2],[1,0]]<br><strong>输出：</strong>0</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>grid = [[1,-1],[-1,-1]]<br><strong>输出：</strong>3</p>
<p><strong>示例 4：</strong></p>
<p><strong>输入：</strong>grid = [[-1]]<br><strong>输出：</strong>1</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>遍历二维数组，统计负数的个数即可。 时间复杂度为：$O(n^2)$ 空间复杂度为：$O(1)$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNegatives</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] &lt; <span class="number">0</span>)&#123;<span class="comment">//统计负数的个数</span></span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="5341-最后-K-个数的乘积"><a href="#5341-最后-K-个数的乘积" class="headerlink" title="5341. 最后 K 个数的乘积"></a><a href="https://leetcode-cn.com/problems/product-of-the-last-k-numbers/">5341. 最后 K 个数的乘积</a></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>请你实现一个「数字乘积类」<code>ProductOfNumbers</code>，要求支持下述两种方法： 1. <code>add(int num)</code></p>
<ul>
<li>将数字 <code>num</code> 添加到当前数字列表的最后面。</li>
</ul>
<ol>
<li><code>getProduct(int k)</code></li>
</ol>
<ul>
<li>返回当前数字列表中，最后 <code>k</code> 个数字的乘积。</li>
<li>你可以假设当前列表中始终 <strong>至少</strong> 包含 <code>k</code> 个数字。</li>
</ul>
<p>题目数据保证：任何时候，任一连续数字序列的乘积都在 32-bit 整数范围内，不会溢出。   <strong>示例：</strong></p>
<p><strong>输入：</strong><br>[“ProductOfNumbers”,”add”,”add”,”add”,”add”,”add”,”getProduct”,”getProduct”,”getProduct”,”add”,”getProduct”]<br>[[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]</p>
<p><strong>输出：</strong><br>[null,null,null,null,null,null,20,40,0,null,32]</p>
<p><strong>解释：</strong><br>ProductOfNumbers productOfNumbers = new ProductOfNumbers();<br>productOfNumbers.add(3);        // [3]<br>productOfNumbers.add(0);        // [3,0]<br>productOfNumbers.add(2);        // [3,0,2]<br>productOfNumbers.add(5);        // [3,0,2,5]<br>productOfNumbers.add(4);        // [3,0,2,5,4]<br>productOfNumbers.getProduct(2); // 返回 20 。最后 2 个数字的乘积是 5 * 4 = 20<br>productOfNumbers.getProduct(3); // 返回 40 。最后 3 个数字的乘积是 2 * 5 * 4 = 40<br>productOfNumbers.getProduct(4); // 返回  0 。最后 4 个数字的乘积是 0 * 2 * 5 * 4 = 0<br>productOfNumbers.add(8);        // [3,0,2,5,4,8]<br>productOfNumbers.getProduct(2); // 返回 32 。最后 2 个数字的乘积是 4 * 8 = 32 </p>
<h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>周赛的时候没有多想，上来直接用vector来存储所有的数，<code>add</code>函数用<code>push_back</code>来实现。最后k个元素乘积直接从vector的最后一个元素开始，将k个元素乘起来即可。 时间复杂度为：O(n) 空间复杂度为：O(n)</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProductOfNumbers</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;vec;</span><br><span class="line">    <span class="built_in">ProductOfNumbers</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getProduct</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = vec.<span class="built_in">size</span>(), res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= len - k; --i)&#123;</span><br><span class="line">            res = res * vec[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your ProductOfNumbers object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * ProductOfNumbers* obj = new ProductOfNumbers();</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(num);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;getProduct(k);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h2><p>参照<a href="https://leetcode-cn.com/circle/discuss/0gO5RS/">LeetCode - 圈子</a>，对于第二题给出了许多优化的算法。题目中给出的限制条件需要注意。</p>
<blockquote>
<p>题目数据保证：任何时候，任一连续数字序列的乘积都在 32-bit 整数范围内，不会溢出。 0 &lt;= num &lt;= 100</p>
</blockquote>
<p>对于任一连续序列的乘积都小于32位整数范围，表示序列中最多只有31个数大于1（$2^{31} - 1$），其它数字都是0和1。所以可以用前缀和来统计0-100这101个数字在序列中出现的个数，这里空间开销是101 * n（n是序列的总长度）。计算最后K个数的乘积，只需要先找出每个数字num出现的次数cnt，$cnt_{num} = vec[n][num] - vec[n - k][num]$，出现0，最后乘积就为0，出现1，则跳过1不算。然后再求其它数字乘积即可。 这里我介绍前缀积的思路。数组存储连续数字的乘积，遇到0，清除数组，重新统计。当最后数组长度不足K时，表示乘积为0，否则就用总乘积除以前面元素的乘积。 时间复杂度为：O(1) 空间复杂度为：O(n)</p>
<h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProductOfNumbers</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;vec;</span><br><span class="line">    <span class="built_in">ProductOfNumbers</span>() &#123;</span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;<span class="comment">//遇到0，清空前缀积数组</span></span><br><span class="line">            vec.<span class="built_in">clear</span>();</span><br><span class="line">            vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(vec.<span class="built_in">back</span>() * num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getProduct</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vec.<span class="built_in">size</span>() - <span class="number">1</span> &lt; k)&#123;<span class="comment">//数组长度不足K表示，最后K个数中存在0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> vec[vec.<span class="built_in">size</span>() - <span class="number">1</span>] / vec[vec.<span class="built_in">size</span>() - <span class="number">1</span> - k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your ProductOfNumbers object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * ProductOfNumbers* obj = new ProductOfNumbers();</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(num);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;getProduct(k);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="1353-最多可以参加的会议数目"><a href="#1353-最多可以参加的会议数目" class="headerlink" title="1353. 最多可以参加的会议数目"></a><a href="https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended/">1353. 最多可以参加的会议数目</a></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个数组 <code>events</code>，其中 <code>events[i] = [startDayi, endDayi]</code> ，表示会议 <code>i</code> 开始于 <code>startDayi</code> ，结束于 <code>endDayi</code> 。 你可以在满足 <code>startDayi &lt;= d &lt;= endDayi</code> 中的任意一天 <code>d</code> 参加会议 <code>i</code> 。注意，一天只能参加一个会议。 请你返回你可以参加的 <strong>最大</strong> 会议数目。   <strong>示例 1：</strong> <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/16/e1.png" alt=""></p>
<p><strong>输入：</strong>events = [[1,2],[2,3],[3,4]]<br><strong>输出：</strong>3<br><strong>解释：</strong>你可以参加所有的三个会议。<br>安排会议的一种方案如上图。<br>第 1 天参加第一个会议。<br>第 2 天参加第二个会议。<br>第 3 天参加第三个会议。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>events= [[1,2],[2,3],[3,4],[1,2]]<br><strong>输出：</strong>4</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>events = [[1,4],[4,4],[2,2],[3,4],[1,1]]<br><strong>输出：</strong>4</p>
<p><strong>示例 4：</strong></p>
<p><strong>输入：</strong>events = [[1,100000]]<br><strong>输出：</strong>1</p>
<p><strong>示例 5：</strong></p>
<p><strong>输入：</strong>events = [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7]]<br><strong>输出：</strong>7</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>贪心+优先队列 首先将区间按开始时间进行排序，然后结束时间早的先安排。还需要鼗安排冲突，不合理的去掉。 时间复杂度为：O(nlogn) 空间复杂度为：O(n)</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxEvents</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; events)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt;que;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, idx = <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//先排序</span></span><br><span class="line">        <span class="built_in">sort</span>(events.<span class="built_in">begin</span>(), events.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span>(i &lt; events.<span class="built_in">size</span>()  que.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; events.<span class="built_in">size</span>() &amp;&amp; events[i][<span class="number">0</span>] == idx)&#123;<span class="comment">//开始时间为idx的，均添加到优先队列</span></span><br><span class="line">                que.<span class="built_in">push</span>(events[i][<span class="number">1</span>]);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(que.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; que.<span class="built_in">top</span>() &lt; idx)&#123;<span class="comment">//去除安排冲突的</span></span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(que.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;<span class="comment">//优先安排结束时间早的</span></span><br><span class="line">                ++cnt;</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ++idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="5343-多次求和构造目标数组"><a href="#5343-多次求和构造目标数组" class="headerlink" title="5343. 多次求和构造目标数组"></a><a href="https://leetcode-cn.com/problems/construct-target-array-with-multiple-sums/">5343. 多次求和构造目标数组</a></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 <code>target</code> 。一开始，你有一个数组 <code>A</code> ，它的所有元素均为 1 ，你可以执行以下操作：</p>
<ul>
<li>令 <code>x</code> 为你数组里所有元素的和</li>
<li>选择满足 <code>0 &lt;= i &lt; target.size</code> 的任意下标 <code>i</code> ，并让 <code>A</code> 数组里下标为 <code>i</code> 处的值为 <code>x</code> 。</li>
<li>你可以重复该过程任意次</li>
</ul>
<p>如果能从 <code>A</code> 开始构造出目标数组 <code>target</code> ，请你返回 True ，否则返回 False 。   <strong>示例 1：</strong></p>
<p><strong>输入：</strong>target = [9,3,5]<br><strong>输出：</strong>true<br><strong>解释：</strong>从 [1, 1, 1] 开始<br>[1, 1, 1], 和为 3 ，选择下标 1<br>[1, 3, 1], 和为 5， 选择下标 2<br>[1, 3, 5], 和为 9， 选择下标 0<br>[9, 3, 5] 完成</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>target = [1,1,1,2]<br><strong>输出：</strong>false<br><strong>解释：</strong>不可能从 [1,1,1,1] 出发构造目标数组。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>target = [8,5]<br><strong>输出：</strong>true</p>
<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>正向思考，不知道用所有的数字之和去替换哪一个数字，尝试的话可能性太多，实现难度太大。反向思考的话，数组中最大的数字显然是上一个数组中所有数字之和，而它所替换的数字等于最大的数字减去其它数字之和。如此替换下去，如果最后所有的数字都为1，表示可以构造目标数组，一旦出现数字0或负数，表示不能构造。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPossible</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rep_num = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt;que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; target.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            sum += target[i];</span><br><span class="line">            que.<span class="built_in">push</span>(target[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(que.<span class="built_in">top</span>() != <span class="number">1</span>)&#123;</span><br><span class="line">            sum = sum - que.<span class="built_in">top</span>();<span class="comment">//除去最大数字其它数字之和</span></span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">1</span>)&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这里用除法而不用减法是为了处理像[100000, 1]这样的例子超时的问题</span></span><br><span class="line"><span class="comment">            用除法，直接使当前的最大数字小于其它数字之和，避免多轮最大数字都是同一个。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(que.<span class="built_in">top</span>() / sum == <span class="number">0</span>  (que.<span class="built_in">top</span>() % sum == <span class="number">0</span>))&#123;<span class="comment">//出现负数和0</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(que.<span class="built_in">top</span>() % sum);</span><br><span class="line">                sum = sum + que.<span class="built_in">top</span>() % sum;<span class="comment">//上一个数组的所有元素之和</span></span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>优先队列</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode第13场双周赛</title>
    <url>/2019/11/20/leetcode%E7%AC%AC13%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="1256-加密数字"><a href="#1256-加密数字" class="headerlink" title="1256. 加密数字"></a>1256. 加密数字</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个非负整数 num ，返回它的「加密字符串」。 加密的过程是把一个整数用某个未知函数进行转化，你需要从下表推测出该转化函数： <a href="https://i.loli.net/2019/11/20/qP8LSD2McVuxWC4.png" title="题目描述1"><img src="https://i.loli.net/2019/11/20/qP8LSD2McVuxWC4.png" alt="题目描述1" title="题目描述1"></a> 示例 1： 输入：num = 23 输出：”1000” 示例 2： 输入：num = 107 输出：”101100” 提示： 0 &lt;= num &lt;= 10^9</p>
<h2 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h2><p>我发现的规律1-2 编码位数为1位从0 - 1，3-6编码位数为2位从00 - 11。7-14编码位数为3位从000 - 111。所以从这个规律中我需要知道2个信息编码的位数及在编码中位置（即第几个）。</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">encode</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> tmp = <span class="number">0</span>, sum = <span class="number">0</span>, res;</span><br><span class="line">        <span class="type">int</span> bit = <span class="number">0</span>;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;<span class="comment">//0的话为空串</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(sum &lt;= num)&#123;<span class="comment">//sum = 2 ^ (bit) -1 寻找2^bit - 1 &gt; num</span></span><br><span class="line">            <span class="keyword">if</span>(bit == <span class="number">0</span>)&#123;</span><br><span class="line">                tmp = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tmp = tmp &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            bit++;</span><br><span class="line">            sum += tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        res = num - (sum - tmp);<span class="comment">//num在bit-1位中编码的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; bit - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            s.<span class="built_in">push_back</span>(res % <span class="number">2</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            res = res &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());<span class="comment">//逆序</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h2><p>参考圈子中的讨论，其实一个数num的编码为num+1的二进制数的低bit-1位（除去最高位）。 比如num = 6的编码为11相当于7（111）的后两位。 其实反过来题解1可以从侧面证实这种解法的正确性，最后得到的res与num存在以下关系 $latex num = res + 2^{bit - 1} - 1$变化成$latex num + 1 = res + 2^{bit - 1}$ res显然是num + 1的后bit-1位</p>
<h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">encode</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="type">int</span> res = num + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(res)&#123;</span><br><span class="line">            s.<span class="built_in">push_back</span>((res &amp; <span class="number">1</span>) + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            res = res &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());<span class="comment">//逆序</span></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(<span class="number">1</span>);<span class="comment">//只输出 低bit-1位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="1257-最小公共区域"><a href="#1257-最小公共区域" class="headerlink" title="1257. 最小公共区域"></a>1257. 最小公共区域</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一些区域列表 regions ，每个列表的第一个区域都包含这个列表内所有其他区域。 很自然地，如果区域 X 包含区域 Y ，那么区域 X 比区域 Y 大。 给定两个区域 region1 和 region2 ，找到同时包含这两个区域的 最小 区域。 如果区域列表中 r1 包含 r2 和 r3 ，那么数据保证 r2 不会包含 r3 。 数据同样保证最小公共区域一定存在。 示例 1： 输入： regions = [[“Earth”,”North America”,”South America”], [“North America”,”United States”,”Canada”], [“United States”,”New York”,”Boston”], [“Canada”,”Ontario”,”Quebec”], [“South America”,”Brazil”]], region1 = “Quebec”, region2 = “New York” 输出：”North America” 提示： 2 &lt;= regions.length &lt;= 10^4 region1 != region2 所有字符串只包含英文字母和空格，且最多只有 20 个字母。</p>
<h2 id="题解1-1"><a href="#题解1-1" class="headerlink" title="题解1"></a>题解1</h2><p>根据regions建立并查集 然后将region1与region2的所有父结点（包括它们自已）放到v1与v2中。 寻找v1与v2的第一个相交元素即为所示。</p>
<h2 id="代码1-1"><a href="#代码1-1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;string, string&gt;maps;</span><br><span class="line">    <span class="function">string <span class="title">findSmallestRegion</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; regions, string region1, string region2)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt;v1, v2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; regions.<span class="built_in">size</span>(); ++i)&#123;<span class="comment">//建立并查集</span></span><br><span class="line">            string fa = regions[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; regions[i].<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">                maps[regions[i][j]] = fa;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将region1与region2的所有父结点对应放到v1与v2中。</span></span><br><span class="line">        <span class="comment">//然后寻找v1与v2第1个相交的元素</span></span><br><span class="line">        v1.<span class="built_in">push_back</span>(region1);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(region2);</span><br><span class="line">        string tmp = region1;</span><br><span class="line">        <span class="keyword">while</span>(maps.<span class="built_in">find</span>(tmp) != maps.<span class="built_in">end</span>())&#123;</span><br><span class="line">            tmp = maps[tmp];</span><br><span class="line">            v1.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = region2;</span><br><span class="line">        <span class="keyword">while</span>(maps.<span class="built_in">find</span>(tmp) != maps.<span class="built_in">end</span>())&#123;</span><br><span class="line">            tmp = maps[tmp];</span><br><span class="line">            v2.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v1[i]) != v2.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> v1[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="1258-近义词句子"><a href="#1258-近义词句子" class="headerlink" title="1258. 近义词句子"></a>1258. 近义词句子</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个近义词表 synonyms 和一个句子 text ， synonyms 表中是一些近义词对 ，你可以将句子 text 中每个单词用它的近义词来替换。 请你找出所有用近义词替换后的句子，按 字典序排序 后返回。 示例 1： 输入： synonyms = [[“happy”,”joy”],[“sad”,”sorrow”],[“joy”,”cheerful”]], text = “I am happy today but was sad yesterday” 输出： [“I am cheerful today but was sad yesterday”, “I am cheerful today but was sorrow yesterday”, “I am happy today but was sad yesterday”, “I am happy today but was sorrow yesterday”, “I am joy today but was sad yesterday”, “I am joy today but was sorrow yesterday”] 提示： 0 &lt;= synonyms.length &lt;= 10 synonyms[i].length == 2 synonyms[0] != synonyms[1] 所有单词仅包含英文字母，且长度最多为 10 。 text 最多包含 10 个单词，且单词间用单个空格分隔开。</p>
<h2 id="题解1-2"><a href="#题解1-2" class="headerlink" title="题解1"></a>题解1</h2><p>题意比较简单，但是比较麻烦。 首先根据近义词对，将所有近义的放到同一个set中 然后将句子text转成单词数组，遍历单词，对每一个单词，在近义词中查找看是否存在近义词，如果存在，则将近义词组中的所有单词添加到v中。 最后通过DFS来生成所有近义的句子。</p>
<h2 id="代码1-2"><a href="#代码1-2" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt;res, words;</span><br><span class="line">string tmp;</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt;<span class="built_in">v</span>(<span class="number">15</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generate</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> n)</span></span>&#123;<span class="comment">//DFS生成句子</span></span><br><span class="line">    <span class="keyword">if</span>(idx &gt;= n)&#123;</span><br><span class="line">        tmp.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                tmp.<span class="built_in">append</span>(words[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tmp.<span class="built_in">append</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                tmp.<span class="built_in">append</span>(words[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> str:v[idx])&#123;</span><br><span class="line">        words.<span class="built_in">push_back</span>(str);</span><br><span class="line">        <span class="built_in">generate</span>(idx + <span class="number">1</span>, n);</span><br><span class="line">        words.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateSentences</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; sy, string text)</span> </span>&#123;</span><br><span class="line">        set&lt;string&gt;sets[<span class="number">15</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i)&#123;<span class="comment">//全局变量需要重置，不然执行结果与本地不相同</span></span><br><span class="line">            v[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">clear</span>();</span><br><span class="line">        words.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>, cnt = <span class="number">-1</span>;</span><br><span class="line">        vector&lt;string&gt;sen;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; sy.<span class="built_in">size</span>(); ++i)&#123;<span class="comment">//根据同义词组，将同义的放到同一个set中</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                idx =cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                idx = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= cnt; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(sets[j].<span class="built_in">find</span>(sy[i][<span class="number">0</span>]) != sets[j].<span class="built_in">end</span>()  sets[j].<span class="built_in">find</span>(sy[i][<span class="number">1</span>]) != sets[j].<span class="built_in">end</span>())&#123;</span><br><span class="line">                        idx = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(idx == <span class="number">-1</span>)&#123;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                    idx = cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> str:sy[i])&#123;</span><br><span class="line">                sets[idx].<span class="built_in">insert</span>(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">istringstream <span class="title">s</span><span class="params">(text)</span></span>;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="keyword">while</span>(s &gt;&gt; str)&#123;<span class="comment">//句子拆成单词</span></span><br><span class="line">            sen.<span class="built_in">push_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; sen.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= cnt; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sets[j].<span class="built_in">find</span>(sen[i]) != sets[j].<span class="built_in">end</span>())&#123;<span class="comment">//如果同义词组中找到该词，则将该同义词组中所有元素放到v[i]中</span></span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> iter :sets[j])&#123;</span><br><span class="line">                        v[i].<span class="built_in">push_back</span>(iter);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                v[i].<span class="built_in">push_back</span>(sen[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">generate</span>(<span class="number">0</span>, sen.<span class="built_in">size</span>());<span class="comment">//DFS生成句子</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="1259-不相交的握手"><a href="#1259-不相交的握手" class="headerlink" title="1259. 不相交的握手"></a>1259. 不相交的握手</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>偶数 个人站成一个圆，总人数为 num_people 。每个人与除自己外的一个人握手，所以总共会有 num_people / 2 次握手。 将握手的人之间连线，请你返回连线不会相交的握手方案数。 由于结果可能会很大，请你返回答案 模 10^9+7 后的结果。 示例 1： 输入：num_people = 2 输出：1 示例 2： <a href="https://i.loli.net/2019/11/20/cgwIRQb8XUnNelP.png"><img src="https://i.loli.net/2019/11/20/cgwIRQb8XUnNelP.png" alt=""></a> 输入：num_people = 4 输出：2 解释：总共有两种方案，第一种方案是 [(1,2),(3,4)] ，第二种方案是 [(2,3),(4,1)] 。 示例 3： <a href="https://i.loli.net/2019/11/20/VYOeulqkWd2syxI.png"><img src="https://i.loli.net/2019/11/20/VYOeulqkWd2syxI.png" alt=""></a> 输入：num_people = 6 输出：5 示例 4： 输入：num_people = 8 输出：14 提示： 2 &lt;= num_people &lt;= 1000 num_people % 2 == 0</p>
<h2 id="题解1-3"><a href="#题解1-3" class="headerlink" title="题解1"></a>题解1</h2><p>这题可以用分治法也可以采用打表的形式，最多也就1000人，可以将所有的结果求出来。然后查询。 如果有n个人，g(n)记为n个握手方案的个数。编号为1， 2， 3， 4， ……， n。对于编号1，它只能和2， 4， 6， ……， 8握手，不然导致之间奇数人握手必有交叉。如果1与2握手，则3， 4， ……， n握手转成n-2个人握手问题，方案数为g(n -2)。如果1与4握手，则方案数为g(2) * g(n - 4)。 所以总方案数g(n)存在以下公式。 <script type="math/tex">g(n) = g(0) \* g(n - 2) + g(2) \* g(n - 4) + …… + g(n - 2) \* g(0)</script></p>
<h2 id="代码1-3"><a href="#代码1-3" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MOD (1000000000 + 7)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfWays</span><span class="params">(<span class="type">int</span> num_people)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res[<span class="number">1005</span>];</span><br><span class="line">        <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="built_in">sizeof</span>(res));</span><br><span class="line">        res[<span class="number">0</span>] = res[<span class="number">2</span>] = <span class="number">1</span>, res[<span class="number">4</span>] = <span class="number">2</span>, res[<span class="number">6</span>] = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">8</span>; i &lt;= <span class="number">1000</span>; i +=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j += <span class="number">2</span>)&#123;</span><br><span class="line">                res[i] = (res[i] + res[j] * res[i - <span class="number">2</span>- j]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[num_people];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title>linux screen 命令详解</title>
    <url>/2020/01/16/linux-screen-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>参见<a href="https://blog.csdn.net/xfg0218/article/details/81869313">博客</a></p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>会话恢复、多会话、会话共享</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Options:</span><br><span class="line">-4            Resolve hostnames only to IPv4 addresses.</span><br><span class="line">-6            Resolve hostnames only to IPv6 addresses.</span><br><span class="line">-a            Force all capabilities into each window&#x27;s termcap.</span><br><span class="line">-A -[rR]     Adapt all windows to the new display width &amp; height.</span><br><span class="line">-c file       Read configuration file instead of &#x27;.screenrc&#x27;.</span><br><span class="line">-d (-r)       Detach the elsewhere running screen (and reattach here).</span><br><span class="line">-dmS name     Start as daemon: Screen session in detached mode.</span><br><span class="line">-D (-r)       Detach and logout remote (and reattach here).</span><br><span class="line">-D -RR        Do whatever is needed to get a screen session.</span><br><span class="line">-e xy         Change command characters.</span><br><span class="line">-f            Flow control on, -fn = off, -fa = auto.</span><br><span class="line">-h lines      Set the size of the scrollback history buffer.</span><br><span class="line">-i            Interrupt output sooner when flow control is on.</span><br><span class="line">-l            Login mode on (update /var/run/utmp), -ln = off.</span><br><span class="line">-ls [match]   or</span><br><span class="line">-list         Do nothing, just list our SockDir [on possible matches].</span><br><span class="line">-L            Turn on output logging.</span><br><span class="line">-m            ignore $STY variable, do create a new screen session.</span><br><span class="line">-O            Choose optimal output rather than exact vt100 emulation.</span><br><span class="line">-p window     Preselect the named window if it exists.</span><br><span class="line">-q            Quiet startup. Exits with non-zero return code if unsuccessful.</span><br><span class="line">-Q            Commands will send the response to the stdout of the querying process.</span><br><span class="line">-r [session]  Reattach to a detached screen process.</span><br><span class="line">-R            Reattach if possible, otherwise start a new session.</span><br><span class="line">-s shell      Shell to execute rather than $SHELL.</span><br><span class="line">-S sockname   Name this session &lt;pid&gt;.sockname instead of &lt;pid&gt;.&lt;tty&gt;.&lt;host&gt;.</span><br><span class="line">-t title      Set title. (window&#x27;s name).</span><br><span class="line">-T term       Use term as $TERM for windows, rather than &quot;screen&quot;.</span><br><span class="line">-U            Tell screen to use UTF-8 encoding.</span><br><span class="line">-v            Print &quot;Screen version 4.01.00devel (GNU) 2-May-06&quot;.</span><br><span class="line">-wipe [match] Do nothing, just clean up SockDir [on possible matches].</span><br><span class="line">-x            Attach to a not detached screen. (Multi display mode).</span><br><span class="line">-X            Execute &lt;cmd&gt; as a screen command in the specified session.</span><br></pre></td></tr></table></figure>
<h2 id="常用screen参数"><a href="#常用screen参数" class="headerlink" title="常用screen参数"></a>常用screen参数</h2><p>screen -S yourname -&gt; 新建一个叫yourname的session screen -ls -&gt; 列出当前所有的session screen -r yourname -&gt; 回到yourname这个session screen -d yourname -&gt; 远程detach某个session screen -d -r yourname -&gt; 结束当前session并回到yourname这个session</p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><h3 id="安装screen"><a href="#安装screen" class="headerlink" title="安装screen"></a>安装screen</h3><p><code>yum install screen</code></p>
<h3 id="创建新会话"><a href="#创建新会话" class="headerlink" title="创建新会话"></a>创建新会话</h3><p><code>screen -S onwaier</code></p>
<h3 id="显示会话列表"><a href="#显示会话列表" class="headerlink" title="显示会话列表"></a>显示会话列表</h3><p><img src="/images/2020/01/41c572d91420db04e5cae3b024e87a15.png" alt=""></p>
<h3 id="暂停与恢复会话"><a href="#暂停与恢复会话" class="headerlink" title="暂停与恢复会话"></a>暂停与恢复会话</h3><p><code>screen -d 27537</code> 27537会话已变成detached状态 <img src="/images/2020/01/2e78cb20f3650367284f8a0c92963779.png" alt=""> <code>screen -r 27537</code> 27537会话再次变成attached状态 <img src="/images/2020/01/1bb040a4a88cbcea494bead8c33c8e5c.png" alt=""></p>
<h3 id="杀死与清除dead会话"><a href="#杀死与清除dead会话" class="headerlink" title="杀死与清除dead会话"></a>杀死与清除dead会话</h3><p><code>kill -9 27537</code> <img src="/images/2020/01/abb08e8489319630f7e12184b9094a5c.png" alt=""> <code>screen -wipe 27537</code> <img src="/images/2020/01/9399c3881226cf3d8bcd3be79c9c6e55.png" alt=""></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>screen</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 配置shadowsocks客户端</title>
    <url>/2019/10/28/linux-%E9%85%8D%E7%BD%AEshadowsocks%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[<h2 id="具体参考博客"><a href="#具体参考博客" class="headerlink" title="具体参考博客"></a>具体参考<a href="https://lvii.gitbooks.io/outman/content/ss.linux.html">博客</a></h2><p>软件包提到了shadowsocks-libev和python-shadowsocks。 <strong>注意</strong>： 1. python-shadowsockds是不支持chacha20-ietf-poly1305协议的 2. 两者的命令还是存在差异的:<code>ss-local -c ss.json</code>和<code>sslocal -c ss.json</code></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>linux与onedrive间同步/备份</title>
    <url>/2020/01/17/linux%E4%B8%8Eonedrive%E9%97%B4%E5%90%8C%E6%AD%A5-%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<p>参照<a href="https://www.moerats.com/archives/740/">博客</a>和<a href="https://github.com/abraunegg/onedrive">github项目</a></p>
<h2 id="安装依赖（针对centos）"><a href="#安装依赖（针对centos）" class="headerlink" title="安装依赖（针对centos）"></a>安装依赖（针对centos）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum groupinstall &#x27;Development Tools&#x27; -y</span><br><span class="line">yum install libcurl-devel -y</span><br><span class="line">yum install sqlite-devel -y</span><br><span class="line">yum install libnotify-devel -y</span><br><span class="line">curl -fsS https://dlang.org/install.sh  bash -s dmd</span><br></pre></td></tr></table></figure>
<p>安装后返回信息 <img src="/images/2020/01/3033f485823bfe9bebed9fb0029d2555.png" alt=""> 执行<code>source ~/dlang/dmd-2.090.0/activate</code>激活环境。</p>
<h2 id="安装客户端"><a href="#安装客户端" class="headerlink" title="安装客户端"></a>安装客户端</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/abraunegg/onedrive.git</span><br><span class="line">cd onedrive</span><br><span class="line">./configure</span><br><span class="line">make clean; make;</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>执行<code>onedrive</code>命令 <img src="/images/2020/01/797dda991ead94618f2cd17541fdeb76.png" alt=""> 复制链接，输入浏览器登录账号进行授权，再将授权后的链接地址复制到SSH客户端运行。</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="显示参数"><a href="#显示参数" class="headerlink" title="显示参数"></a>显示参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onedrive --display-config</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/980f50f6f48c0f1f880338c4007b2d2c.png" alt=""></p>
<h3 id="测试参数"><a href="#测试参数" class="headerlink" title="测试参数"></a>测试参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onedrive --synchronize --verbose --dry-run</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/53eb11d9054841c49634b2fc73ded73c.png" alt=""> 展示执行同步命令即将发生的。 <strong>Note</strong>: —dry-run can only be used with —synchronize. It cannot be used with —monitor and will be ignored.</p>
<h3 id="执行同步（默认）"><a href="#执行同步（默认）" class="headerlink" title="执行同步（默认）"></a>执行同步（默认）</h3><p>默认会将onedrive的所有文件下到<code>/root/onedrive</code>中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onedrive --synchronize</span><br></pre></td></tr></table></figure>
<h3 id="同步某个文件夹"><a href="#同步某个文件夹" class="headerlink" title="同步某个文件夹"></a>同步某个文件夹</h3><p>只同步OndDrive某文件夹到本地</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onedrive --synchronize --single-directory &#x27;&lt;dir_name&gt;&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="单向—只执行下载同步"><a href="#单向—只执行下载同步" class="headerlink" title="单向—只执行下载同步"></a>单向—只执行下载同步</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onedrive --synchronize --download-only </span><br></pre></td></tr></table></figure>
<h3 id="单向—只执行上传同步"><a href="#单向—只执行上传同步" class="headerlink" title="单向—只执行上传同步"></a>单向—只执行上传同步</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onedrive --synchronize --upload-only</span><br></pre></td></tr></table></figure>
<h2 id="部分参数说明"><a href="#部分参数说明" class="headerlink" title="部分参数说明"></a>部分参数说明</h2><p>配置文件 在<code>/root/.config/onedrive</code>中 执行<code>cd /root/.config/onedrive</code>，新建配置文件<code>touch config</code>。然后将下面默认配置内容粘贴进去。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Configuration for OneDrive Linux Client</span><br><span class="line"># This file contains the list of supported configuration fields</span><br><span class="line"># with their default values.</span><br><span class="line"># All values need to be enclosed in quotes</span><br><span class="line"># When changing a config option below, remove the &#x27;#&#x27; from the start of the line</span><br><span class="line"># For explanations of all config options below see docs/USAGE.md or the man page.</span><br><span class="line">#</span><br><span class="line"># sync_dir = &quot;~/OneDrive&quot;</span><br><span class="line"># skip_file = &quot;~*.~**.tmp&quot;</span><br><span class="line"># monitor_interval = &quot;45&quot;</span><br><span class="line"># skip_dir = &quot;&quot;</span><br><span class="line"># log_dir = &quot;/var/log/onedrive/&quot;</span><br><span class="line"># drive_id = &quot;&quot;</span><br><span class="line"># upload_only = &quot;false&quot;</span><br><span class="line"># check_nomount = &quot;false&quot;</span><br><span class="line"># check_nosync = &quot;false&quot;</span><br><span class="line"># download_only = &quot;false&quot;</span><br><span class="line"># disable_notifications = &quot;false&quot;</span><br><span class="line"># disable_upload_validation = &quot;false&quot;</span><br><span class="line"># enable_logging = &quot;false&quot;</span><br><span class="line"># force_http_11 = &quot;false&quot;</span><br><span class="line"># force_http_2 = &quot;false&quot;</span><br><span class="line"># local_first = &quot;false&quot;</span><br><span class="line"># no_remote_delete = &quot;false&quot;</span><br><span class="line"># skip_symlinks = &quot;false&quot;</span><br><span class="line"># debug_https = &quot;false&quot;</span><br><span class="line"># skip_dotfiles = &quot;false&quot;</span><br><span class="line"># dry_run = &quot;false&quot;</span><br><span class="line"># min_notify_changes = &quot;5&quot;</span><br><span class="line"># monitor_log_frequency = &quot;5&quot;</span><br><span class="line"># monitor_fullscan_frequency = &quot;10&quot;</span><br><span class="line"># sync_root_files = &quot;false&quot;</span><br><span class="line"># classify_as_big_delete = &quot;1000&quot;</span><br><span class="line"># user_agent = &quot;&quot;</span><br></pre></td></tr></table></figure>
<h3 id="sync-dir"><a href="#sync-dir" class="headerlink" title="sync_dir"></a>sync_dir</h3><p><code>sync_dir</code> 指定OneDrive中的文件同步到本地文件的位置 若修改<code>sync_dir</code>需在同步时，在原命令后加<code>--resync</code>，如<code>onedrive --synchronize --resync</code>。</p>
<h3 id="skip-dir"><a href="#skip-dir" class="headerlink" title="skip_dir"></a>skip_dir</h3><p><code>skip_dir</code>同步时跳过本地的某些文件夹。</p>
<h3 id="skip-file"><a href="#skip-file" class="headerlink" title="skip_file"></a>skip_file</h3><p><code>skip_file</code>同步时跳过本地的某些文件 <strong>注意</strong>：修改<code>skip_dir</code>和<code>skip_file</code>都是相对<code>sync_dir</code>而言的，并且修改后同步，要在原命令后加<code>--resync</code>。 具体见<a href="https://github.com/abraunegg/onedrive/blob/master/docs/USAGE.md">这里</a>。</p>
<h2 id="卸载客户端"><a href="#卸载客户端" class="headerlink" title="卸载客户端"></a>卸载客户端</h2><p>在下载的onedrive目录下执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo make uninstall</span><br><span class="line">rm -rf ~/.config/onedrive</span><br></pre></td></tr></table></figure>
<h2 id="onedrive帮助"><a href="#onedrive帮助" class="headerlink" title="onedrive帮助"></a>onedrive帮助</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OneDrive - a client for OneDrive Cloud Services</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  onedrive [options] --synchronize</span><br><span class="line">      Do a one time synchronization</span><br><span class="line">  onedrive [options] --monitor</span><br><span class="line">      Monitor filesystem and sync regularly</span><br><span class="line">  onedrive [options] --display-config</span><br><span class="line">      Display the currently used configuration</span><br><span class="line">  onedrive [options] --display-sync-status</span><br><span class="line">      Query OneDrive service and report on pending changes</span><br><span class="line">  onedrive -h  --help</span><br><span class="line">      Show this help screen</span><br><span class="line">  onedrive --version</span><br><span class="line">      Show version</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"></span><br><span class="line">  --auth-files ARG</span><br><span class="line">      Perform authorization via two files passed in as ARG in the format `authUrl:responseUrl`</span><br><span class="line">      The authorization URL is written to the `authUrl`, then onedrive waits for the file `responseUrl`</span><br><span class="line">      to be present, and reads the response from that file.</span><br><span class="line">  --check-for-nomount</span><br><span class="line">      Check for the presence of .nosync in the syncdir root. If found, do not perform sync.</span><br><span class="line">  --check-for-nosync</span><br><span class="line">      Check for the presence of .nosync in each directory. If found, skip directory from sync.</span><br><span class="line">  --confdir ARG</span><br><span class="line">      Set the directory used to store the configuration files</span><br><span class="line">  --create-directory ARG</span><br><span class="line">      Create a directory on OneDrive - no sync will be performed.</span><br><span class="line">  --debug-https</span><br><span class="line">      Debug OneDrive HTTPS communication.</span><br><span class="line">  --destination-directory ARG</span><br><span class="line">      Destination directory for renamed or move on OneDrive - no sync will be performed.</span><br><span class="line">  --disable-notifications</span><br><span class="line">      Do not use desktop notifications in monitor mode.</span><br><span class="line">  --disable-upload-validation</span><br><span class="line">      Disable upload validation when uploading to OneDrive</span><br><span class="line">  --display-config</span><br><span class="line">      Display what options the client will use as currently configured - no sync will be performed.</span><br><span class="line">  --display-sync-status</span><br><span class="line">      Display the sync status of the client - no sync will be performed.</span><br><span class="line">  --download-only</span><br><span class="line">      Only download remote changes</span><br><span class="line">  --dry-run</span><br><span class="line">      Perform a trial sync with no changes made</span><br><span class="line">  --enable-logging</span><br><span class="line">      Enable client activity to a separate log file</span><br><span class="line">  --force</span><br><span class="line">      Force the deletion of data when a &#x27;big delete&#x27; is detected</span><br><span class="line">  --force-http-1.1</span><br><span class="line">      Force the use of HTTP/1.1 for all operations (DEPRECIATED)</span><br><span class="line">  --force-http-2</span><br><span class="line">      Force the use of HTTP/2 for all operations where applicable</span><br><span class="line">  --get-O365-drive-id ARG</span><br><span class="line">      Query and return the Office 365 Drive ID for a given Office 365 SharePoint Shared Library</span><br><span class="line">  --get-file-link ARG</span><br><span class="line">      Display the file link of a synced file</span><br><span class="line">  --help -h</span><br><span class="line">      This help information.</span><br><span class="line">  --local-first</span><br><span class="line">      Synchronize from the local directory source first, before downloading changes from OneDrive.</span><br><span class="line">  --log-dir ARG</span><br><span class="line">      Directory where logging output is saved to, needs to end with a slash.</span><br><span class="line">  --logout</span><br><span class="line">      Logout the current user</span><br><span class="line">  --min-notify-changes ARG</span><br><span class="line">      Minimum number of pending incoming changes necessary to trigger a desktop notification</span><br><span class="line">  --monitor -m</span><br><span class="line">      Keep monitoring for local and remote changes</span><br><span class="line">  --monitor-fullscan-frequency ARG</span><br><span class="line">      Number of sync runs before performing a full local scan of the synced directory</span><br><span class="line">  --monitor-interval ARG</span><br><span class="line">      Number of seconds by which each sync operation is undertaken when idle under monitor mode.</span><br><span class="line">  --monitor-log-frequency ARG</span><br><span class="line">      Frequency of logging in monitor mode</span><br><span class="line">  --no-remote-delete</span><br><span class="line">      Do not delete local file &#x27;deletes&#x27; from OneDrive when using --upload-only</span><br><span class="line">  --print-token</span><br><span class="line">      Print the access token, useful for debugging</span><br><span class="line">  --remove-directory ARG</span><br><span class="line">      Remove a directory on OneDrive - no sync will be performed.</span><br><span class="line">  --resync</span><br><span class="line">      Forget the last saved state, perform a full sync</span><br><span class="line">  --single-directory ARG</span><br><span class="line">      Specify a single local directory within the OneDrive root to sync.</span><br><span class="line">  --skip-dir</span><br><span class="line">      Skip any directories that match this pattern from syncing</span><br><span class="line">  --skip-dot-files</span><br><span class="line">      Skip dot files and folders from syncing</span><br><span class="line">  --skip-file ARG</span><br><span class="line">      Skip any files that match this pattern from syncing</span><br><span class="line">  --skip-size</span><br><span class="line">      Skip new files larger than this size (in MB)</span><br><span class="line">  --skip-symlinks</span><br><span class="line">      Skip syncing of symlinks</span><br><span class="line">  --source-directory ARG</span><br><span class="line">      Source directory to rename or move on OneDrive - no sync will be performed.</span><br><span class="line">  --sync-root-files</span><br><span class="line">      Sync all files in sync_dir root when using sync_list.</span><br><span class="line">  --syncdir ARG</span><br><span class="line">      Specify the local directory used for synchronization to OneDrive</span><br><span class="line">  --synchronize</span><br><span class="line">      Perform a synchronization</span><br><span class="line">  --upload-only</span><br><span class="line">      Only upload to OneDrive, do not sync changes from OneDrive locally</span><br><span class="line">  --user-agent ARG</span><br><span class="line">      Specify a User Agent string to the http client</span><br><span class="line">  --verbose -v+</span><br><span class="line">      Print more details, useful for debugging (repeat for extra debugging)</span><br><span class="line">  --version</span><br><span class="line">      Print the version and exit</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Onedrive同步</tag>
      </tags>
  </entry>
  <entry>
    <title>linux无root权限编译安装tmux到用户目录下</title>
    <url>/2020/06/03/linux%E6%97%A0root%E6%9D%83%E9%99%90%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85tmux%E5%88%B0%E7%94%A8%E6%88%B7%E7%9B%AE%E5%BD%95%E4%B8%8B/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://blog.csdn.net/bdss58/article/details/72962896">Linux在当前（指定）用户下安装软件</a></li>
<li><a href="https://blog.csdn.net/zw__chen/article/details/101603526">Ubuntu 源码编译安装tmux指定版本于用户目录</a></li>
<li><a href="https://www.jianshu.com/p/da92ca36a220">无root权限下解决编译时的依赖问题</a></li>
</ol>
<h2 id="下载源码及依赖"><a href="#下载源码及依赖" class="headerlink" title="下载源码及依赖"></a>下载源码及依赖</h2><p>tmux源码地址:<a href="https://github.com/tmux/tmux">https://github.com/tmux/tmux</a> 依赖(Dependencies) - libevent 2.x源码地址:<a href="https://github.com/libevent/libevent">https://github.com/libevent/libevent</a> - ncurses 源码地址:<a href="https://invisible-mirror.net/archives/ncurses/">https://invisible-mirror.net/archives/ncurses/</a> 使用wget下载源码的示例命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://github.com/tmux/tmux/releases/download/3.1b/tmux-3.1b.tar.gz</span><br><span class="line">wget https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz</span><br><span class="line">wget https://invisible-mirror.net/archives/ncurses/ncurses-6.0.tar.gz</span><br></pre></td></tr></table></figure>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>参考<a href="https://blog.csdn.net/zw__chen/article/details/101603526">资料2</a>编译即可. 编译常见三部曲为<code>./configure --prefix=$HOME/usr &amp;&amp; make &amp;&amp; make install</code>，其中<code>./configure</code>设置尤为重要. 因为无root权限，所以需要使用<code>prefix</code>选项改变安装位置</p>
<ol>
<li>安装依赖libevent</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf libevent-2.1.11-stable.tar.gz</span><br><span class="line">cd libevent-2.1.11-stable</span><br><span class="line">./configure --prefix=$HOME/.local --disable-shared</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<ol>
<li>安装依赖ncurses</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf ncurses-6.0.tar.gz</span><br><span class="line">cd ncurses-6.0</span><br><span class="line">./configure --prefix=$HOME/.local</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>编译过程会出现错误，参考<a href="https://blog.csdn.net/zw__chen/article/details/101603526">资料2</a>解决即可. <code>大约是在104行，去除104行后面的注释。即：删除/* generated */</code></p>
<ol>
<li>安装tmux</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf tmux-3.1b.tar.gz</span><br><span class="line">cd tmux-3.1b</span><br></pre></td></tr></table></figure>
<p>tmux依赖于libevent和ncurses，需设置编译选项 编译有关的环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 编译器</span><br><span class="line">CC          指定C编译器(compiler command)路径</span><br><span class="line">CXX         指定C++编译器</span><br><span class="line"># 编译器选项</span><br><span class="line">CFLAGS      用于C编译器的选项</span><br><span class="line">CXXFLAGS    用于C++编译器的选项</span><br><span class="line">LDFLAGS     链接相关选项,如果你有自定义的函数库(lib dir)，即可以用 -L&lt;lib dir&gt;指定</span><br><span class="line"># 预编译器</span><br><span class="line">CXXCPP      C++ 预处理器(preprocessor)</span><br><span class="line">CPP         C 预处理器(preprocessor)</span><br><span class="line"># 预编译器选项</span><br><span class="line">CPPFLAGS    C/C++预处理器选项, 如果你自定义的头文件，可以用-I&lt;include dir&gt;</span><br></pre></td></tr></table></figure>
<p>tmux的编译选项设置可参考<a href="https://blog.csdn.net/zw__chen/article/details/101603526">资料2</a>和<a href="https://www.jianshu.com/p/da92ca36a220">资料3</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd tmux-3.1b</span><br><span class="line">./configure CFLAGS=&quot;-I$HOME/.local/include -I$HOME/.local/include/ncurses&quot; LDFLAGS=&quot;-L$HOME/.local/lib -L$HOME/.local/include/ncurses -L$HOME/.local/include&quot; CPPFLAGS=&quot;-I$HOME/.local/include -I$HOME/.local/include/ncurses&quot; LDFLAGS=&quot;-static -L$HOME/.local/include -L$HOME/.local/include/ncurses -L$HOME/.local/lib&quot; </span><br><span class="line">make</span><br><span class="line">cp tmux $HOME/.local/bin</span><br></pre></td></tr></table></figure>
<ol>
<li>添加环境变量</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 用vim修改.bashrc，在文件中添加一行export PATH=&quot;$HOME/.local/bin:$PATH&quot;,保证每次都有效</span><br><span class="line">export PATH=&quot;$HOME/.local/bin:$PATH&quot;</span><br><span class="line">source ～/.bashrc</span><br></pre></td></tr></table></figure>
<p>这样就完成了tmux的编译安装，下一篇博文将介绍如何使用tmux.</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>tmux</tag>
        <tag>编译软件</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac终端走ssr代理</title>
    <url>/2019/11/03/mac%E7%BB%88%E7%AB%AF%E8%B5%B0ssr%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>系统开启了ssr代理，浏览器可以正常访问，但终端下使用wget， brew等命令下载某些资源仍然速度很慢或没速度。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>参考<a href="https://double-c.github.io/2018/10/17/mac-ss-cmd/index.html">博客</a>。</p>
<ol>
<li>privoxy 安装</li>
</ol>
<p>用brew安装 <code>brew install privoxy</code></p>
<ol>
<li>privoxy 配置</li>
</ol>
<p>配置文件位置在：<code>/usr/local/etc/privoxy/config</code> 使用vim编辑，命令：<code>vim /usr/local/etc/privoxy/config</code>。 在文件最后加入以下两行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">listen-address 0.0.0.0:8118</span><br><span class="line">forward-socks5 / localhost:1080 .</span><br></pre></td></tr></table></figure>
<ol>
<li><p>启动 privoxy 启动命令 <code>sudo /usr/local/sbin/privoxy /usr/local/etc/privoxy/config</code>。 如果指示错误<code>/usr/local/sbin/provoxy</code>不是命令，可以参照<a href="https://apple.stackexchange.com/questions/312330/brew-link-unbound-returns-usr-local-sbin-is-not-writable-error">此处</a>解决。 首先再次安装<code>brew install privoxy</code>，然后它会提示已存在，用brew命令关联这个版本<code>brew link privoxy</code>，又出现新的错误<code>Error: Could not symlink sbin/privoxy /usr/local/sbin is not writable.</code>解决方法在给出的链接的回答中给出来了，新建一个文件夹并修改权限<code>if [ ! -d /usr/local/sbin ]; then sudo mkdir /usr/local/sbin; fi &amp;&amp; sudo chmod 777 /usr/local/sbin</code>。再次执行命令<code>brew link privoxy</code>,<code>sudo /usr/local/sbin/privoxy /usr/local/etc/privoxy/config</code>即可。</p>
</li>
<li><p>查看是否启动成功</p>
</li>
</ol>
<p><code>netstat -na grep 8118</code></p>
<ol>
<li>使用</li>
</ol>
<p>- 临时使用： 在终端中输入命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export http_proxy=&#x27;http://localhost:8118&#x27;</span><br><span class="line">export https_proxy=&#x27;http://localhost:8118&#x27;</span><br></pre></td></tr></table></figure>
<p>不想使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unset http_proxy</span><br><span class="line">unset https_proxy</span><br></pre></td></tr></table></figure>
<p>关闭终端需要重新执行上面的两条命令 - 永久使用 将上面上行代码添加到<code>~/.bash_profile</code>文件最后，然后执行<code>source ~/.bash_profile</code></p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
  </entry>
  <entry>
    <title>Numpy，Opencv及PIL.Image 格式相互转换</title>
    <url>/2020/02/03/numpy%EF%BC%8Copencv%E5%8F%8Aipl-image-%E6%A0%BC%E5%BC%8F%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://blog.csdn.net/qq_31261509/article/details/94383575">Python OpenCV中的numpy与图像类型转换</a> </li>
<li><a href="https://github.com/llSourcell/Object_Detection_demo_LIVE/issues/6">解决ndarray的类型错误</a> </li>
<li><a href="https://blog.csdn.net/qq_19707521/article/details/78367617">Python OpenCV格式和PIL.Image格式 互转</a></li>
<li><a href="https://www.jianshu.com/p/706086c1b8ba">python模块 opencv-python与PIL.Image图像常用方法与相互转换</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/87441580">OpenCV读取图片与PIL读取图片的差别</a></li>
<li><a href="https://blog.csdn.net/JohinieLi/article/details/81012572">python中PIL.Image，OpenCV，Numpy图像格式相互转换</a> </li>
<li><a href="https://blog.csdn.net/tsq292978891/article/details/78767326">PIL.Image和np.ndarray图片与Tensor之间的转换</a></li>
</ol>
<h2 id="Numpy与Opencv格式互转"><a href="#Numpy与Opencv格式互转" class="headerlink" title="Numpy与Opencv格式互转"></a>Numpy与Opencv格式互转</h2><p>参照<a href="https://blog.csdn.net/qq_31261509/article/details/94383575">资料1</a></p>
<blockquote>
<p>Python OpenCV存储图像使用的是Numpy存储，所以可以将Numpy当做图像类型操作，操作之前还需进行类型转换，转换到int8类型</p>
</blockquote>
<p>对Opencv存储的图像格式进行验证</p>
<ul>
<li><strong>输入：</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">numpy与Opencv图像类型的转换</span></span><br><span class="line"><span class="string">&gt; Python OpenCV存储图像使用的是Numpy存储，所以可以将Numpy当做图像类型操作，操作之前还需进行类型转换，转换到int8类型</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;./Messi.jpg&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;shape:&quot;</span> + <span class="built_in">str</span>(img.shape))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(img)) <span class="comment">#数据类型显示为numpy.ndarray</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>输出：</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shape:(500, 500, 3)</span><br><span class="line">&lt;class &#x27;numpy.ndarray&#x27;&gt;</span><br></pre></td></tr></table></figure>
<p>存储类型为numpy.ndarray，这是否表明numpy与Opencv可以直接互操作呢？答案是否定的。因为图像存放时，每个像素值都是非负的，并且取值范围受限于存储位数的限制，所以将numpy.ndarray存储为图像格式，需要先将其进行类型转换。</p>
<ul>
<li><strong>输入：</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array = np.ones([<span class="number">20</span>, <span class="number">30</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;shape:&quot;</span> + <span class="built_in">str</span>(array.shape))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(array)) <span class="comment">#数据类型显示numpy.ndarray 与Opencv图像类型格式相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以将ndarray作为Opencv图片进行处理，但在处理之前一般进行类型转换</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">类型转换时需注意，我参照博客转成int8类型，可以写入，但是单通道转多通道会出错</span></span><br><span class="line"><span class="string">Assertion failed) VScn::contains(scn) &amp;&amp; VDcn::contains(dcn) &amp;&amp; VDepth::contains(depth) in function &#x27;CvtHelper&#x27;</span></span><br><span class="line"><span class="string">参照github是类型错误导致的</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">array = np.uint8(array)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;shape:&quot;</span> + <span class="built_in">str</span>(array.shape))</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;test.jpg&#x27;</span>, array)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类型转换</span></span><br><span class="line">array = cv2.cvtColor(array, cv2.COLOR_GRAY2BGR)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;shape:&quot;</span> + <span class="built_in">str</span>(array.shape))</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;test2.jpg&#x27;</span>, array)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>输出：</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shape:(20, 30)</span><br><span class="line">&lt;class &#x27;numpy.ndarray&#x27;&gt;</span><br><span class="line">shape:(20, 30)</span><br><span class="line">shape:(20, 30, 3)</span><br></pre></td></tr></table></figure>
<p>正如注释所写，类型转换时，要注意，我参照<a href="https://blog.csdn.net/qq_31261509/article/details/94383575">资料1</a>转为int8，在通道转换时出现了错误<strong>Assertion failed) VScn::contains(scn) &amp;&amp; VDcn::contains(dcn) &amp;&amp; VDepth::contains(depth) in function ‘CvtHelper’</strong>，参照<a href="https://github.com/llSourcell/Object_Detection_demo_LIVE/issues/6">资料2</a>进行解决。</p>
<h2 id="IPL-Image与Opencv相互转换"><a href="#IPL-Image与Opencv相互转换" class="headerlink" title="IPL.Image与Opencv相互转换"></a>IPL.Image与Opencv相互转换</h2><p>先复习一下Opencv与IPL.Image的读，写，显示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Opencv 图像的读，写，显示</span></span><br><span class="line"><span class="string">PIL.Image的读，写，显示</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Opencv读</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;Messi.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># Opencv写</span></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;Messi2.jpg&#x27;</span>, img)</span><br><span class="line"><span class="comment"># Opencv显示</span></span><br><span class="line">cv2.imshow(<span class="string">&#x27;Messi&#x27;</span>, img)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># PIL.Image读</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&#x27;Messi.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># PIL.Image写</span></span><br><span class="line">img.save(<span class="string">&#x27;Messi3.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># PIL.Image显示</span></span><br><span class="line">img.show()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Image.open()读取的通道顺序是RGB，cv2.imread()读取的通道顺序为BGR。 Image.open()函数只是保持了图像被读取的状态，但是图像的真实数据并未被读取，因此如果对需要操作图像每个元素，如输出某个像素的RGB值等，需要执行对象的load()方法读取数据 PIL.Image.save()直接保存RGB的图片 cv2.imwirte()保存图片的时候相当于做了BGR2RGB再去保存</p>
</blockquote>
<p><strong>OpenCV转换成PIL.Image格式</strong></p>
<ul>
<li><strong>代码：</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line"><span class="keyword">import</span> numpy </span><br><span class="line">img = cv2.imread(<span class="string">&quot;Messi.jpg&quot;</span>)</span><br><span class="line">cv2.imshow(<span class="string">&quot;OpenCV&quot;</span>,img)</span><br><span class="line">Image.fromarray(cv2.cvtColor(img,cv2.COLOR_BGR2RGB))  </span><br></pre></td></tr></table></figure>
<p><strong>PIL.Image转换成OpenCV格式：</strong></p>
<ul>
<li><strong>代码：</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line"><span class="keyword">import</span> numpy  </span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">&quot;Messi.jpg&quot;</span>)  </span><br><span class="line">img = cv2.cvtColor(numpy.asarray(image),cv2.COLOR_RGB2BGR)</span><br></pre></td></tr></table></figure>
<h2 id="PIL-Image与Numpy格式的相互转换"><a href="#PIL-Image与Numpy格式的相互转换" class="headerlink" title="PIL.Image与Numpy格式的相互转换"></a>PIL.Image与Numpy格式的相互转换</h2><p>相当于 Opencv与PIL.Image的相互转换少了通道的变换。</p>
<ul>
<li><strong>Numpy转PIL.Image</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line"><span class="keyword">import</span> numpy </span><br><span class="line">array = np.ones(<span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">Image.fromarray(array)  </span><br></pre></td></tr></table></figure>
<ul>
<li><strong>PIL.Image转Numpy</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy </span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">&quot;Messi.jpg&quot;</span>)</span><br><span class="line">array = numpy.asarray(image)</span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>参考<a href="https://blog.csdn.net/JohinieLi/article/details/81012572">资料6</a></p>
<h3 id="list与tuple转换"><a href="#list与tuple转换" class="headerlink" title="list与tuple转换"></a>list与tuple转换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]<span class="comment">#a is a list</span></span><br><span class="line">b = <span class="built_in">tuple</span>(a) <span class="comment"># b is a tuple</span></span><br><span class="line">c = <span class="built_in">list</span>(b) <span class="comment"># c is a list</span></span><br></pre></td></tr></table></figure>
<h3 id="list-tuple-ndarray转换"><a href="#list-tuple-ndarray转换" class="headerlink" title="list,tuple,ndarray转换"></a>list,tuple,ndarray转换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment"># a is a list</span></span><br><span class="line">arr = np.array(a) <span class="comment"># arr is a ndarray</span></span><br><span class="line">b = <span class="built_in">tuple</span>(arr) <span class="comment"># b is a tuple</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)<span class="comment"># a is a tuple</span></span><br><span class="line">arr = np.arr(a) <span class="comment"># arr is a ndarray</span></span><br><span class="line">b = <span class="built_in">list</span>(arr) <span class="comment"># b is a list</span></span><br></pre></td></tr></table></figure>
<h3 id="torch的tensor与numpy转换"><a href="#torch的tensor与numpy转换" class="headerlink" title="torch的tensor与numpy转换"></a>torch的tensor与numpy转换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tensor 转numpy</span></span><br><span class="line">array = a.numpy() <span class="comment"># a is a tensor</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy 转tensor</span></span><br><span class="line">torch.from_numpy(array) <span class="comment"># array is a ndarray</span></span><br></pre></td></tr></table></figure>
<h3 id="tensor与PIL-image转换"><a href="#tensor与PIL-image转换" class="headerlink" title="tensor与PIL image转换"></a>tensor与PIL image转换</h3><p>pytorch官方提供了<code>torchvision.transforms</code>包,可以用<code>transforms</code>来实现tensor 与PIL image的转换</p>
<blockquote>
<p>ToTensor把一个取值范围是[0,255]的PIL.Image或者shape为(H,W,C)的numpy.ndarray，转换成形状为[C,H,W]，取值范围是[0,1.0]的torch.FloadTensor</p>
</blockquote>
<ul>
<li>tensor与PIL image的转换</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># PIL Image转tensor</span></span><br><span class="line"></span><br><span class="line">transform1 = transforms.Compose([</span><br><span class="line">    <span class="keyword">pass</span>, <span class="comment"># 这里可以写对PIL的相关操作（裁剪，旋转等）</span></span><br><span class="line">    transforms.ToTensor(), </span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line">img_PIL = Image.<span class="built_in">open</span>(<span class="string">&#x27;test.jpg&#x27;</span>).convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line">img_PIL_tensor = transform1(img_PIL)<span class="comment"># 将PIL image转为tensor</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(img_PIL))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(img_PIL_tensor))</span><br><span class="line"></span><br><span class="line"><span class="comment"># transforms也提供了tensor转PIL image的方法</span></span><br><span class="line">new_img_PIL = transforms.ToPILImage()(img_PIL_Tensor).convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line"></span><br><span class="line">transform2 = transforms.Compose([</span><br><span class="line">    <span class="keyword">pass</span>, <span class="comment"># transform没有对Opencv的相关操作（裁剪，旋转等）</span></span><br><span class="line">    transforms.ToTensor(), </span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">img_Opencv = cv2.imread(<span class="string">&#x27;test&#x27;</span>.jpg)</span><br><span class="line">img_Opencv_tensor = transform2(img_Opencv)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
        <tag>Opencv</tag>
        <tag>PIL.Image</tag>
        <tag>tensor</tag>
      </tags>
  </entry>
  <entry>
    <title>python调试工具 -- pdb</title>
    <url>/2020/03/03/python%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7-pdb/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://docs.python.org/zh-cn/3/library/pdb.html">官方文档</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/37294138">10分钟教程掌握Python调试器pdb</a></li>
<li><a href="https://juejin.im/post/5ce2bfb5e51d455070226ef5">Python 必备 debug 神器：pdb</a></li>
<li><a href="https://www.jianshu.com/p/1c2212fc28a6">PDB——Python调试利器详解</a></li>
</ol>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>pdb是python的内置模块，类似c++中的gdb的存在，可用于在命令行中对代码进行调试。</p>
<h2 id="进入调试"><a href="#进入调试" class="headerlink" title="进入调试"></a>进入调试</h2><ol>
<li>修改代码</li>
</ol>
<blockquote>
<p>The typical usage to break into the debugger from a running program is to insert at the location you want to break into the debugger.</p>
</blockquote>
<p>在需要调试的位置插入以下代码，运行的时候，会在插入位置停止进入调试模式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line">pdb.set_trace()</span><br></pre></td></tr></table></figure>
<ol>
<li>脚本执行调试</li>
</ol>
<blockquote>
<p>pdb.py can also be invoked as a script to debug other scripts</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># myscript.py为要调试的程序</span></span><br><span class="line">python3 -m pdb myscript.py</span><br></pre></td></tr></table></figure>
<p>推荐使用方法2，重要的是不会添加额外的代码污染代码，更加灵活。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>命令</p>
<p>功能</p>
<p><strong>_断点有关的命令_</strong></p>
<p><strong>b(break)</strong></p>
<p>查看已设的所有断点</p>
<p><strong>b no</strong></p>
<p>设置断点，no是断点所在的行号</p>
<p><strong>b filename:no</strong></p>
<p>将断点添加到某个文件中</p>
<p><strong>b funcname</strong></p>
<p>为函数funcname的第一行设置断点</p>
<p><strong>tbreak(break)</strong></p>
<p>同b，临时断点，执行一次自动清除</p>
<p><strong>tbreak no</strong></p>
<p>略</p>
<p><strong>tbeak filename:no</strong></p>
<p>略</p>
<p><strong>tbreak funcname</strong></p>
<p>略</p>
<p><strong>disable bno</strong></p>
<p>禁用指定序号断点，但未删除</p>
<p><strong>enable bno</strong></p>
<p>启用指定序号断点</p>
<p><strong>cl</strong></p>
<p>清除所有断点(包括临时断点)</p>
<p><strong>cl bno1[bno2 ……]</strong></p>
<p>清除指定序号的断点，多个用空格分隔</p>
<p><strong>cl filename:no</strong></p>
<p>清除某文件所在行号的断点</p>
<p><strong>_调试相关的命令_</strong></p>
<p><strong>s(step)</strong></p>
<p>执行下一句，遇到函数会进入到函数内部执行</p>
<p><strong>n(next)</strong></p>
<p>执行下一句，不会进入函数</p>
<p><strong>r(return)</strong></p>
<p>执行当前所在函数的返回处</p>
<p><strong>c(continue)</strong></p>
<p>执行到下一个断点处</p>
<p><strong>unt(until)</strong></p>
<p>退出当前循环或堆栈，遇到断点会停止</p>
<p><strong>unt no</strong></p>
<p>执行到指定行号处停止</p>
<p><strong>_查看代码或变量值_</strong></p>
<p><strong>l(list)</strong></p>
<p>列出当前执行行周围的11行代码</p>
<p><strong>l no</strong></p>
<p>列出指定行号周围的11行代码</p>
<p><strong>l no1 no2</strong></p>
<p>列出no1 no2间的行号</p>
<p><strong>ll</strong></p>
<p>列出所有代码</p>
<p><strong>p exp</strong></p>
<p>打印某变量或表达式的值</p>
<p><strong>pp exp</strong></p>
<p>好看一点打印某变量或表达式的值</p>
<p><strong>a</strong></p>
<p>查看所在函数的参数与参数值</p>
<p><strong>what is var</strong></p>
<p>查看变量的类型</p>
<p><strong>_其它_</strong></p>
<p><strong>restart</strong></p>
<p>重新运行</p>
<p><strong>run</strong></p>
<p>类似restart</p>
<p><strong>q(quit)</strong></p>
<p>退出调试</p>
<p><strong>interact</strong></p>
<p>启动一个python的交互式解释器，使用当前代码的全局命名空间 ctrl + d退出</p>
]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
  </entry>
  <entry>
    <title>pytorch:CUDA out of memory</title>
    <url>/2020/05/20/pytorchcuda-out-of-memory/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://blog.csdn.net/pursuit_zhangyu/article/details/88717635">CSDN - pytorch出现RuntimeError: CUDA out of memory.</a></li>
<li><a href="https://ptorch.com/news/160.html">pytorch模型提示超出内存cuda runtime error(2): out of memory</a></li>
</ol>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol>
<li>最容易想到的就是调小batch size</li>
<li>在测试时，不需要更新模型了，使用torch.no_grad()</li>
<li>参考<a href="https://ptorch.com/news/160.html">资料2</a> 我的问题是调小batch_size，正常的第1个epoch不会出错，而训练第2个epoch一开始，出现了<code>CUDA out of memory</code>。解决方法参考资料2的前2条，实测有效。</li>
</ol>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
  </entry>
  <entry>
    <title>pytorch入门</title>
    <url>/2020/01/26/pytorch%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>参考<a href="https://pytorch.org/tutorials/">PyTorch官方教程中文版</a></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>支持GPU，灵活，支持动态神经网络，底层代码易于理解，命令式体验。</p>
<h2 id="张量-tensor-学习"><a href="#张量-tensor-学习" class="headerlink" title="张量(tensor)学习"></a>张量(tensor)学习</h2><p>具体用法参照<a href="https://pytorch.org/docs">官方文档</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="comment"># 构造一个5x3矩阵，不初始化。</span></span><br><span class="line">x = torch.empty((<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/ed20c4059b7d2876b35477dbae98c0cc.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构造一个随机初始化的矩阵</span></span><br><span class="line">x = torch.rand((<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/d843b2cb1db05d0a87f8acae961e95ab.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构造一个填充某个值的矩阵</span></span><br><span class="line">x = torch.full((<span class="number">5</span>, <span class="number">3</span>), <span class="number">3.1415</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/3df9c44f3e392ed46360000226f7298f.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构造全为0的矩阵，且数据类型为long</span></span><br><span class="line">x = torch.zeros((<span class="number">5</span>, <span class="number">3</span>), dtype = torch.long)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/214502b926fc8897cb2b225601a1539c.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构造单位矩阵</span></span><br><span class="line"><span class="comment"># torch.eye(n, m=None, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor</span></span><br><span class="line"><span class="comment"># Returns a 2-D tensor with ones on the diagonal and zeros elsewhere.</span></span><br><span class="line">torch.eye(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/3de040933ac1e2449b838670d0f3828a.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用数据构造一个张量</span></span><br><span class="line">x = torch.tensor([<span class="number">5.5</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/80e290544e3258d4747a981c07ffc1c6.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用已经存在的tensor构造一个tensor</span></span><br><span class="line">x = x.new_ones((<span class="number">5</span>, <span class="number">3</span>), dtype = torch.double)</span><br><span class="line"><span class="comment"># new_* methods take in sizes</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">x = torch.randn_like(x, dtype = torch.<span class="built_in">float</span>)</span><br><span class="line"><span class="comment"># size和原x的size相同，但数据类型不同</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/c88c5035e16c81a04070fb3fde64b4bb.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取维度信息 size()</span></span><br><span class="line"><span class="built_in">print</span>(x.size())</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/da1e8247bfaf5fbf426c836b02a379dd.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加法1 +</span></span><br><span class="line">y = torch.rand(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(x + y)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/8908dce0053d4a9e7349700e1ae46e95.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加法2 torch.add</span></span><br><span class="line"><span class="comment"># torch.add(input, alpha=1, other, out=None)</span></span><br><span class="line"><span class="comment"># Each element of the tensor other is multiplied by the scalar alpha and added to each element of the tensor input. The resulting tensor is returned.</span></span><br><span class="line"><span class="built_in">print</span>(torch.add(x, y))</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/44d8b9299f68ef1623e0c4a3028a41aa.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提供一个输出tensor作为参数</span></span><br><span class="line">result = torch.empty((<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line">torch.add(x, y, out = result)</span><br><span class="line"><span class="built_in">print</span>(x + y)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/be5c19b1d4267bee2ee93ebcf78045f0.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add x to y  (in-place)</span></span><br><span class="line"><span class="comment"># 即将x+y的值赋给y</span></span><br><span class="line"><span class="comment"># 任何使张量会发生变化的操作都有一个前缀</span></span><br><span class="line">y.add_(x)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/3c954a7cf80df393c107c27f6797a5da.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 改变大小：如果你想改变一个 tensor 的大小或者形状，你可以使用 torch.view:</span></span><br><span class="line"></span><br><span class="line">x = torch.randn(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">y = x.view(<span class="number">16</span>)</span><br><span class="line">z = x.view(-<span class="number">1</span>, <span class="number">8</span>)  <span class="comment"># the size -1 is inferred from other dimensions</span></span><br><span class="line"><span class="built_in">print</span>(x.size(), y.size(), z.size())</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/7fdd67d05badaa78ee6bb1cf9f51f2ba.png" alt=""></p>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
  </entry>
  <entry>
    <title>Pytorch对两张图片进行相同的数据增广操作</title>
    <url>/2020/02/16/pytorch%E5%AF%B9%E4%B8%A4%E5%BC%A0%E5%9B%BE%E7%89%87%E8%BF%9B%E8%A1%8C%E7%9B%B8%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%B9%BF%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://dingguanglei.com/pytorch/">个人博客 - Pytorch同时对输入输出使用transform</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/95680105">知乎 - 4个例子让你的pytorch数据增强过程不随机</a></li>
<li><a href="https://blog.csdn.net/liangdong2014/article/details/83339444">CSDN - Tensorflow如何对两幅图像做同样的数据增广操作</a></li>
<li><a href="https://pytorch.org/docs/stable/torchvision/transforms.html?highlight=torchvision%20transforms%20functional#module-torchvision.transforms.functional">Pytorch官方文档 - torchvision.transforms.functional</a></li>
</ol>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>原始的人脸表情识别训练过程中，对于每张输入的图片，都有一个表情标签与之对应（这里只考虑单标签）。可以直接使用<code>torchvision.transform</code>中的<code>transforms.RandomCrop</code>、<code>transforms.RandomHorizontalFlip</code>、<code>transforms.RandomRotation</code>等对图片进行随机操作，从而实现对数据的增广操作，提高模型的泛化能力。 但在人脸表情识别中引入<strong>Attention</strong>机制后，对于每张输入图片，则对应一个脸部分割的概率图。在对原始图片进行<code>transform</code>的变换时，与之对应的脸部分割图mask应与之进行相同的变化。但是上面提到的所有操作都是随机操作，涉及一个随机值。所以，无法做到输入与mask进行相同的<code>transform</code>。所以，决定放弃使用数据增广的操作，而是直接使用的是原图，训练过程中出现train的准确率不断上升，最后达到100%，而test的准确率则开始是上升，中间出现波动。最后开始下降。很显然，模型过拟化。为了解决这个问题，相当于解决如何用Pytorch对两张图片进行相同的数据增广操作的问题？</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><blockquote>
<p>在pytorch文档上可以看到，除了torchvision.transform 还有torchvision.transforms.functional。 相比transform ，transforms.functional 更加灵活，该方法只提供了图像的增强变换功能，而并没有随机部分</p>
</blockquote>
<p>引用自<a href="https://dingguanglei.com/pytorch/">资料1</a> 实际上是用<strong>torchvision.transforms.functional</strong>中提供的函数（都没有引入随机性），来自定义<code>transform</code>函数。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>原图及脸部分割mask如图所求 <img src="/images/2020/02/a224c83a16ac9de23a6d622063e8274f.png" alt=""> <img src="/images/2020/02/cc8c79c6d866801fab0a166386706afe.png" alt=""> 然后对图片同时进行随机旋转和翻转，代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms.functional <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_transform1</span>(<span class="params">image, mask</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 拿到角度的随机数。angle是一个-180到180之间的一个数</span></span><br><span class="line">        angle = transforms.RandomRotation.get_params([-<span class="number">180</span>, <span class="number">180</span>])</span><br><span class="line">        <span class="comment"># 对image和mask做相同的旋转操作，保证他们都旋转angle角度</span></span><br><span class="line">        image = image.rotate(angle)</span><br><span class="line">        mask = mask.rotate(angle)</span><br><span class="line"></span><br><span class="line">        image = tf.to_tensor(image)</span><br><span class="line">        mask = tf.to_tensor(mask)</span><br><span class="line">        <span class="keyword">return</span> image, mask</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_transform2</span>(<span class="params">image, mask</span>):</span><br><span class="line">    <span class="comment"># 50%的概率应用垂直，水平翻转。</span></span><br><span class="line">    <span class="keyword">if</span> random.random() &gt; <span class="number">0.5</span>:</span><br><span class="line">        image = tf.hflip(image)</span><br><span class="line">        mask = tf.hflip(mask)</span><br><span class="line">    <span class="keyword">if</span> random.random() &gt; <span class="number">0.5</span>:</span><br><span class="line">        image = tf.vflip(image)</span><br><span class="line">        mask = tf.vflip(mask)</span><br><span class="line">    image = tf.to_tensor(image)</span><br><span class="line">    mask = tf.to_tensor(mask)</span><br><span class="line">    <span class="keyword">return</span> image, mask</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_transform3</span>(<span class="params">image, mask</span>):</span><br><span class="line">    <span class="comment"># 随机裁剪</span></span><br><span class="line">    i, j, h, w = transforms.RandomResizedCrop.get_params(</span><br><span class="line">    image, scale=(<span class="number">0.7</span>, <span class="number">1.0</span>), ratio=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    image = tf.resized_crop(image, i, j, h, w, <span class="number">48</span>)</span><br><span class="line">    mask = tf.resized_crop(mask, i, j, h, w, <span class="number">48</span>)</span><br><span class="line">    image = tf.to_tensor(image)</span><br><span class="line">    mask = tf.to_tensor(mask)</span><br><span class="line">    <span class="keyword">return</span> image, mask</span><br><span class="line"></span><br><span class="line"><span class="comment"># transform处理对象一般都是 PIL Image</span></span><br><span class="line"></span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">&#x27;./0.jpg&#x27;</span>) <span class="comment"># 原图</span></span><br><span class="line">mask = Image.<span class="built_in">open</span>(<span class="string">&#x27;./0_seg_face.jpg&#x27;</span>) <span class="comment"># mask</span></span><br><span class="line"></span><br><span class="line">image_tensor, mask_tensor = my_transform1(image, mask)</span><br><span class="line"></span><br><span class="line"><span class="comment">#此时image, mask为tensor,需转成PIL Image</span></span><br><span class="line">image_rotate = transforms.ToPILImage()(image_tensor).convert(<span class="string">&#x27;L&#x27;</span>).save(<span class="string">&#x27;0_rotate.jpg&#x27;</span>)</span><br><span class="line">mask_rotate = transforms.ToPILImage()(mask_tensor).convert(<span class="string">&#x27;L&#x27;</span>).save(<span class="string">&#x27;0_seg_face_rotate.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">image_tensor, mask_tensor = my_transform2(image, mask)</span><br><span class="line"></span><br><span class="line"><span class="comment">#此时image, mask为tensor,需转成PIL Image</span></span><br><span class="line">image_flip = transforms.ToPILImage()(image_tensor).convert(<span class="string">&#x27;L&#x27;</span>).save(<span class="string">&#x27;0_flip.jpg&#x27;</span>)</span><br><span class="line">mask_flip = transforms.ToPILImage()(mask_tensor).convert(<span class="string">&#x27;L&#x27;</span>).save(<span class="string">&#x27;0_seg_face_flip.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">image_tensor, mask_tensor = my_transform3(image, mask)</span><br><span class="line"></span><br><span class="line"><span class="comment">#此时image, mask为tensor,需转成PIL Image</span></span><br><span class="line">image_crop = transforms.ToPILImage()(image_tensor).convert(<span class="string">&#x27;L&#x27;</span>).save(<span class="string">&#x27;0_crop.jpg&#x27;</span>)</span><br><span class="line">mask_crop = transforms.ToPILImage()(mask_tensor).convert(<span class="string">&#x27;L&#x27;</span>).save(<span class="string">&#x27;0_seg_face_crop.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>旋转后图片为（每次旋转结果可能都不一样，角度随机） <img src="/images/2020/02/488f76c329186d7ec3a42e72f032c942.png" alt=""> <img src="/images/2020/02/88758350925fa2953bc0d0747f61ef3e.png" alt=""> 50%可能性翻转后图片为 <img src="/images/2020/02/462a90f6e8b3e61c13c9a9b30fe88a1f.png" alt=""> <img src="/images/2020/02/2ef457bac586668f6fa9fab7a9a2362b.png" alt=""> 随机裁剪，裁剪后大小为原来的[0.8,1]，长宽比例为1：1，最后并将resize为(48, 48)，图片为： <img src="/images/2020/02/4d13b7f8b17042df1b272f701770e3d9.png" alt=""> <img src="/images/2020/02/3c4bf2f5dbac43a03d95553492fb9bd1.png" alt=""></p>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
        <tag>transform</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch构建神经网络</title>
    <url>/2020/01/27/pytorch%E6%9E%84%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="神经网络的训练过程"><a href="#神经网络的训练过程" class="headerlink" title="神经网络的训练过程"></a>神经网络的训练过程</h2><ol>
<li><p>定义一个包含可训练参数的神经网络</p>
</li>
<li><p>迭代整个输入</p>
</li>
<li><p>通过神经网络处理输入</p>
</li>
<li><p>计算损失(loss)</p>
</li>
<li><p>反向传播梯度到神经网络的参数</p>
</li>
<li><p>更新网络的参数，典型的用一个简单的更新方法：weight = weight - learning_rate *gradient</p>
</li>
</ol>
<h2 id="定义神经网络"><a href="#定义神经网络" class="headerlink" title="定义神经网络"></a>定义神经网络</h2><p>用下面代码可以构建一个典型的神经网络</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(nn.Module):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        <span class="comment"># 1 input image channel, 6 output channels, 5x5 square convolution</span></span><br><span class="line">        <span class="comment"># kernel</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="comment"># an affine operation: y = Wx + b</span></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># Max pooling over a (2, 2) window</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv1(x)), (<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">        <span class="comment"># If the size is a square you can only specify a single number</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv2(x)), <span class="number">2</span>)</span><br><span class="line">        x = x.view(-<span class="number">1</span>, self.num_flat_features(x))</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">num_flat_features</span>(<span class="params">self, x</span>):</span><br><span class="line">        size = x.size()[<span class="number">1</span>:]  <span class="comment"># all dimensions except the batch dimension</span></span><br><span class="line">        num_features = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> size:</span><br><span class="line">            num_features *= s</span><br><span class="line">        <span class="keyword">return</span> num_features</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">net = Net()</span><br><span class="line"><span class="built_in">print</span>(net)</span><br></pre></td></tr></table></figure>
<h3 id="Conv2d"><a href="#Conv2d" class="headerlink" title="Conv2d"></a><a href="https://pytorch.org/docs/stable/nn.html?highlight=nn%20conv2d#torch.nn.Conv2d">Conv2d</a></h3><p><strong>方法原型</strong> <code>torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True, padding_mode=&#39;zeros&#39;)</code> <strong>参数说明</strong> - <code>in_channels</code>:输入图片的通道数 - <code>out_channels</code>:卷积操作后输出图片的通道数 - <code>kernel_size</code>:卷积核的尺寸 - <code>stride</code>:卷积的步长，默认为1 - <code>padding</code>:卷积的padding，默认为0 <code>kernel_size</code>, <code>stride</code>, <code>padding</code>取值可以为<code>a single int</code>或者<code>a tuple of two ints</code>，<code>a single int</code>表示宽和高相同。<code>a tuple of two ints</code>表示第1个为宽的大小，第2个为高的大小。 计算输出图片的尺寸的方法：（dilation的值默认为1） <img src="/images/2020/01/d76f4d4ebdb3f0dcd025121b37833b88.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = nn.Conv2d(<span class="number">16</span>, <span class="number">33</span>, <span class="number">3</span>, stride=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">input</span> = torch.randn(<span class="number">20</span>, <span class="number">16</span>, <span class="number">50</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(m(<span class="built_in">input</span>).size())</span><br><span class="line">m = nn.Conv2d(<span class="number">16</span>, <span class="number">33</span>, (<span class="number">3</span>, <span class="number">5</span>), stride=(<span class="number">2</span>, <span class="number">1</span>), padding=(<span class="number">4</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(m(<span class="built_in">input</span>).size())</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/69e6b29c6990b04ea51ea103b8ebf214.png" alt=""></p>
<h3 id="Linear"><a href="#Linear" class="headerlink" title="Linear"></a><a href="https://pytorch.org/docs/stable/nn.html?highlight=linear#torch.nn.Linear">Linear</a></h3><p><strong>方法原型</strong> <code>torch.nn.Linear(in_features, out_features, bias=True)</code> $y = xW^T + b$ 对传入的数据进行线性变换。 <strong>参数说明</strong> <code>in_features</code>: 每个输入样例的尺寸 <code>out_features</code>:每个输出样例的尺寸 <code>bias</code>:如果设置为<code>False</code>，则不会学习额外的bias参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = nn.Linear(<span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="built_in">input</span> = torch.randn(<span class="number">128</span>, <span class="number">20</span>)</span><br><span class="line">output = m(<span class="built_in">input</span>)</span><br><span class="line"><span class="built_in">print</span>(output.size())</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/241be8826b081a8cdf2b76062e7c65ee.png" alt=""></p>
<h3 id="max-pool2d"><a href="#max-pool2d" class="headerlink" title="max_pool2d"></a><a href="https://pytorch.org/docs/stable/nn.functional.html?highlight=max_pool2d#torch.nn.functional.max_pool2d">max_pool2d</a></h3><p>最大池化 <strong>方法原型</strong> torch.nn.functional.max_pool3d(*args, ** kwargs) 细节参考<a href="https://pytorch.org/docs/stable/nn.html#torch.nn.MaxPool2d">MaxPool2d</a> <code>torch.nn.MaxPool2d(kernel_size, stride=None, padding=0, dilation=1, return_indices=False, ceil_mode=False)</code> <strong>参数说明</strong> 略</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = nn.MaxPool2d(<span class="number">3</span>, stride=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">input</span> = torch.randn(<span class="number">20</span>, <span class="number">16</span>, <span class="number">50</span>, <span class="number">32</span>)</span><br><span class="line">output = m(<span class="built_in">input</span>)</span><br><span class="line"><span class="built_in">print</span>(output.size())</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/89f6d7dd0aa1f5a2117f791de6b3e1f3.png" alt=""></p>
<h3 id="relu"><a href="#relu" class="headerlink" title="relu"></a><a href="https://pytorch.org/docs/stable/nn.functional.html?highlight=relu#torch.nn.functional.relu">relu</a></h3><p><strong>方法原型</strong> <code>torch.nn.functional.relu(input, inplace=False) → Tensor</code> relu激活函数 细节参照<a href="https://pytorch.org/docs/stable/nn.html#torch.nn.ReLU">ReLU</a> $ReLU(x)=max(0,x)$ <img src="/images/2020/01/96ebadd4f0377c4cdb645f3ad0945458.png" alt=""></p>
<h3 id="net-parameters"><a href="#net-parameters" class="headerlink" title="net.parameters()"></a>net.parameters()</h3><p>一个模型可训练的参数可以通过调用 net.parameters() 返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">params = <span class="built_in">list</span>(net.parameters())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(params))</span><br><span class="line"><span class="built_in">print</span>(params[<span class="number">0</span>].size())  <span class="comment"># conv1&#x27;s .weight</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/abb85cb7f85d94c0fc2f84d0a84f9c6a.png" alt=""></p>
<h2 id="计算损失值"><a href="#计算损失值" class="headerlink" title="计算损失值"></a>计算损失值</h2><p>一个损失函数需要一对输入：模型输出和目标，nn包中提供了一些常见的损失函数。其中<code>nn.MSELoss</code>(均方差)是最简单的损失函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算损失值</span></span><br><span class="line">output = net(<span class="built_in">input</span>)</span><br><span class="line">target = torch.randn(<span class="number">10</span>)  <span class="comment"># a dummy target, for example</span></span><br><span class="line">target = target.view(<span class="number">1</span>, -<span class="number">1</span>)  <span class="comment"># make it the same shape as output</span></span><br><span class="line">criterion = nn.MSELoss()</span><br><span class="line"></span><br><span class="line">loss = criterion(output, target)</span><br><span class="line"><span class="built_in">print</span>(loss)</span><br></pre></td></tr></table></figure>
<h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 反向传播前后conv1的偏置项的变化</span></span><br><span class="line">net.zero_grad()     <span class="comment"># zeroes the gradient buffers of all parameters</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;conv1.bias.grad before backward&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(net.conv1.bias.grad)</span><br><span class="line"></span><br><span class="line">loss.backward()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;conv1.bias.grad after backward&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(net.conv1.bias.grad)</span><br></pre></td></tr></table></figure>
<h2 id="更新神经网络参数"><a href="#更新神经网络参数" class="headerlink" title="更新神经网络参数"></a>更新神经网络参数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最简单的更新规则：随机梯度下降</span></span><br><span class="line"><span class="comment"># weight = weight - learning_rate * gradient</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用python来实现这个规则</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> net.parameters():</span><br><span class="line">    f.data.sub_(f.grad.data * learning_rate)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用内置包</span></span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># create your optimizer</span></span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># in your training loop:</span></span><br><span class="line">optimizer.zero_grad()   <span class="comment"># zero the gradient buffers</span></span><br><span class="line">output = net(<span class="built_in">input</span>)</span><br><span class="line">loss = criterion(output, target)</span><br><span class="line">loss.backward()</span><br><span class="line">optimizer.step()    <span class="comment"># Does the update 实现参数更新，一般放在反向传播后面</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
  </entry>
  <entry>
    <title>pytorch自动求导</title>
    <url>/2020/01/27/pytorch%E8%87%AA%E5%8A%A8%E6%B1%82%E5%AF%BC/</url>
    <content><![CDATA[<h1 id="科比一路走好，愿曼巴精神永存！"><a href="#科比一路走好，愿曼巴精神永存！" class="headerlink" title="科比一路走好，愿曼巴精神永存！"></a><strong>科比一路走好，愿曼巴精神永存！</strong></h1><p>具体用法参照<a href="https://pytorch.org/docs/stable/index.html">官方文档</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">x = torch.ones(<span class="number">2</span>, <span class="number">2</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#  .requires_grad 设置为 True，则会开始跟踪针对 tensor 的所有操作</span></span><br><span class="line"><span class="comment"># 调用 .backward() 来自动计算所有梯度</span></span><br><span class="line"><span class="comment"># 调用 .detach()，它将其与计算历史记录分离</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/4cb6b491c6678cb31e04fa0a3288f12f.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 针对张量进行操作</span></span><br><span class="line">y = x + <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/3f788f92348161e8a2bdb2940246f0e6.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Tensor 和 Function 互相连接并构建一个非循环图，它保存整个完整的计算过程的历史信息</span></span><br><span class="line"><span class="comment"># 每个张量都有一个 .grad_fn 属性保存着创建了张量的 Function 的引用</span></span><br><span class="line"><span class="comment"># 用户自己创建张量，则g rad_fn 是 None </span></span><br><span class="line"><span class="built_in">print</span>(x.grad_fn)</span><br><span class="line"><span class="built_in">print</span>(y.grad_fn)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/2f4a974a142f57678dbb84e121385317.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对 y 做更多的操作</span></span><br><span class="line">z = y * y * <span class="number">3</span></span><br><span class="line">out = z.mean()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(z, out)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/fda278be8c27426099b2f8a771dc7774.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .requires_grad( ... ) 会改变张量的 requires_grad 标记。输入的标记默认为 False ，如果没有提供相应的参数。</span></span><br><span class="line">a = torch.randn(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">a = ((a * <span class="number">3</span>) / (a - <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(a.requires_grad)</span><br><span class="line">a.requires_grad_(<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(a.requires_grad)</span><br><span class="line">b = (a * a).<span class="built_in">sum</span>()</span><br><span class="line"><span class="built_in">print</span>(b.grad_fn)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/242393c2cf03eb241f58dfa5d54c186b.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># out.backward(y) 后向传播</span></span><br><span class="line"><span class="built_in">print</span>(x.requires_grad, y.requires_grad, z.requires_grad)</span><br><span class="line"><span class="built_in">print</span>(out.requires_grad)</span><br><span class="line">out.backward()</span><br><span class="line"><span class="comment"># 由梯度计算的链式法则算到所有的结果变量</span></span><br><span class="line"><span class="comment"># 所计算的梯度都是结果变量关于创建变量的梯度</span></span><br><span class="line"><span class="comment"># graph leaves(事先创建，而非运行得到的中间结果)</span></span><br><span class="line"><span class="built_in">print</span>(x.grad)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/0a182c961476e9f8f0615c13758980b5.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 停止对跟踪历史中张量求导</span></span><br><span class="line"><span class="built_in">print</span>(x.requires_grad)</span><br><span class="line"><span class="built_in">print</span>((x ** <span class="number">2</span>).requires_grad)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="built_in">print</span>((x ** <span class="number">2</span>).requires_grad)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/4ea392629723ce2e8a8ff4c98c2f6ba9.png" alt=""> <strong>注意</strong> 1. 求导只对用户定义的变量进行，即对各个leaf Variable计算梯度 2. 运算结果变量的“requires_grad”是不可以更改的，且不会改变</p>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
  </entry>
  <entry>
    <title>Pytorch载入部分参数并冻结</title>
    <url>/2020/02/28/pytorch%E8%BD%BD%E5%85%A5%E9%83%A8%E5%88%86%E5%8F%82%E6%95%B0%E5%B9%B6%E5%86%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://blog.csdn.net/LXX516/article/details/80124768">pytorch 模型部分参数的加载</a></li>
<li><a href="https://blog.csdn.net/qq_34914551/article/details/87871134">Pytorch中，只导入部分模型参数的做法</a></li>
<li><a href="https://discuss.pytorch.org/t/correct-way-to-freeze-layers/26714">Correct way to freeze layers</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/34147880">Pytorch自由载入部分模型参数并冻结</a></li>
<li><a href="https://blog.csdn.net/qq_21997625/article/details/90369838">pytorch冻结部分参数训练另一部分</a></li>
<li><a href="https://blog.csdn.net/jinxin521125/article/details/83621268?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task">PyTorch更新部分网络，其他不更新</a></li>
<li><a href="https://www.cnblogs.com/jiangkejie/p/11199847.html">Pytorch固定部分参数(只训练部分层)</a></li>
</ol>
<h2 id="加载部分参数"><a href="#加载部分参数" class="headerlink" title="加载部分参数"></a>加载部分参数</h2><p>如果加载现有模型的所有参数，我们常使用的是代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.load(model.state_dict())</span><br></pre></td></tr></table></figure>
<p>在训练过程中，我们常常会使用预训练模型，有时我们是在自己的模型中加入别人的某些模块，或者对别人的模型进行局部修改，这个时候再使用<code>torch.load（model.state_dict())</code>，就会出现类似这些的错误：<code>RuntimeError: Error(s) in loading state_dict for Net:Missing key(s) in state_dict:xxx</code>。出现这个错误就是某些参数缺失或者不匹配。</p>
<h3 id="保持原来网络层的名称和结构不变"><a href="#保持原来网络层的名称和结构不变" class="headerlink" title="保持原来网络层的名称和结构不变"></a>保持原来网络层的名称和结构不变</h3><p>现有模型中引入的那部分网络结构的网络层的名称和结构保持不变，这时候加载参数的代码很简单。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载引入的网络模型</span></span><br><span class="line">model_path = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">checkpoint = torch.load(os.path.join(model_path, map_location=torch.device(<span class="string">&#x27;cpu&#x27;</span>))</span><br><span class="line">pretrained_dict = checkpoint[<span class="string">&#x27;net&#x27;</span>]</span><br><span class="line"><span class="comment"># 获取现有模型的参数字典</span></span><br><span class="line">model_dict =  model.state_dict()</span><br><span class="line"><span class="comment"># 获取两个模型相同网络层的参数字典</span></span><br><span class="line">state_dict = &#123;k:v <span class="keyword">for</span> k,v <span class="keyword">in</span> pretrained_dict.items() <span class="keyword">if</span> k <span class="keyword">in</span> model_dict.keys()&#125;</span><br><span class="line"><span class="comment"># update必不可少，实现相同key的value同步</span></span><br><span class="line">model_dict.update(state_dict)</span><br><span class="line"><span class="comment"># 加载模型部分参数</span></span><br><span class="line">model.load_state_dict(model_dict)</span><br></pre></td></tr></table></figure>
<h3 id="引入的网络层名称发生修改"><a href="#引入的网络层名称发生修改" class="headerlink" title="引入的网络层名称发生修改"></a>引入的网络层名称发生修改</h3><p>这个时候再直接使用上面的加载方法，会导致部分key的value无法实现更新。 我就曾在这个位置犯过很严重的错误。首先我定义了<code>AttentionResNet</code>，这是一个UNet来实现图像分割，然后在另一个模型中我使用了这个模型<code>self.attention_map = AttentionResNet(XXX)</code>。因为我在引用的过程中并没有对<code>AttentionResNet</code>那部分代码进行修改，所以本能的觉得这部分网络层的名称是相同的，所以加载这部分参数时，我直接使用了上面的方法。这个错误隐藏了差不多一个星期。直到我开始冻结这部分参数进行训练时，发现情况不对。因为我在输出<code>attention_map</code>的特征图时，我发现它是一张全黑图（像素全为0），这表示加载的参数不对，然后我尝试输出<code>pretrained_dict</code>时，它是一个空字典。然后继续输出<code>pretrained_dict.keys()</code>(未修改之前的<code>pretrained_dict</code>)和<code>model_dict.keys()</code>发现预期相同的那部分key中都多了一部分<code>attention_map.</code>。问题主要出在<code>self.attention_map = AttentionResNet(XXX)</code>这一句，它使原有的网络层名称都加了个前缀<code>attention_map.</code>，知道了错误，修改起来很简单。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载引入的网络模型</span></span><br><span class="line">model_path = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">checkpoint = torch.load(os.path.join(model_path, map_location=torch.device(<span class="string">&#x27;cpu&#x27;</span>))</span><br><span class="line">pretrained_dict = checkpoint[<span class="string">&#x27;net&#x27;</span>]</span><br><span class="line"><span class="comment"># 获取现有模型的参数字典</span></span><br><span class="line">model_dict =  model.state_dict()</span><br><span class="line"><span class="comment"># 获取两个模型相同网络层的参数字典</span></span><br><span class="line">state_dict = &#123;<span class="string">&#x27;attention_map.&#x27;</span> + k:v <span class="keyword">for</span> k,v <span class="keyword">in</span> pretrained_dict.items() <span class="keyword">if</span> <span class="string">&#x27;attention_map.&#x27;</span> + k <span class="keyword">in</span> model_dict.keys()&#125;</span><br><span class="line"><span class="comment"># update必不可少，实现相同key的value同步</span></span><br><span class="line">model_dict.update(state_dict)</span><br><span class="line"><span class="comment"># 加载模型部分参数</span></span><br><span class="line">model.load_state_dict(model_dict)</span><br></pre></td></tr></table></figure>
<p>其实我这个位置的修改有点投机，更加常规的方法是： 引用自<a href="https://zhuanlan.zhihu.com/p/34147880">Pytorch自由载入部分模型参数并冻结</a></p>
<blockquote>
<p>我们看出只要构建一个字典，使得字典的keys和我们自己创建的网络相同，我们在从各种预训练网络把想要的参数对着新的keys填进去就可以有一个新的state_dict了，这样我们就可以load这个新的state_dict，这是最普适的方法适用于所有的网络变化。</p>
</blockquote>
<p>先输出两个模型的参数字典，观察需要加载的那部分参数所处的位置，然后利用for循环构建新的字典。</p>
<h2 id="冻结参数"><a href="#冻结参数" class="headerlink" title="冻结参数"></a>冻结参数</h2><ol>
<li>将需要固定的那部分参数的<code>requires_grad</code>置为False.</li>
<li>在优化器中加入filter根据<code>requires_grad</code>进行过滤.</li>
</ol>
<p>ps: 解决<code>AttributeError: ‘NoneType’ object has no attribute ‘data’</code>问题的一种思路就是冻结参数，参考<a href="http://onwaier.com/?p=540">博客</a> 代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># requires_grad置为False</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> net.XXX.parameters():</span><br><span class="line">    p.requires_grad = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># filter</span></span><br><span class="line">optimizer.SGD(<span class="built_in">filter</span>(<span class="keyword">lambda</span> p: p.requires_grad, model.parameters()), lr=<span class="number">1e-3</span>)</span><br></pre></td></tr></table></figure>
<p>当需要冻结的那部分参数的网络层名称不太明确时，可以采用<a href="https://blog.csdn.net/qq_21997625/article/details/90369838">pytorch冻结部分参数训练另一部分</a>的思路，打印出所有网络层，通过参数名称进行冻结。</p>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
        <tag>pytorch冻结参数</tag>
        <tag>pytorch加载部分参数</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux使用教程</title>
    <url>/2020/06/03/tmux%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux 使用教程</a></li>
<li><a href="https://harttle.land/2015/11/06/tmux-startup.html">优雅地使用命令行：Tmux 终端复用</a></li>
<li><a href="https://www.cnblogs.com/kaiye/p/6275207.html">十分钟学会tmux</a></li>
<li><a href="http://louiszhai.github.io/2017/09/30/tmux/">Tmux使用手册</a></li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>tmux教程</tag>
      </tags>
  </entry>
  <entry>
    <title>transforms.ToPILImage(): pic should be Tensor or ndarray</title>
    <url>/2020/02/03/transforms-topilimage-pic-should-be-tensor-or-ndarray/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://github.com/pytorch/vision/issues/408">transforms.ToPILImage(): pic should be Tensor or ndarray</a></li>
</ol>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>对UNet网络完成训练，需要输入一张图片，测试输出的概率图是否接近分割出的人脸。网络的输入为<code>(num, 3, w, h)</code>4维度tensor。输出仍为<code>(num, 1, w, h)</code>4维度的tensor，我的目标是将输出的tensor转为图像，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inputs = inputs.view(-<span class="number">1</span>, c, h, w)</span><br><span class="line"><span class="comment">#inputs = inputs.cuda()</span></span><br><span class="line"></span><br><span class="line">inputs = Variable(inputs, volatile=<span class="literal">True</span>)</span><br><span class="line">outputs = net(inputs)</span><br><span class="line"><span class="built_in">print</span>(outputs.shape)</span><br><span class="line">transforms.ToPILImage()(outputs).convert(<span class="string">&#x27;L&#x27;</span>).save(<span class="string">&#x27;test2.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>运行出现错误<code>transforms.ToPILImage(): pic should be Tensor or ndarray</code>。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>查阅<a href="https://github.com/pytorch/vision/issues/408">资料1</a>，出错是因为</p>
<blockquote>
<p>All images in torchvision have to be represented as 3-dimensional tensors of the form [Channel, Height, Width]. I’m guessing your float tensor is a 2d tensor (height x width). For example, this works:</p>
</blockquote>
<p>即torchvision中的所有图像必须是三维的tensor表示的，而我代码中的outputs未经处理时，是四维的。所以需要进行维度转换。修改后代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inputs = inputs.view(-<span class="number">1</span>, c, h, w)</span><br><span class="line"><span class="comment">#inputs = inputs.cuda()</span></span><br><span class="line"></span><br><span class="line">inputs = Variable(inputs, volatile=<span class="literal">True</span>)</span><br><span class="line">outputs = net(inputs)</span><br><span class="line"><span class="built_in">print</span>(outputs.shape)</span><br><span class="line">outputs = outputs.view(<span class="number">1</span>, h, w)  <span class="comment"># 转成3维的 很重要！！！</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(outputs))</span><br><span class="line">transforms.ToPILImage()(outputs).convert(<span class="string">&#x27;L&#x27;</span>).save(<span class="string">&#x27;test2.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
        <tag>ToPILImage</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeError: Caught TypeError in DataLoader worker process 0.</title>
    <url>/2020/02/09/typeerror-caught-typeerror-in-dataloader-worker-process-0/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://blog.csdn.net/weixin_45093926/article/details/103330105">Python迭代DataLoader时出现TypeError: Caught TypeError in DataLoader worker process 0.错误。</a></li>
</ol>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>用构造的数据集去训练网络过程，迭代DataLoader出现TypeError的错误，<code>Caught TypeError in DataLoader worker process 0</code></p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>参考<a href="https://blog.csdn.net/weixin_45093926/article/details/103330105">资料1</a>)，出错原因是数据集的标签缺失，不完整。 查看自己的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">files = os.listdir(anger_path)</span><br><span class="line">files.sort()</span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> files:</span><br><span class="line">    I = skimage.io.imread(os.path.join(anger_path,filename))</span><br><span class="line">    image = cv2.imread(os.path.join(anger_path,filename))</span><br><span class="line">    res, flag = get_mask(image)</span><br><span class="line">    data_x.append(I.tolist())</span><br><span class="line">    data_y.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> flag == <span class="literal">True</span>:</span><br><span class="line">        res = res * <span class="number">255</span></span><br><span class="line">        seg_image_data = res.tolist()</span><br><span class="line">        data_z.append(seg_image_data)</span><br><span class="line">        imageCount = imageCount + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(imageCount)</span><br></pre></td></tr></table></figure>
<p>data_x与data_y的数据是直接添加的，而data_z是经过if判断的，False时，就不会添加。这样就导致某一条记录里面没有data_z这个标签，为了解决这个问题，需将data_x和data_y的数据添加移到if条件中，实现data_x，data_y和data_z三个同步添加。即</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">files = os.listdir(anger_path)</span><br><span class="line">files.sort()</span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> files:</span><br><span class="line">    I = skimage.io.imread(os.path.join(anger_path,filename))</span><br><span class="line">    image = cv2.imread(os.path.join(anger_path,filename))</span><br><span class="line">    res, flag = get_mask(image)</span><br><span class="line">    <span class="keyword">if</span> flag == <span class="literal">True</span>:</span><br><span class="line">        data_x.append(I.tolist())</span><br><span class="line">        data_y.append(<span class="number">0</span>)</span><br><span class="line">        res = res * <span class="number">255</span></span><br><span class="line">        seg_image_data = res.tolist()</span><br><span class="line">        data_z.append(seg_image_data)</span><br><span class="line">        imageCount = imageCount + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(imageCount)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeError: default_collate: batch must contain tensors, numpy arrays, numbers, dicts or lists; found </title>
    <url>/2020/02/03/typeerror-default-collate-batch-must-contain-tensors-numpy-arrays-numbers-dicts-or-lists-found/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://discuss.pytorch.org/t/image-file-reading-typeerror-batch-must-contain-tensors-numbers-dicts-or-lists-found-class-pil-image-image/9909">issue</a></li>
</ol>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>原始网络用来训练一个表情分类的网络，对输入的图像进行了变换；我将其换成了一个图像分割的网络，目标值从原来的表情标签变成了01概率图的ground truth，此时不能再对输入图像进行变换，因为ground truth不能随之变换。所以我将<code>transform</code>赋值为<code>None</code>,再次训练网络时，出现了错误<strong>TypeError: default_collate: batch must contain tensors, numpy arrays, numbers, dicts or lists; found</strong> 。</p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>查阅<a href="https://discuss.pytorch.org/t/image-file-reading-typeerror-batch-must-contain-tensors-numbers-dicts-or-lists-found-class-pil-image-image/9909">相关问题</a>的回答。</p>
<blockquote>
<p>The error states that the DataLoader receives a PIL image. This is because there are no transforms made (transform=None) on the image. The <strong>getitem</strong> method of MyDataset passes an unprocessed PIL image to the DataLoader, whereas it should receive a tensor. You can add a transform that creates a tensor from the PIL image by adding transform:</p>
</blockquote>
<p>将<code>PIL image</code>交给<code>DataLoader</code>，必须要将<code>PIL image</code>先进行处理，即将其转为<code>tensor</code>，所以对图片仍需进行<code>transform</code>，将其它随机裁剪注释掉，仅保留<code>PIP image</code>转为<code>tensor</code>的代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transform_train = transforms.Compose([</span><br><span class="line">    <span class="comment">#transforms.RandomCrop(44),</span></span><br><span class="line">    <span class="comment">#transforms.RandomHorizontalFlip(),</span></span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">transform_test = transforms.Compose([</span><br><span class="line">    <span class="comment">#transforms.TenCrop(cut_size),</span></span><br><span class="line">    transforms.Lambda(<span class="keyword">lambda</span> crops: torch.stack([transforms.ToTensor()(crop) <span class="keyword">for</span> crop <span class="keyword">in</span> crops])),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>PIL image转为tensor</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeError: Object dtype dtype(&#39;O&#39;) has no native HDF5 equivalent</title>
    <url>/2020/02/10/typeerror-object-dtype-dtypeo-has-no-native-hdf5-equivalent/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://blog.csdn.net/chenvast/article/details/78974359">Python TypeError: No conversion path for dtype: dtype(‘</a></li>
<li><a href="https://www.twblogs.net/a/5c359e55bd9eee35b3a55bb6/zh-cn">TypeError: Object dtype dtype(‘O’) has no native HDF5 equivalent</a></li>
<li><a href="https://www.ojit.com/article/358928">python - 使用不同大小的h5py数组进行保存</a></li>
</ol>
<h2 id="错误描述"><a href="#错误描述" class="headerlink" title="错误描述"></a>错误描述</h2><p>在对h5文件写的过程中，首先遇到了错误<code>OSError: Cannot write data (no appropriate function for conversion path)</code>，网上搜索之后，与之相关的问题很少，大部分提到的是字符串编码问题，参照<a href="https://blog.csdn.net/chenvast/article/details/78974359">资料1</a>，对字符串的编码修改，但错误依旧。在这个地方卡了很长时间，一直检查数据类型哪里是不是有问题？最后尝试性，将最后创建数据集中的<code>dtype</code>去掉，即置为<code>None</code>。即将</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">datafile.create_dataset(<span class="string">&quot;PrivateTest_gt&quot;</span>, dtype = <span class="string">&#x27;uint8&#x27;</span>, data=PrivateTest_z)</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">datafile.create_dataset(<span class="string">&quot;PrivateTest_gt&quot;</span>, data=PrivateTest_z)</span><br></pre></td></tr></table></figure>
<p>问题出现了转机，提示的错误不一样了，<code>TypeError: Object dtype dtype(&#39;O&#39;) has no native HDF5 equivalent</code>，再查询这个问题上，发现很多博客，如<a href="https://www.twblogs.net/a/5c359e55bd9eee35b3a55bb6/zh-cn">资料2</a>和<a href="https://www.ojit.com/article/358928">资料3</a>提到出现错误的原因是：</p>
<blockquote>
<p>要存储的数据中存在维度不一致的数据</p>
</blockquote>
<p>具体<code>datafile.create_dataset(&quot;PrivateTest_gt&quot;, data=PrivateTest_z)</code>一行中，PrivateTest_z列表中存储着两种shape的图片数据，一种是48 * 48，而另一种是128 * 128。这种情况h5py无法统一处理。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>参照资料，解决这个问题常见有两种。</p>
<ul>
<li>散装</li>
</ul>
<p>将相同维度的数据放在同一个dataset中，即把原始数据拆分成多个dataset存储</p>
<ul>
<li>统装</li>
</ul>
<p>统一数据的维度。我用的就是这种方法，我将所有图片的数据都统一成128 * 128（对于48的resize），即解决上述问题。</p>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
        <tag>h5py</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu18.04上非root用户安装cuda9.0与cudnn</title>
    <url>/2020/07/29/ubuntu18-04%E4%B8%8A%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E5%AE%89%E8%A3%85cuda9-0%E4%B8%8Ecudnn/</url>
    <content><![CDATA[<h1 id="ubuntu18-04上非root用户安装cuda9-0与cudnn"><a href="#ubuntu18-04上非root用户安装cuda9-0与cudnn" class="headerlink" title="ubuntu18.04上非root用户安装cuda9.0与cudnn"></a>ubuntu18.04上非root用户安装cuda9.0与cudnn</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://blog.csdn.net/sinat_20280061/article/details/80421532">Linux非root用户如何优雅的安装cuda和cudnn</a></li>
<li><a href="https://www.cnblogs.com/cj695/p/5212848.html">安装cuda时 提示toolkit installation failed using unsupported compiler解决方法</a></li>
</ol>
<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><ol>
<li>cuda与cudnn下载</li>
</ol>
<ul>
<li><p>cuda下载地址：<a href="https://developer.nvidia.com/cuda-downloads">https://developer.nvidia.com/cuda-downloads</a></p>
</li>
<li><p>cudnn下载地址：<a href="https://developer.nvidia.com/cudnn">https://developer.nvidia.com/cudnn</a>(需要注册登录账号)</p>
</li>
</ul>
<ol>
<li>安装cuda</li>
</ol>
<ul>
<li><p>在浏览器中找到指定版本的cuda的下载链接，如<a href="https://developer.nvidia.com/compute/cuda/9.0/Prod/local_installers/cuda_9.0.176_384.81_linux-run">cuda9.0</a>.然后在命令行中下载<code>wget link</code>，如<code>wget https://developer.nvidia.com/compute/cuda/9.0/Prod/local_installers/cuda_9.0.176_384.81_linux-run</code></p>
</li>
<li><p>下载完成后，使用<code>chmod +x filename.run</code>赋予执行权限，然后执行命令<code>./filename.run</code></p>
</li>
<li><p>同意协议，不安装驱动，然后将cuda和cudasamples的目录修改为个人目录。安装时可能会出现错误<code>toolkit installation failed using unsupported compiler</code>，这是因为gcc版本过高引起的，解决方法为在命令后加上<code>--override</code>，即<code>./filename.run --override</code>（这种方法治标不治本，最好的解决方法是编译安装低版本的gcc）。</p>
</li>
</ul>
<ol>
<li>安装cudnn</li>
</ol>
<ul>
<li>找到与cuda对应版本的cudnn，如<a href="https://developer.nvidia.com/compute/machine-learning/cudnn/secure/7.6.5.32/Production/9.0_20191031/cudnn-9.0-linux-x64-v7.6.5.32.tgz">cudnn7.6.5</a>。</li>
<li>解压文件，<code>tar -zxvf cudnn-9.0-linux-x64-v7.6.5.32.tgz</code></li>
<li>将解压出的文件夹 <strong>include</strong>与<strong>lib64</strong>中的文件复制到cuda安装位置中对应的 <strong>include</strong>与 <strong>lib64</strong>文件夹中.</li>
</ul>
<ol>
<li>修改个人用户的环境变量</li>
</ol>
<ul>
<li>修改<code>～/.bashrc</code>文件，在文件末尾中加下以下代码（注： <strong>/data2/ljj/software/cuda-9.0是我的cuda安装位置</strong>）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=/data2/ljj/software/cuda-9.0/bin:$PATH </span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/data2/ljj/software/cuda-9.0/lib64/ </span><br></pre></td></tr></table></figure>
<ul>
<li>执行<code>source ~/.baserc</code>使环境变量生效</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>cuda</tag>
      </tags>
  </entry>
  <entry>
    <title>vim常见操作</title>
    <url>/2019/08/20/vim%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="vim简介"><a href="#vim简介" class="headerlink" title="vim简介"></a>vim简介</h1><p>vim是功能强大的文本编辑器，常用于Linux上，作用是用来建立、编辑、显示文件。</p>
<h1 id="vim的三种工作模式"><a href="#vim的三种工作模式" class="headerlink" title="vim的三种工作模式"></a>vim的三种工作模式</h1><p>vim有三种工作模式：命令模式、插入模式、编辑模式。 <a href="https://i.loli.net/2019/08/20/iaQJuNgVlSF58dP.png" title="vim三种模式转换"><img src="https://i.loli.net/2019/08/20/iaQJuNgVlSF58dP.png" alt="vim三种模式转换" title="vim三种模式转换"></a></p>
<h1 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h1><p>插入命令常见的有a，A，i，I，o，O等</p>
<p>命令</p>
<p>作用</p>
<p>a</p>
<p>在光标所在字符后插入</p>
<p>A</p>
<p>在光标所在行尾插入</p>
<p>i</p>
<p>在光标所在字符前插入</p>
<p>I</p>
<p>在光标所有行行首插入</p>
<p>o</p>
<p>在光标下插入新行</p>
<p>O</p>
<p>在光标上插入新行</p>
<h1 id="定位命令"><a href="#定位命令" class="headerlink" title="定位命令"></a>定位命令</h1><p>命令</p>
<p>作用</p>
<p>:set nu</p>
<p>设置行号</p>
<p>:set nonu</p>
<p>取消行号</p>
<p>gg</p>
<p>到第一行</p>
<p>G</p>
<p>到最后一行</p>
<p>nG</p>
<p>到第n行</p>
<p>:n</p>
<p>到第n行</p>
<p>$</p>
<p>移至行尾</p>
<p>0</p>
<p>移到行首</p>
<h1 id="移动光标命令"><a href="#移动光标命令" class="headerlink" title="移动光标命令"></a>移动光标命令</h1><p>命令</p>
<p>作用</p>
<p>h</p>
<p>光标左移</p>
<p>l</p>
<p>光标右移</p>
<p>j</p>
<p>光标下移</p>
<p>k</p>
<p>光标上移</p>
<h1 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h1><p>命令</p>
<p>作用</p>
<p>x</p>
<p>删除光标所在处字符</p>
<p>nx</p>
<p>删除光标所在处后n个字符</p>
<p>dd</p>
<p>删除光标所在行，ndd删除n行</p>
<p>dG</p>
<p>删除光标所在行到文件末尾内容</p>
<p>D</p>
<p>删除光标所在处到行尾的内容</p>
<p>d0</p>
<p>删除光标前到行首的内容</p>
<p>:n1,n2d</p>
<p>删除指定范围的行</p>
<h1 id="复制和剪切命令"><a href="#复制和剪切命令" class="headerlink" title="复制和剪切命令"></a>复制和剪切命令</h1><p>命令</p>
<p>作用</p>
<p>yy</p>
<p>复制当前行</p>
<p>nyy</p>
<p>复制当前行以下n行</p>
<p>dd</p>
<p>剪切当前行</p>
<p>ndd</p>
<p>剪切当前行以下n行</p>
<p>p、P</p>
<p>粘贴在当前光标所在行下或行上</p>
<h1 id="替换和取消命令"><a href="#替换和取消命令" class="headerlink" title="替换和取消命令"></a>替换和取消命令</h1><p>命令</p>
<p>作用</p>
<p>r</p>
<p>取消光标所在处的字符</p>
<p>R</p>
<p>从光标所在处开始替换字符，按ESC结束</p>
<p>u</p>
<p>取消上一步的操作</p>
<h1 id="搜索和搜索替换命令"><a href="#搜索和搜索替换命令" class="headerlink" title="搜索和搜索替换命令"></a>搜索和搜索替换命令</h1><p>命令</p>
<p>作用</p>
<p>/string</p>
<p>搜索指定字符串，搜索时忽略大小写:set ic</p>
<p>n</p>
<p>搜索指定字符串的下一个出现位置</p>
<p>:%s/old/new/g</p>
<p>全文替换指定字符串</p>
<p>:n1，n2s/old/new/g</p>
<p>在指定范围内替换指定字符串</p>
<h1 id="保存和退出命令"><a href="#保存和退出命令" class="headerlink" title="保存和退出命令"></a>保存和退出命令</h1><p>命令</p>
<p>作用</p>
<p>:w</p>
<p>保存修改(write)</p>
<p>:w new_filename</p>
<p>另存为指定文件</p>
<p>:wq</p>
<p>保存修改并退出</p>
<p>ZZ</p>
<p>快捷键，保存修改并退出</p>
<p>:q!</p>
<p>不保存修改并退出(quit)</p>
<p>:wq!</p>
<p>保存修改并退出</p>
<h1 id="一些使用技巧"><a href="#一些使用技巧" class="headerlink" title="一些使用技巧"></a>一些使用技巧</h1><p>1、导入命令执行结果 :r !命令 2、定义快捷键 :map 快捷键 触发命令 如设置注释快捷键 :map ^P I#<ESC> 按ctrl + p 应可以行首添加”#”进行注释 同样取消注释快捷键可以设为 :map ^B 0x 按ctrl + b 可以删除行首的”#” 3、连续行注释 :n1,n2s/^/#/g 在n1至n2行添加注释 :n1,n2s/^#/g 取消n1 n2行的注释 4、替换 :ab mail onwaier@163.com mail用onwaier@163.com来代替</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vim常见操作</tag>
      </tags>
  </entry>
  <entry>
    <title>vim配置</title>
    <url>/2019/10/23/vim%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="配置文件内容"><a href="#配置文件内容" class="headerlink" title="配置文件内容"></a>配置文件内容</h2><p>所有用户生效 修改 /etc/vimrc 仅在当前用户下生效 在用户目录下新建文件为 .vimrc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;设置编码</span><br><span class="line">set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936</span><br><span class="line">set termencoding=utf-8</span><br><span class="line">set encoding=utf-8</span><br><span class="line"></span><br><span class="line">&quot;显示行号</span><br><span class="line">set nu</span><br><span class="line">set number</span><br><span class="line"></span><br><span class="line">&quot;cursorline的缩写形式</span><br><span class="line">set cursorline</span><br><span class="line">set cul</span><br><span class="line"></span><br><span class="line">&quot;突出显示当前列</span><br><span class="line">&quot;set cursorcolumn</span><br><span class="line">&quot;set cuc</span><br><span class="line"></span><br><span class="line">&quot;启用鼠标</span><br><span class="line">set mouse=a</span><br><span class="line">set selection=exclusive</span><br><span class="line">set selectmode=mouse,key</span><br><span class="line"></span><br><span class="line">&quot;显示括号匹配</span><br><span class="line">set showmatch</span><br><span class="line"></span><br><span class="line">&quot;设置Tab长度为4空格</span><br><span class="line">set tabstop=4</span><br><span class="line">&quot;设置自动缩进长度为4空格</span><br><span class="line">set shiftwidth=4</span><br><span class="line">&quot;继承前一行的缩进方式，适用于多行注释</span><br><span class="line">set autoindent</span><br><span class="line"></span><br><span class="line">&quot;设置粘贴</span><br><span class="line">set paste</span><br><span class="line"></span><br><span class="line">&quot;显示tab和空白符，方便定位错误</span><br><span class="line">set listchars=tab:&gt;-,trail:-</span><br><span class="line"></span><br><span class="line">&quot;总是显示状态栏</span><br><span class="line">set laststatus=2</span><br><span class="line">&quot;显示光标当前位置</span><br><span class="line">set ruler</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>win10 vs2015配置opencv2.4.9和opencv3.2.0</title>
    <url>/2019/08/22/win10-vs2015%E9%85%8D%E7%BD%AEopencv2-4-9%E5%92%8Copencv3-2-0/</url>
    <content><![CDATA[<p>为vs2015同时配置opencv2和opencv3的版本，opencv3以后的一些功能（sifi，surf算法等）移到contrib中，如需使用这些功能需要单独配置contrib，为避免麻烦，这里同时配置opencv2和opencv3两个版本，方便使用。后面我会写博客介绍opencv3的contrib的配置。</p>
<h1 id="配置opencv2-4-9"><a href="#配置opencv2-4-9" class="headerlink" title="配置opencv2.4.9"></a>配置opencv2.4.9</h1><h3 id="在官网下载opencv2-4-9"><a href="#在官网下载opencv2-4-9" class="headerlink" title="在官网下载opencv2.4.9"></a>在<a href="https://opencv.org/releases" title="官网">官网</a>下载opencv2.4.9</h3><p>打开“opencv\\2.4.9\\opencv\\build\\x86”，我们发现目录下只有vc10，vc11，vc12，并没有vc14(对应的是vs2015)。这里是没有关系的，涉及到vc的都配置成vc12就可以了。 <a href="https://i.loli.net/2019/08/22/l8ImAUyN6FwbJd9.png"><img src="https://i.loli.net/2019/08/22/l8ImAUyN6FwbJd9.png" alt=""></a></p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>编辑系统环境变量中的path变量，添加D:\\Program Files\\opencv2.4.9\\opencv\\build\\x86\\vc12\\bin（这个目录和你安装的opencv的位置有关，下面同理） <a href="https://i.loli.net/2019/08/22/z1WqVAyfTp8oEXK.png"><img src="https://i.loli.net/2019/08/22/z1WqVAyfTp8oEXK.png" alt=""></a></p>
<h3 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h3><p>添加源文件，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat img = <span class="built_in">imread</span>(<span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">namedWindow</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;1&quot;</span>, img);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">6000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后视图中选择属性管理器-&gt;Debug win32 -&gt;Microsoft.Cpp.Win32.user，单击右键，选择属性。 <a href="https://i.loli.net/2019/08/22/QE1uIBPHieaKtGp.png"><img src="https://i.loli.net/2019/08/22/QE1uIBPHieaKtGp.png" alt=""></a></p>
<h3 id="配置VC-目录的包含目录和库目录"><a href="#配置VC-目录的包含目录和库目录" class="headerlink" title="配置VC++目录的包含目录和库目录"></a>配置VC++目录的包含目录和库目录</h3><p>包含目录为： <code>D:Program Files\opencv2.4.9\opencv\build\include D:Program Files\opencv2.4.9\opencv\build\include\opencv D:Program Files\opencv2.4.9\opencv\build\include\opencv2</code> <a href="https://i.loli.net/2019/08/22/SZYU71hydE4g8sN.png"><img src="https://i.loli.net/2019/08/22/SZYU71hydE4g8sN.png" alt=""></a> 库目录为: <code>D:Program Files\opencv2.4.9\opencv\build\x86\vc12\lib</code> <a href="https://i.loli.net/2019/08/22/nYLRVqOJf9xWkHs.png"><img src="https://i.loli.net/2019/08/22/nYLRVqOJf9xWkHs.png" alt=""></a></p>
<h3 id="添加附加依赖项"><a href="#添加附加依赖项" class="headerlink" title="添加附加依赖项"></a>添加附加依赖项</h3><p>选择链接器，选择输入，然后点击附加依赖项。 添加2.4.9的lib</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">opencv_ml249d.lib</span><br><span class="line">opencv_calib3d249d.lib</span><br><span class="line">opencv_contrib249d.lib</span><br><span class="line">opencv_core249d.lib</span><br><span class="line">opencv_features2d249d.lib</span><br><span class="line">opencv_flann249d.lib</span><br><span class="line">opencv_gpu249d.lib</span><br><span class="line">opencv_highgui249d.lib</span><br><span class="line">opencv_imgproc249d.lib</span><br><span class="line">opencv_legacy249d.lib</span><br><span class="line">opencv_objdetect249d.lib</span><br><span class="line">opencv_ts249d.lib</span><br><span class="line">opencv_video249d.lib</span><br><span class="line">opencv_nonfree249d.lib</span><br><span class="line">opencv_ocl249d.lib</span><br><span class="line">opencv_photo249d.lib</span><br><span class="line">opencv_stitching249d.lib</span><br><span class="line">opencv_superres249d.lib</span><br><span class="line">opencv_videostab249d.lib</span><br><span class="line">opencv_objdetect249.lib</span><br><span class="line">opencv_ts249.lib</span><br><span class="line">opencv_video249.lib</span><br><span class="line">opencv_nonfree249.lib</span><br><span class="line">opencv_ocl249.lib</span><br><span class="line">opencv_photo249.lib</span><br><span class="line">opencv_stitching249.lib</span><br><span class="line">opencv_superres249.lib</span><br><span class="line">opencv_videostab249.lib</span><br><span class="line">opencv_calib3d249.lib</span><br><span class="line">opencv_contrib249.lib</span><br><span class="line">opencv_core249.lib</span><br><span class="line">opencv_features2d249.lib</span><br><span class="line">opencv_flann249.lib</span><br><span class="line">opencv_gpu249.lib</span><br><span class="line">opencv_highgui249.lib</span><br><span class="line">opencv_imgproc249.lib</span><br><span class="line">opencv_legacy249.lib</span><br><span class="line">opencv_ml249.lib</span><br></pre></td></tr></table></figure>
<h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p>然后管理器设为Debug，X86运行项目。 <a href="https://i.loli.net/2019/08/22/BkFlrUGih7Cd568.png"><img src="https://i.loli.net/2019/08/22/BkFlrUGih7Cd568.png" alt=""></a> 成功运行出来图片，则表示配置成功。 如果运行出现缺少*.dll的错误，将对应的dll全部复制到操作系统目录下可解决问题。 具体如下：将D:\\Program Files\\opencv2.4.9\\opencv\\build\\x86\\vc12\\bin的所有文件复制到C:WindowsSystems32和C:WindowsSysWow64。</p>
<h1 id="配置opencv3-2-0"><a href="#配置opencv3-2-0" class="headerlink" title="配置opencv3.2.0"></a>配置opencv3.2.0</h1><h3 id="配置环境变量-1"><a href="#配置环境变量-1" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:Program Files\opencv3.2.0\opencv\build\x64\vc14\bin</span><br></pre></td></tr></table></figure>
<h3 id="配置包含目录和库目录"><a href="#配置包含目录和库目录" class="headerlink" title="配置包含目录和库目录"></a>配置包含目录和库目录</h3><p>属性管理器-&gt;Dubug x64 -&gt;Microsoft.Cpp.x64.user，单击右键属性。 包含目录为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:Program Files\opencv3.2.0\opencv\build\include</span><br><span class="line">D:Program Files\opencv3.2.0\opencv\build\include\opencv</span><br><span class="line">D:Program Files\opencv3.2.0\opencv\build\include\opencv2</span><br></pre></td></tr></table></figure>
<p>库目录为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:Program Files\opencv3.2.0\opencv\build\x64\vc14\lib</span><br></pre></td></tr></table></figure>
<h3 id="配置附加依赖项"><a href="#配置附加依赖项" class="headerlink" title="配置附加依赖项"></a>配置附加依赖项</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">opencv_world320d.lib</span><br><span class="line">opencv_world320.lib</span><br></pre></td></tr></table></figure>
<h3 id="运行项目-1"><a href="#运行项目-1" class="headerlink" title="运行项目"></a>运行项目</h3><p>管理器设为Dubug x64运行项目 至此win10上vs2015配置opencv2.4.9和opencv3.2.0完成。</p>
]]></content>
      <categories>
        <category>opencv</category>
      </categories>
      <tags>
        <tag>opencv配置</tag>
      </tags>
  </entry>
  <entry>
    <title>wordpress首页显示文章摘要</title>
    <url>/2019/08/28/wordpress%E9%A6%96%E9%A1%B5%E6%98%BE%E7%A4%BA%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81/</url>
    <content><![CDATA[<h1 id="1、安装插件"><a href="#1、安装插件" class="headerlink" title="1、安装插件"></a>1、安装插件</h1><p>插件有很多，这里推荐安装WP-UTF8-Excerpt。 主要特点： 1. 支持多字节语言（如中文），不会产生乱码。 2. 摘要可保留文章中的格式标签，如字体、颜色、链接、图片等（需保留的标签可在后台设置）。 3. 首页每篇文章显示300字，存档页面每篇文章显示150字（字数可设置）。</p>
<h1 id="2、修改代码"><a href="#2、修改代码" class="headerlink" title="2、修改代码"></a>2、修改代码</h1><p>index.php是嵌套一个 content.php 的文件用于专门显示文章的内容。打开content.php文件（外观 -&gt; 主题编辑器 -&gt; content.php）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">the_content(</span><br><span class="line">                sprintf(</span><br><span class="line">                    __( &#x27;Continue reading %s&#x27;, &#x27;twentyfifteen&#x27; ),</span><br><span class="line">                    the_title( &#x27;&lt;span class=&quot;screen-reader-text&quot;&gt;&#x27;, &#x27;&lt;/span&gt;&#x27;, false )</span><br><span class="line">                )</span><br><span class="line">            );</span><br></pre></td></tr></table></figure>
<p>替换成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(!is_single()) &#123;</span><br><span class="line">                the_excerpt();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                the_content(__(&#x27;(more…)&#x27;));</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>然后就能在首页显示你为文章设置的摘要了。</p>
]]></content>
      <categories>
        <category>wordpress</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>定制linux垃圾箱</title>
    <url>/2021/09/05/%E5%AE%9A%E5%88%B6linux%E5%9E%83%E5%9C%BE%E7%AE%B1/</url>
    <content><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>在linux或mac中有时使用rm命令会误删文件，导致恢复过程十分复杂。能否实现一个类似于垃圾箱功能用于暂存文件，然后恢复误删文件</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>·<a href="https://xunming.blog.csdn.net/article/details/79310395">Linux回收站功能的实现</a></li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改rm 命令</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">rm</span>=delete <span class="comment">#命令别名，通过delete来实现rm改为mv</span></span><br><span class="line"><span class="built_in">alias</span> r=delete</span><br><span class="line"><span class="built_in">alias</span> rl=<span class="string">&#x27;ls /home/onwaier/Documents/trash&#x27;</span> <span class="comment">#rl 命令显示回收站的内容</span></span><br><span class="line"><span class="built_in">alias</span> ur=undelfile <span class="comment">#ul 命令找回回收站的文件</span></span><br><span class="line"><span class="comment"># 回收文件</span></span><br><span class="line"><span class="function"><span class="title">undelfile</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> [ ! <span class="variable">$#</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">mv</span> /home/onwaier/Documents/trash/<span class="variable">$@</span> ./</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;请传入需撤销删除的文件名称,不清楚文件名称请用rl命令查看&quot;</span></span><br><span class="line">    <span class="keyword">fi</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 将文件移至trash文件夹下</span></span><br><span class="line"><span class="function"><span class="title">delete</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> [ ! -d <span class="string">&quot;/home/onwaier/Documents/trash/&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">mkdir</span> /home/onwaier/Documents/trash </span><br><span class="line">    <span class="keyword">fi</span> </span><br><span class="line">    \<span class="built_in">mv</span> <span class="variable">$@</span> /home/onwaier/Documents/trash/</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 清空回收站</span></span><br><span class="line"><span class="function"><span class="title">cleartrash</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">read</span> <span class="string">&quot;confirm?Are you sure?[YN]&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$confirm</span> <span class="keyword">in</span></span><br><span class="line">        Y  y)</span><br><span class="line">            /bin/rm -rf /home/onwaier/Documents/trash/*;;</span><br><span class="line">        N  n)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;exit&quot;</span>;;</span><br><span class="line">        *)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;error choice&quot;</span>;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>删除文件时，用<code>rm filename1 finename2</code>将会实现软删除，文件其实被移到你设置的特定路径下(如/home/onwaier/Documents/trash/)，恢复时使用<code>ur filename1</code>，查看回收站的内容<code>rl</code>，清空回收站<code>cleartransh</code></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>实现智能侧边栏跟随固定范围浮动</title>
    <url>/2020/01/28/%E5%AE%9E%E7%8E%B0%E6%99%BA%E8%83%BD%E4%BE%A7%E8%BE%B9%E6%A0%8F%E8%B7%9F%E9%9A%8F%E5%9B%BA%E5%AE%9A%E8%8C%83%E5%9B%B4%E6%B5%AE%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>我的博客是两列布局，当文章内容过多时，向下滑动，左侧栏会出现空白，影响阅读体验。想要实现这种效果：当左侧栏滑到底时，不继续左边内容向下滑动。查阅网上的资料，实现的方法大致分为三种。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>解决方法大致分为两种类型：通过插件实现或者修改代码。</p>
<h3 id="插件Q2W3-Fixed-Widget"><a href="#插件Q2W3-Fixed-Widget" class="headerlink" title="插件Q2W3 Fixed Widget"></a>插件Q2W3 Fixed Widget</h3><p>参考<a href="https://www.freeluffy.com/q2w3-fixed-widget/">博客</a>，我添加后没有达到理想效果，可能是哪里没设置好或者设置冲突。 - 安装插件 通过插件安装器搜索或者zip压缩包安装即可.</p>
<ul>
<li><p>设置Widget固定 先启动插件<code>Q2W3 Fixed Widget</code>，然后点击<code>外观-&gt;小工具</code>. 对于添加在左侧栏的小工具，多了一个设置选项。如图所示。 <img src="/images/2020/01/ccca529e7f22a669404f043baa87a2cf.png" alt=""> 将需要固定的工具的<code>Fixed widget</code>勾上即可。</p>
<h3 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h3><p>参照<a href="http://wanlimm.com/77201807015793.html">博客</a></p>
<ol>
<li>修改js和css代码</li>
</ol>
<ul>
<li>修改<code>single.php</code>文件 在文件最后添加如下代码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;http://code.jquery.com/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">$(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> offset_left = $(<span class="string">&quot;.sidebar&quot;</span>).<span class="title function_">offset</span>().<span class="property">left</span>; <span class="comment">//body左边距 = 右边距</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> sidebar_w = $(<span class="string">&quot;.sidebar&quot;</span>).<span class="title function_">width</span>(); <span class="comment">//侧边栏宽度</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> sidebar_h = $(<span class="string">&quot;.sidebar&quot;</span>).<span class="title function_">outerHeight</span>(); <span class="comment">//侧边栏高</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> sidebar_top = $(<span class="string">&quot;.sidebar&quot;</span>).<span class="title function_">offset</span>().<span class="property">top</span>; <span class="comment">//侧边栏上边距</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">console</span>.<span class="title function_">log</span>(sidebar_top + sidebar_h)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">console</span>.<span class="title function_">log</span>($(<span class="variable language_">window</span>).<span class="title function_">height</span>())</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">console</span>.<span class="title function_">log</span>($(<span class="variable language_">document</span>).<span class="title function_">height</span>())</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">innerHeight</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">$(<span class="variable language_">document</span>).<span class="title function_">scroll</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> scroll_h = $(<span class="variable language_">document</span>).<span class="title function_">scrollTop</span>(); <span class="comment">//滚动条高度</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">if</span>( scroll_h &gt; (sidebar_top+sidebar_h - <span class="variable language_">window</span>.<span class="property">innerHeight</span>))&#123; <span class="comment">//当滚动条高度 &gt; 侧边栏底部到顶部的高</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        $(<span class="string">&quot;.sidebar&quot;</span>).<span class="title function_">addClass</span>(<span class="string">&quot;fixed&quot;</span>);  <span class="comment">//给侧边栏添加fixed类</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        $(<span class="string">&quot;.fixed&quot;</span>).<span class="title function_">css</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="string">&#x27;width&#x27;</span>:sidebar_w+<span class="string">&#x27;px&#x27;</span>, <span class="comment">//设置宽度</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="string">&#x27;top&#x27;</span>:sidebar_top + <span class="string">&#x27;px&#x27;</span> <span class="comment">//设置上边距</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//如果滚动条高度 &lt;  侧边栏底部到顶部的高</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        $(<span class="string">&quot;.sidebar&quot;</span>).<span class="title function_">removeClass</span>(<span class="string">&quot;fixed&quot;</span>);  <span class="comment">//去除侧边栏的fixed类</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>修改<code>style.css</code> 在<code>style.css</code>查找<code>.sidebar</code>在其下面添加类fixed的样式代码。</li>
</ul>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.fixed</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:fixed;</span><br><span class="line">    <span class="attribute">z-index</span>:<span class="number">999</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后实现效果如图所求。 <img src="/images/2020/01/fix1.gif" alt=""> 最后实现效果是左侧栏滑到底时，直接回到顶部。</p>
<ol>
<li>利用第三方js代码 参照<a href="https://www.mybj123.com/4288.html">博客</a></li>
</ol>
<ul>
<li>下载第三方js 在<a href="https://github.com/WeCodePixels/theia-sticky-sidebar">github</a>下载<code>theia-sticky-sidebar</code></li>
</ul>
<p>放到js目录下，我的目录位置为：<code>/www/wwwroot/onwaier.com/wp-content/themes/twentyfifteen/js</code></p>
<ul>
<li>修改<code>single.php</code>代码 在原代码最后加入以下代码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;http://code.jquery.com/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&lt;?php echo esc_url( get_template_directory_uri() ); ?&gt;/js/theia-sticky-sidebar.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  $(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    $(<span class="string">&#x27;.sidebar&#x27;</span>).<span class="title function_">theiaStickySidebar</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// Settings</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">additionalMarginTop</span>: <span class="number">30</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>最后实现效果如图所求。 <img src="/images/2020/01/fix2.gif" alt=""> 注意：上面代码修改都是<code>single.php</code>，只能修改每篇文章的侧栏滑动效果，如果想要修改首页的侧栏滑动效果，可以修改<code>index.php</code>的代码.</p>
]]></content>
      <categories>
        <category>wordpress</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>弗洛伊德的兔子与乌龟(Floyd&#39;s Tortoise and the Hare algorithm)</title>
    <url>/2020/02/05/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%9A%84%E5%85%94%E5%AD%90%E4%B8%8E%E4%B9%8C%E9%BE%9Ffloyds-tortoise-and-the-hare-algorithm/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://zh.wikipedia.org/zh-hans/Floyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95">Floyd判圈算法</a></li>
<li><a href="http://www.siafoo.net/algorithm/11">Brent’s Cycle Detection Algorithm</a></li>
<li><a href="https://blog.csdn.net/gdymind/article/details/70544153">Floyd判圈算法（龟兔赛跑算法, Floyd’s cycle detection）及其证明</a></li>
<li><a href="https://qht1003077897.github.io/2017/07/03/%E7%AE%97%E6%B3%95-floyd%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/">算法-floyd判环(圈)算法</a></li>
</ol>
<h2 id="算法解读"><a href="#算法解读" class="headerlink" title="算法解读"></a>算法解读</h2><blockquote>
<p>Floyd判圈算法(Floyd Cycle Detection Algorithm)，又称龟兔赛跑算法(Tortoise and Hare Algorithm)，是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，求出该环的起点与长度的算法。该算法据高德纳称由美国科学家罗伯特·弗洛伊德发明。</p>
</blockquote>
<p>引用自<a href="https://zh.wikipedia.org/zh-hans/Floyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95">维基百科-Floyd判圈算法</a></p>
<h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><blockquote>
<p>如何检测一个链表是否有环（循环节），如果有，那么如何确定环的起点以及环的长度。</p>
</blockquote>
<p>引用自<a href="https://blog.csdn.net/gdymind/article/details/70544153">博客</a> 上述问题是一个经典问题，经常会在面试中被问到。我之前在杭州一家网络公司的电话面试中就很不巧的问到，当时是第一次遇到那个问题（毕竟太菜，没有专门准备过算法面试），我思考片刻，问答的是用一个哈希表存储访问的节点的地址，当访问某节点时，发现哈希表中已存在，表明链表中存在环。面试官听了我的回答就反问了我一句：如果链表的环很大，那么哈希表的空间消耗就很大，你的方法并不实用。你能在不消耗额外空间的情况下，找到链表的环吗？当时，想了很久没想到，面试官就说可以这样做，balabala…</p>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ul>
<li>形象化解释</li>
</ul>
<p>解决上述问题的方法就是我们常说的<code>快慢指针</code>。乌龟与兔子在一个含环的跑道上（如图所求）进行比赛，乌龟在单位时间内移动一步，而兔子则在单位时间内移动两步，其移动速度是乌龟的两倍。乌龟与兔子同时从A点出发，兔子移动的快先行进入环形跑道，但那以后，一直在转圈。所以如果存在环的话，乌龟总能与兔子相遇（首次相遇在C点），甚至还能跑到兔子前面:joy:。 <img src="/images/2020/02/5cca0237fddaff11241dcb3204ae8b3c.png" alt=""></p>
<ul>
<li>判断是否有环</li>
</ul>
<p>定义两个指针p1与p2，起始时，都指向链表的起点A，p1每次移动1个长度，p2每次移动2个长度。如果p2在移到链表的尾端时，并未与p1相遇，表明链表中不存在环。如果p1与p2相遇在环上的某一点C，表明链表有环。</p>
<ul>
<li>环的长度</li>
</ul>
<p>将指针p1固定在相遇位置C，移动p2，每次移动1个长度，并用变量<code>cnt</code>计数。当p2再次与p1相遇时，此时<code>cnt</code>的值就是链表的长度。</p>
<ul>
<li>环的起点</li>
</ul>
<p>环的起点即图中点B，将指针p1指向链表的起始位置A，指针p2仍在位置C，指针p1与p2每次均移动一个单位，p1与p2再次相遇的位置就是环的起点位置点B。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul>
<li>伪代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t := &amp;S</span><br><span class="line">h := &amp;S                 //令指针t和h均指向起始节点S。</span><br><span class="line">repeat</span><br><span class="line">    t := t-&gt;next</span><br><span class="line">    h := h-&gt;next</span><br><span class="line">    if h is not NULL       //要注意这一判断一般不能省略</span><br><span class="line">        h := h-&gt;next</span><br><span class="line">until t = h or h = NULL</span><br><span class="line">if h != NULL             //如果存在环的話</span><br><span class="line">    n := 0</span><br><span class="line">    repeat                //求环的度</span><br><span class="line">        t := t-&gt;next</span><br><span class="line">        n := n+1</span><br><span class="line">    until t = h</span><br><span class="line">    t := &amp;S               //求环的一个起点</span><br><span class="line">    while t != h</span><br><span class="line">    t := t-&gt;next</span><br><span class="line">        h := h-&gt;next</span><br><span class="line">P := *t</span><br></pre></td></tr></table></figure>
<p>引用自<a href="https://zh.wikipedia.org/zh-hans/Floyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95">维基百科</a></p>
<ul>
<li>c++代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span><span class="comment">//链表节点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node * next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">findCircle</span><span class="params">(Node * list)</span></span>&#123;</span><br><span class="line">    Node* p1  = list-&gt;next, *p2;<span class="comment">//p1移动1个单位</span></span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line">    <span class="keyword">if</span>(p1 == <span class="literal">NULL</span>)&#123;<span class="comment">//链表只有1个节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p2 = p1 -&gt; next;<span class="comment">//p2移动两个单位</span></span><br><span class="line">    <span class="keyword">while</span>(p1 != p2 &amp;&amp; p2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p2 = p2-&gt;next;<span class="comment">//p2移动两个单位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//存在环，首先求环的长度</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>, p2 = p2-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p2 != p1)&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时cnt就是环的长度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//求环的起点</span></span><br><span class="line">        p1 = list;</span><br><span class="line">        <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时p1与p2都指向环的起点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="简单证明"><a href="#简单证明" class="headerlink" title="简单证明"></a>简单证明</h3><p>借鉴于<a href="https://qht1003077897.github.io/2017/07/03/%E7%AE%97%E6%B3%95-floyd%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/">博客</a> 上面求链表是否存在环及求环的长度的思路都很好理解，主要是为什么p1与p2再次相遇就是环的起点呢？这里假设从跑道的起始点A到环的起点B的路程为m，从B到相遇点C的路程为k，环的长度为n，相遇时乌龟的爬行路程为$S_1 = m + k + t_1 * n$，兔子的奔跑距离为$S_2 = m + k + t_2 * n(t_2 &gt; t_1)$，兔子的速度是乌龟的两倍即$S_2 = 2 * S_1$，则$S_1 = S_2 - S_1 = (t_2 - t_1) * n$，$S_2 = 2 * (t_2 - t_1) * n$即兔子和乌龟相遇时的奔跑距离为环的整数倍，而$m + k = (t_2 - 2 * t_1) * n$也为环的整数倍。当兔子回到跑道的起始位置，乌龟从相遇点B出发时，这时，两人的速度均为单位时间内爬行1个长度，当兔子到达环的起点B即爬行了m距离时，乌龟则是k+m，此时刚好爬行环的整数倍，也处于环的起点B，即乌龟与兔子再次相遇的位置即为环的起点位置B。</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>空间复杂度</li>
</ul>
<p>空间复杂度为：$O(1)$。使用的p1，p2，cnt均为常量空间。</p>
<ul>
<li>时间复杂度</li>
</ul>
<p>假设链表中存在环，则p1移动m个长度即可到达环的起点，p2与p1间的最大距离为n-1。而p2移动速度是p1的两倍，每个单位时间内可以将其与p1的距离缩短1，则最多n-1时间，即可与p1相遇。时间复杂度为$O(m + n)$，即线性时间。</p>
<h2 id="Brent的移动的兔子和传送的乌龟"><a href="#Brent的移动的兔子和传送的乌龟" class="headerlink" title="Brent的移动的兔子和传送的乌龟"></a>Brent的移动的兔子和传送的乌龟</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>How do you determine if your singly-linked list has a cycle? In 1980, Brent invented an algorithm that not only worked in linear time, but required less stepping than Floyd’s Tortoise and the Hare algorithm (however it is slightly more complex). Although stepping through a ‘regular’ linked list is computationally easy, these algorithms are also used for factorization and pseudorandom number generators, linked lists are implicit and finding the next member is computationally difficult.</p>
</blockquote>
<p>引用自<a href="http://www.siafoo.net/algorithm/11">网站</a> 1980年，Brent提出了一种算法，不仅能在线性时间内找到环，并且使用的步数比Floyd的判圈算法要少。</p>
<h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><blockquote>
<p><img src="/images/2020/02/677e7ad79f99cd994a480aaa03b4b11b.png" alt=""> Brent’s algorithm features a moving rabbit and a stationary, then teleporting, turtle. Both turtle and rabbit start at the top of the list. The rabbit takes one step per iteration. If it is then at the same position as the stationary turtle, there is obviously a loop. If it reaches the end of the list, there is no loop. Of course, this by itself will take infinite time if there is a loop. So every once in a while, we teleport the turtle to the rabbit’s position, and let the rabbit continue moving. We start out waiting just 2 steps before teleportation, and we double that each time we move the turtle.</p>
</blockquote>
<p>相比Floyd的兔子与乌龟，Brent的兔子仍然移动，但乌龟静止，达到传送时间t时，乌龟直接移动到兔子当前的位置，然后传送时间t翻倍（t = 2 * t），如此下去，如果兔子到达终点，则表示不存在环，如果兔子与乌龟相遇（兔子回到自己曾去达的位置）表示有环。</p>
<h3 id="算法效率"><a href="#算法效率" class="headerlink" title="算法效率"></a>算法效率</h3><blockquote>
<p>Note that like Floyd’s Tortoise and Hare algorithm, this one runs in O(N). However you’re doing less stepping than with Floyd’s (in fact the upper bound for steps is the number you would do with Floyd’s algorithm). According to Brent’s research, his algorithm is 24-36% faster on average for implicit linked list algorithms.</p>
</blockquote>
<p>兔子仍在不断移动，乌龟的传送使得其位置瞬移，缩短了它与兔子相遇时间。并且传送等待时间的不断翻倍，保证了兔子与乌龟在有限的时间内一定能相遇。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><ul>
<li>伪代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">turtle = top</span><br><span class="line">rabbit = top</span><br><span class="line"></span><br><span class="line">steps_taken = 0</span><br><span class="line">step_limit = 2</span><br><span class="line"></span><br><span class="line">forever:</span><br><span class="line">    if rabbit == end:</span><br><span class="line">       return &#x27;No Loop Found&#x27;</span><br><span class="line">    rabbit = rabbit.next</span><br><span class="line"></span><br><span class="line">    steps_taken += 1</span><br><span class="line"></span><br><span class="line">    if rabbit == turtle:</span><br><span class="line">        return &#x27;Loop found&#x27;</span><br><span class="line"></span><br><span class="line">    if steps_taken == step_limit:</span><br><span class="line">        steps_taken = 0</span><br><span class="line">        step_limit *= 2</span><br><span class="line">        // teleport the turtle</span><br><span class="line">        turtle = rabbit</span><br></pre></td></tr></table></figure>
<p>引用自<a href="http://www.siafoo.net/algorithm/11">网站</a></p>
<ul>
<li>c++代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span><span class="comment">//链表节点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node * next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">findCircle</span><span class="params">(Node * list)</span></span>&#123;</span><br><span class="line">    Node* p1  = list-&gt;next, *p2 = list;<span class="comment">//p1移动1个单位</span></span><br><span class="line">    <span class="type">int</span> steps_taken = <span class="number">1</span>, step_limit = <span class="number">2</span>;</span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line">    <span class="keyword">if</span>(p1 == <span class="literal">NULL</span>)&#123;<span class="comment">//链表只有1个节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 != p2 &amp;&amp; p1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        ++steps_taken;</span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(steps_taken == step_limit)&#123;<span class="comment">//达到传送时间</span></span><br><span class="line">            steps_taken = <span class="number">0</span>;<span class="comment">//步数清0</span></span><br><span class="line">            step_limit = step_limit * <span class="number">2</span>;<span class="comment">//传送时间翻倍</span></span><br><span class="line">            p2 = p1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p1 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//存在环，首先求环的长度</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>, p2 = p2-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p2 != p1)&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时cnt就是环的长度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//求环的起点</span></span><br><span class="line">        p1 = list;</span><br><span class="line">        <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时p1与p2都指向环的起点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>floyd判圈法</tag>
        <tag>兔子与乌龟</tag>
      </tags>
  </entry>
  <entry>
    <title>搭载上vim快速之车</title>
    <url>/2019/08/22/%E6%90%AD%E8%BD%BD%E4%B8%8Avim%E5%BF%AB%E9%80%9F%E4%B9%8B%E8%BD%A6/</url>
    <content><![CDATA[<p>vim通过命令能够快速的对文本内容进行编辑，能快速的移动光标和定位，使用起来非常方便，那怎样为其它的编辑器或IDE设置或扩展vim呢？</p>
<h1 id="sublime开启vim模式"><a href="#sublime开启vim模式" class="headerlink" title="sublime开启vim模式"></a>sublime开启vim模式</h1><p>在菜单栏中： Preferences（首选项） -&gt; Setting - User（设置 - 用户） 即可打开配置文件进行编辑，将 ignored_packages 项的[]里面内容清空：”ignored_packages”: []。 此时按ESC键，便可进入vim的command mode。</p>
<h1 id="vs开启vim模式"><a href="#vs开启vim模式" class="headerlink" title="vs开启vim模式"></a>vs开启vim模式</h1><p>VIM是一款很高效的编辑工具，VS2012以后支持VIM的插件：VsVim。 官网下载地址<a href="https://marketplace.visualstudio.com/items?itemName=JaredParMSFT.VsVim" title="VsVim下载地址">VsVim下载地址</a>。下载安装完成后，打开vs，按ESC键便可进入vim的command mode。</p>
<h1 id="xcode开启vim模式"><a href="#xcode开启vim模式" class="headerlink" title="xcode开启vim模式"></a>xcode开启vim模式</h1><p>参考我在CSDN上写的<a href="https://blog.csdn.net/happyeveryday62/article/details/82956744">博客</a></p>
<h3 id="软件版本要求"><a href="#软件版本要求" class="headerlink" title="_软件版本要求_"></a>_软件版本要求_</h3><p>该插件用于Xcode9.0及以上，Xcode以下版本，请参考 <a href="https://github.com/XVimProject/XVim">https://github.com/XVimProject/XVim</a> 我的Mac系统是Max 10.13.6；Xcode是10.0</p>
<h3 id="对Xcode签名证书"><a href="#对Xcode签名证书" class="headerlink" title="_对Xcode签名证书_"></a>_对Xcode签名证书_</h3><ol>
<li>关闭Xcode</li>
<li>打开钥匙串访问 点击菜单栏 钥匙串访问-&gt;证书助理-&gt;创建证书..</li>
<li>填写证书的信息：名称：XcodeSigner；身份类型：自签名根证书；证书类型：Code Signing，然后点击“创建”</li>
<li>打开命令行，输入如下代码：<code>sudo codesign -f -s XcodeSigner /Applications/Xcode.app</code> 此过程有点漫长，请耐心等待，不要关闭命令行程序</li>
</ol>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="_安装插件_"></a>_安装插件_</h3><ol>
<li>下载插件的源码(使用git命令)：<code>git clone https://github.com/XVimProject/XVim2.git</code></li>
<li>确认<code>xcode-select</code>的指向是否正确，输入命令：<code>xcode-select -p</code>,会返回结果：<code>/Applications/Xcode.app/Contents/Developer</code>,若不是，则通过命令<code>xcode-select -s</code>进行设置，具体如下：<code>xcode-select -s /Applications/Xcode.app/Contents/Developer</code></li>
<li>进行源码目录：git默认下载在家目录下的当前用户的XVim2，命令：<code>cd ./XVim2</code>,然后进行编译,命令：<code>make</code></li>
<li>出现<code>Build Succeeded</code>表示已经编译成功。</li>
</ol>
<h3 id="加载插件"><a href="#加载插件" class="headerlink" title="_加载插件_"></a>_加载插件_</h3><p>打开Xcode时，询问是否加载插件时，点击Load bundle即可。</p>
<h3 id="卸载插件"><a href="#卸载插件" class="headerlink" title="_卸载插件_"></a>_卸载插件_</h3><p>进入源代码目录，然后用命令：<code>make uninstall</code>进行卸载。</p>
<h3 id="致谢"><a href="#致谢" class="headerlink" title="_致谢_"></a>_致谢_</h3><p>参考博客及文章：</p>
<ol>
<li><a href="http://blog.sina.com.cn/s/blog\_5d6f997d0102xrib.html">http://blog.sina.com.cn/s/blog\_5d6f997d0102xrib.html</a></li>
<li><a href="https://www.jianshu.com/p/0345c2b0d04c">https://www.jianshu.com/p/0345c2b0d04c</a></li>
<li><a href="https://github.com/XVimProject/XVim2">https://github.com/XVimProject/XVim2</a></li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>摩尔投票法(Boyer–Moore majority vote algorithm)</title>
    <url>/2020/02/01/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95boyer-moore-majority-vote-algorithm/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://www.cs.ou.edu/~rlpage/dmtools/mjrty.pdf">论文MJRTY A Fast Majority Vote Algorithm</a></li>
<li><a href="https://www.cs.utexas.edu/~moore/best-ideas/mjrty/index.html">算法演示网站</a></li>
<li><a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm">维基百科</a></li>
</ol>
<h2 id="算法解读"><a href="#算法解读" class="headerlink" title="算法解读"></a>算法解读</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p><img src="/images/2020/02/7c1a38379afd4d065b99dba5c9db906d.png" alt=""></p>
</blockquote>
<p>摩尔投票法(Boyer–Moore majority vote algorithm)出自<a href="https://www.cs.ou.edu/~rlpage/dmtools/mjrty.pdf">论文</a>，算法解决的问题是如何在任意多的候选人（选票无序），选出获得票数最多的那个。常见的算法是扫描一遍选票，对每个候选人进行统计的选票进行统计。当候选人的数目固定时，这个常见算法的时间复杂度为：$O(n)$，当候选人的数目不定时，统计选票可能会执行较长时间，可能需运行$O(n^2)$的时间。当选票有序时，可以很容易编出$O(n)$的程序，首先找到中位数，然后检查中位数的个数是否超过选票的一半。这篇论文针对无序且侯选人不定的情形，提出了摩尔投票算法。算法的比较次数最多是选票（记为n）的两倍，可以在$O(n)$时间内选出获票最多的，空间开销为$O(1)$。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><blockquote>
<p><img src="/images/2020/02/6bba7e6867007df07a6f887e20578913.png" alt=""></p>
</blockquote>
<ul>
<li>形象化描述</li>
</ul>
<p>想象着这样一个画面：会议大厅站满了投票代表，每个都有一个牌子上面写着自己所选的候选人的名字。然后选举意见不合的（所选的候选人不同）两个人，会打一架，并且会同时击倒对方。显而易见，如果一个人拥有的选票比其它所有人加起来的选票还要多的话，这个候选人将会赢得这场“战争”，当混乱结束，最后剩下的那个代表（可能会有多个）将会来自多数人所站的阵营。但是如果所有参加候选人的选票都不是大多数（选票都未超过一半），那么最后站在那的代表（一个人）并不能代表所有的选票的大多数。因此，当某人站到最后时，需要统计他所选的候选人的选票是否超过一半（包括倒下的），来判断选票结果是否有效。</p>
<blockquote>
<p><img src="/images/2020/02/5e54af168b5a71ac4d82df10f01f1b57.png" alt=""></p>
</blockquote>
<ul>
<li>算法步骤</li>
</ul>
<p>算法分为两个阶段：<strong>pairing</strong>阶段和<strong>counting</strong>阶段。</p>
<ol>
<li><p><strong>pairing</strong>阶段：两个不同选票的人进行对抗，并会同时击倒对方，当剩下的人都是同一阵营，相同选票时，结束。</p>
</li>
<li><p><strong>counting</strong>阶段：计数阶段，对最后剩下的下进行选票计算统计，判断选票是否超过总票数的一半，选票是否有效。</p>
</li>
</ol>
<blockquote>
<p><img src="/images/2020/02/7bde43514d0c37a58b31d450d109c4df.png" alt=""></p>
</blockquote>
<ul>
<li><strong>pairing</strong>阶段的简化</li>
</ul>
<p>选票不同就要大干一架，太过粗鲁，这里提供一种更加现代化的文明方式。 在场的有个叫<code>onwaier</code>的，他很聪明，他想到一个方法。他用他那犀利人目光扫一遍所有代表们的选票，在脑子记住两件事，当前的候选人的名字<code>cand</code>和他对应的计数<code>k</code>（并不是他的选票数）。起始时，<code>k</code>的值为0，看每个人的选票时，先想想现在<code>k</code>是否为0，如果是0就将<code>cand</code>更新为他将看到的候选人的名字并且将<code>k</code>的值更新为1。观察每个人选票的过程，如果这个人的选票与<code>cand</code>相同，则将<code>k</code>的值加1；否则，将<code>k</code>的值减1。最后的<code>cand</code>可能胜选，还需统计他的总选票数是否超过一半。</p>
<h3 id="算法证明"><a href="#算法证明" class="headerlink" title="算法证明"></a>算法证明</h3><blockquote>
<p><img src="/images/2020/02/4cefdcdf7b2de8fd13ff4f5d4d47f82b.png" alt=""></p>
</blockquote>
<p><strong>证明</strong>： 假设共有n个代表（一人一票，选票总数为n）。当<code>onwaier</code>看到第i个代表的选票时$(1 \leq i \leq n)$，前面他已经看到的所有选票可以分为两组，第一组是<code>k</code>个代表赞同<code>cand</code>；另一组是选票可以全部成对（选票不同）抵销。当处理完所有的选票时，如果存在大多数，则<code>cand</code>当选。 假设存在一个<code>x</code>其不同于<code>cand</code>，但拥有的选票超过$n/2$。但因为第二组的选票可以全部成对抵销，所以<code>x</code>最多的选票数为$(n - k) / 2$，因此<code>x</code>必须要收到第一组的选票才能超过一半，但是第一组的选票都是<code>cand</code>的，出现矛盾，假设不成立。 所以，如果存在大多数，<code>cand</code>就是那个。</p>
<h3 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h3><p>来自<a href="https://www.cs.utexas.edu/~moore/best-ideas/mjrty/index.html">网站</a> 选票情况为： A A A C C B B C C C B C C 结果应该是<code>C</code></p>
<ul>
<li>算法执行过程 <img src="/images/2020/02/algo.gif" alt=""></li>
</ul>
<h3 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h3><ul>
<li>伪代码</li>
</ul>
<p>伪代码来自<a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm">维基百科</a></p>
<blockquote>
<p><img src="/images/2020/02/d9c9ad72b724fb9989247f9050df9b40.png" alt=""></p>
</blockquote>
<ul>
<li>c++代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">根据多数元素出现的次数大于n/2且超过其它元素出现次数之和这一特点，进行统计</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">时间复杂度为：O(n)</span></span><br><span class="line"><span class="comment">空间复杂度为：O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, cand = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//成对抵销阶阶段</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            cand = num;</span><br><span class="line">            k = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(num == cand)&#123;</span><br><span class="line">                ++k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计数阶段 判断cand的个数是否超过一半</span></span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == cand)&#123;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= nums.<span class="built_in">size</span>() / <span class="number">2</span>)&#123;</span><br><span class="line">        cand = <span class="number">-1</span>;<span class="comment">//表示未超过一半 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cand;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法应用"><a href="#算法应用" class="headerlink" title="算法应用"></a>算法应用</h2><p>摩尔投票法的一大应用就是求众数。 相关题目有：</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/majority-element/">169. 多数元素</a></li>
</ol>
<p>其中题1的代码和上面的c++代码相同，它就是摩尔选票法的直接应用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">根据多数元素出现的次数大于n/2且超过其它元素出现次数之和这一特点，进行统计</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">时间复杂度为：O(n)</span></span><br><span class="line"><span class="comment">空间复杂度为：O(1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">摩尔选票法的直接应用，因为题目说明一定存在大多数，所以不用进行第二阶段</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">0</span>)&#123;</span><br><span class="line">                res = num;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(num == res)&#123;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    --cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li><a href="https://leetcode-cn.com/problems/majority-element-ii/">229. 求众数 II</a></li>
</ol>
<p>题2的代码则是摩尔选票法的变形。 题2可以看成这样一个情形：一个班里要选副班长，至多2位。每一个投一票，成为副班长得票必须超过总票数的三分之一。 因为可能会产生两名。所以候选人$cand$与计数$cnt$都转成相应的数组形式$cands$与$cnts$，长度都为2。 第一阶段成对抵销时，<code>cands[0]</code>与<code>cands[1]</code>的选票不相互抵销，即如果代表将票投给了<code>cands[0]</code>，则<code>cands[1]</code>对应的<code>cnts[1]</code>的值不变化。 投给<code>cands[1]</code>也是同样的道理。这样就转化成摩尔投票法的原始情形了。 第二阶段计数时，除了要判断两个候选的票数是否超过三分之一，还需判断两个候选是否相同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">时间复杂度为：O(n)</span></span><br><span class="line"><span class="comment">空间复杂度为：O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res, cands, cnts;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;<span class="comment">//没有元素，直接返回空数组</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        cands.<span class="built_in">assign</span>(<span class="number">2</span>, nums[<span class="number">0</span>]);</span><br><span class="line">        cnts.<span class="built_in">assign</span>(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//第1阶段 成对抵销</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num: nums)&#123;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cands.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num == cands[i])&#123;</span><br><span class="line">                    ++cnts[i];</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                <span class="type">bool</span> flag2 = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cands.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnts[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                        flag2 = <span class="literal">true</span>;</span><br><span class="line">                        cands[j] = num;</span><br><span class="line">                        cnts[j]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!flag2)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnts.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">                        --cnts[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第2阶段 计数 数目要超过三分之一</span></span><br><span class="line">        cnts[<span class="number">0</span>] = cnts[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(cands[<span class="number">0</span>] == cands[<span class="number">1</span>])</span><br><span class="line">            cands.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cands.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cands[i] == num)&#123;</span><br><span class="line">                    ++cnts[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cands.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnts[i] &gt; len / <span class="number">3</span>)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(cands[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>至多选出m个代表，每个选票数大于n / (m + 1)</li>
</ol>
<p>只需要将题2的判断最后候选是否相同代码进行修改即可。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>摩尔投票法</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>深度静态人脸表情识别综述阅读笔记</title>
    <url>/2019/12/05/%E6%B7%B1%E5%BA%A6%E9%9D%99%E6%80%81%E4%BA%BA%E8%84%B8%E8%A1%A8%E6%83%85%E8%AF%86%E5%88%AB%E7%BB%BC%E8%BF%B0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><a href="https://arxiv.org/abs/1804.08348">论文地址</a></p>
<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>人脸表情是人们用来表达情感的最有力，最自然和最普通的方式之一。由于人脸表情识在社交机器人，医学治疗，疲劳驾驶检测和许多人机交互系统的实际应用价值，已经做了很多关于人脸表情识别的研究。早在20世纪，Ekman和Friesen基于人们对于相同表情的表达与种族无关的研究，定义了六种基本的表情。包括愤怒，厌恶，害怕，高兴，悲伤和惊讶。蔑视后来也被加入基本表情中。 尽管基于基本表情的模型在表达人们日常生活中的复杂表情和细微表情上的能力有所不足，像面部动作编码系统（FACS)等可以表示更宽范围，更丰富的表情。但基于基本表情的分类模型仍是FER中最流行的，在这篇综述中，我们也仅在这种分类模型上讨论FER。 FER系统可以根据特征表示被分成两个主要类别：静态图像FER和动态序列FER。在基于静态的方法其特征表示的编码仅包含单个图像的空间信息，而基于动态的方法的特征表示的编码考虑了输入表情序列的连续帧之间的时间关系。用于FER的大多数传统的方法使用的是手工特征或浅层学习（例如，局部二元模式（LBP），非负矩阵分解（NMF）和稀疏学习）。然而，自从2013年起，表情识别比赛，如FER2013和EmotiW，从现实的场景中，收集足够多的训练数据，促使FER从实验室走向实际场景。与此同时，由于芯片的处理能力的急速提高（例如，GPU）和好的网络架构，使得各个领域的研究已开始转移到深度学习的方法，取得了最好的识别精度并且大幅度超过传统方法的识别精度。在表情识别方面，近年来，相关的研究机构也提供了大量的训练数据集，越来越多的深度学习的方法被提出来解决表情识别中一些具有挑战的场景。在图1展示出的Fer相关的算法和数据集的演变。 近年来，关于人脸表情识别的综述有很多，这些综述建立了一系列关于FER的标准算法准则，但是，他们集中于对传统方法的论述，对深度方法很少提及。因此，在这篇文章，对基于静态单张图片的FER任务的深度方法进行了全面的研究。尽管深度学习具有强大的特征学习能力，但应用到FER仍然还存在着一些问题。首先，深度神经网络需要大量的训练数据来防止过拟合，然而，现存在的人脸表情数据集不够充分以致不能训练较好的神经网络模型。另外，由于不同人的年龄，性别，种族背景等导致个体间存在较大的差异。除了个体差异，光照、遮挡和姿态等因素对于人脸表情识别的性能具有较大的影响。 <img src="/images/2019/12/4b5ec059a8211131d8d59f80061ad8df.png" alt=""> 图X 人脸表情识别在数据集及方法上的演变 在这篇论文中，我们介绍一些用于解决以上问题的最新的深度FER的方法。首先，第2章介绍常用的人脸表情数据集，第3章介绍深度EFR系统中最主要的有三个步骤。……</p>
<h2 id="2-人脸表情数据集"><a href="#2-人脸表情数据集" class="headerlink" title="2 人脸表情数据集"></a>2 人脸表情数据集</h2><p>拥有尽可能多的复杂环境的带标签的训练数据庥对于深度人脸表情识别系统的设计量至关重要的。在这一章，我们主要讨论那些包含基本表情，并广泛应用于深度学习算法评估的公共数据集。表X提供了这些数据集的概览。包含人的数量，图片或视频用例的数量，数据集收集的环境，表情的分布和其它信息。 表X 人脸表情数据集概览 <img src="/images/2019/12/0be4fec2069ecea78a486d9d6c8b6400.png" alt=""> CK+:CK+数据集是评估FER系统中应用最广泛的采集于实验室的数据集。CK+数据集包含来自123个人的593个视频序列，这些序列从10帧到60帧数量不等，并且展示出表情从中性到峰值的变化。这些视频序列都标有基于FACS的七个基本的表情标签（愤怒，蔑视，厌恶，害怕，高兴，悲伤，惊讶）。因为CK+并不提供特定的训练集，验证集和测试集，所有算法在这个数据集的评估方式存在差异，基于静态图片的最觉见的数据选取方法是提取每一个视频序列的第一帧，带有峰值信息的三帧及最后一帧。然后，将这些受试者被分成n组来进行n重交叉验证实验，通常选取的n值为5， 8， 10。 JAFFE:日本女性表情数集(JAFFE)是一个在实验室采集的图像数据集，其中包含来自10名日本女性的213张姿态表情。每一个人都有3-4张基本表情(愤怒，厌恶，害怕，高兴，悲伤和惊讶)，有一张中性的表情。由于该数据集拥有较少的图片，导致它具有一定的挑战性。 FER2013:FER2013数据集首次在ICML2013特征学习挑战赛中提出的。FER2013是使用谷歌图片搜索引擎自动收集的大规模，不受约束的数据集。所有的图片大小被调整到$48\times48$的。FER2013中包含28709张训练数据集，3589张验证数据集和3589张测试数据集，每张图片标注有七种标签(愤怒，厌恶，害怕，高兴，悲伤，惊讶和中性)之一。 AFEW:AFEW(Acted Facial Expression in the Wild)数据集自2013年起开始作为每年的EmotiW(Emotion Recognition in the Wild Challenge)的评测平台。AFEW包含来自不同的电影带有连续表情的电影片段，其中涉及姿态，遮挡和光照等复杂环境。每个样例标记有七个表情：愤怒，厌恶，恐惧，高兴，悲伤，惊讶和中性。表情的标签在持续更新，并有现实中的真人秀节目的数据不断增加进来。 EmotiW2017的AFEW 7.0数据集按照来自电影或真人秀的受试者将数据集分成三部分：训练集(773个)，验证集(383个)，测试集(653个)。 SFEW:SFEW(The Static Facial Expressions in the Wild)是基于脸部关键点计算关键帧从AFEW数据集中选取静态帧组成的。最常用的版本是SFEW2.0,其是EmotiW2015中SReco子挑战的基准数据集。SFEW2.0被分成三个数据集：训练数据集(958个)，验证数据集(436个)和测试数据集(372个)。每张图片都被标记为七种表情种类(愤怒，厌恶，害怕，中性，高兴，悲伤和惊讶)的一种。 BU-3DFE:BU-3DFE(Binghamton University 3D Facial Expression)包含来自100个人的606个人脸表情序列。对于每张图片，都显式的标出6种基本表情(愤怒，厌恶，害怕，高兴，悲伤和惊讶)的强度。和Multi-PIE相似，这个数据集通常被用于3D人脸表情分析。 Oulu-CASIA:Oulu-CASIA数据集包含来自80个个体共2880个视频序列，都标有六种基本表情标签：愤怒，厌恶，害怕，高兴，悲伤和惊讶等。环境为近红外光，可见光，三种不同的光照条件。同CK+数据集类似，它的第一帧是中性表情，最后一帧有峰值表情。特别是来自480个视频的最后三帧峰值表情和第一帧用来做10重交叉验证实验。 EmotionNet:EmotionNet是一个大型的数据集，它拥有100万张收自网络的人脸表情图片。其中的95万张图片用AU检测模型(action unit)来自动标注，剩下的25万张图片则是用11AUs去手动标注。在EmotinNet挑战赛上，提供了带有6种基本表情和10种综合表情标签的2478张图片。 RAF-DB:RAF-DB(Real-world Affective Face Database)是包含下载自互联网的29672张表情图片的真实世界的数据集。借助手动标注和可靠的估算，每个样例标有7个基本表情和11个综合表情标签。基本表情数据集中15339张图片被分成两组(12271个训练样例和3068个测试用例)用来评估算法性能。 AffectNet:AffectNet数据集包含来自网络的100多万张图片，每张图片使用不同的搜索引擎用与表情相关的关键字查询所获得。其中的45张图片已经被手式标注了8个基本表情标签。 ExpW:ExpW(Expression in-the-Wild Database)包含91793张使用google图片搜索引擎下载的人脸图片，每一张人脸的图片都被手动标注为7种基本表情的一种，无人脸的图片将在标注过程中移除掉。</p>
<h2 id="3-深度人脸表情识别"><a href="#3-深度人脸表情识别" class="headerlink" title="3 深度人脸表情识别"></a>3 深度人脸表情识别</h2><p>这一章，我们将介绍了深度FER中最主要的三个步骤，预处理，深度特征提取和深度特征分类。我们简短的总结了每个步骤广泛使用的算法。</p>
<h3 id="3-1-预处理"><a href="#3-1-预处理" class="headerlink" title="3.1 预处理"></a>3.1 预处理</h3><p>一些变量像不同的背景，光照和姿态等都与人脸表情不相关，但是在无约束的场景是普通存在的。因此，在训练神经网络去学习有用的特征之前，需要用预处理来对齐人脸并规范人脸所传达出的视觉语义信息。</p>
<h4 id="3-1-1-人脸对齐"><a href="#3-1-1-人脸对齐" class="headerlink" title="3.1.1 人脸对齐"></a>3.1.1 人脸对齐</h4><p>人脸对齐在很多与人脸相关的识别的任务中是一个预处理的步骤。我们列出了一些广泛应用深度FER并公开算法实现的算法。对于训练数据，首先第一步是检测人脸，然后去除人脸和不相关的区域。Viola-Jones(V&amp;J)人脸检测器是一个经典的并广泛应用人脸检测的检测器，它具有很强鲁棒性，并且计算简单。 表X 在深度FER中广泛应用的人脸对齐检测器的总结 <img src="/images/2019/12/4d9a486faa0dc8cab2641656b27f5263.png" alt=""> 尽管人脸检测是特征学习前唯一的必不可少的过程，在检测后的人脸使用人脸对齐能进一步提高FER的性能。这一步是至关重要的，因为它能减小人脸规模和平面内旋转的变化。表X研究了广泛应用在深度FER中的人脸关键点检测算法并比较他们的执行效率及性能。主动外观模型(Active Appearance Model)是一个典型的生成式模型，优化全局的人脸外观和形状模型的参数。在判别式模型中，MoT(mixtures of trees)和DRMF(Disctiminative response map fitting)通过关键点周围的局部外观信息来表示人脸。另处，还有大量的差别式模型直接使用级联回归函数将图像外观特征映射到关键点位置，并显示更好的结果。比如在IntraFace中实现的SDM(supervised descent method)，3000 fps和增量人脸对齐等等。最近，深度网络也广泛应用于人脸对齐。级联CNN是第一个用级联的方式来预测人脸关键点的深度算法。基于此，TCDCN(Tasks-Constrained Deep Convolutional Network)和多任务CNN(MTCNN)进一步利用多任务学习来提升性能。一般情况下，级联回归由于其高速和高精确度已经成为最流行和最新的算法。</p>
<h4 id="3-1-2-数据增强"><a href="#3-1-2-数据增强" class="headerlink" title="3.1.2 数据增强"></a>3.1.2 数据增强</h4><p>深度卷积神经网络要求足够多的数据来确保模型在指定的识别任务下的泛化能力。然而大部分公开的人脸数据集并没有充分的人脸数据用于训练，因此，数据增强是深度FER中至关重要的一步。数据增增技术可分为两类：线下数据增强和在线数据增强。 通常情况下，线上数据增强被加入深度学习工具箱来防止过拟合。在训练过程中，输入的图片从图像的四角和中心随机裁剪，然后水平翻转，就能使得训练的数据集是原始的十倍。除了基础的线上数据增强，各种各样的离线数据增强被用来进一步扩充数据。最常用的操作包括：旋转，平移，尺寸变换，噪声，反转，畸变等。比如，常见的噪声模型像椒盐噪声，高斯噪声等被用于扩大数据量。多种操作相结合可以生成更多看不到的训练数据，使网络模型的鲁棒性更强。</p>
<h4 id="3-1-3-人脸归一化"><a href="#3-1-3-人脸归一化" class="headerlink" title="3.1.3 人脸归一化"></a>3.1.3 人脸归一化</h4><p>人脸图片中光照和头部姿态的变化对FER的性能有很大的影响，因此，我介绍了两种典型的人脸归一化方法来减少这些变化带来的影响：光照归一化和姿态归一化。 光照归一化：光照在不同的图片中都存在差异，即使是同一个人的相同表情也存在不同的光照，尤其在非限制的环境下，它会对结果产生很大影响。在[60]中，总结了几个常用的光照归一化方法：基于各向同性扩散归一化（isotropic diffusion-based normalization）、基于离散余弦变换归一化（DCT-based normalization）和高斯差分（DoG）。在[86]中使用了同态滤波归一化的方法，其相比其它方法，产生更加一致的结果。另外，有相关研究显示，将光照归一化与直方图均衡化相结合在人脸表情识别的性能比只使用光照归一化的性能要好。许多对深度FER的研究都在预处理阶段采用直方均衡图来增加图像整体的对比度。当图像的前景与背景的高度较接近时，这种方法是比较有效的。 姿态归一化：考虑到姿态变化在非受限的环境下是另一个常见的问题。一些研究采用姿态归一化技术来生成正面人脸图。其中Hassner提出的方法是最常用的，在对人脸的关键点进行定位后，对所有的人脸生成一个3D纹理参考模型估计可视人脸部分，然后将输入的人脸投影到参考的坐标系上，合成的人脸的正面图。最近，也提出了一些基于GAN的生成正面人脸的深度网络模型(FF-GAN，TP-GAN和DR-GAN)。</p>
<h3 id="3-2-特征学习深度网络"><a href="#3-2-特征学习深度网络" class="headerlink" title="3.2 特征学习深度网络"></a>3.2 特征学习深度网络</h3><p>深度学习最近是一个很火热的研究话题，在很多应用上都取得最新的性能表现。深度学习尝试使用多个非线性的转换和表示结构来捕获更高层次的特征抽象。在这一章，我们简短地介绍了应用于FER的深度学习技术。这些深度神经网络的结构如图X所示。 图X 深度表情识别系统的一般步骤 <img src="/images/2019/12/0aa27fad76d8353cb418220e2956e02a.png" alt=""> CNN在计算机视觉中广泛应用，一个CNN结构通常包含卷积层、池化层和全连接层等。在表X中我们列出了一些著名的CNN模型的构成和特征。除了这些神经网络，基于区域的CNN(R-CNN)也被用于FER中的特征学习，Faster R-CNN 通过生成高质量候选区域，识别面部表情。Ji et al提出的3D CNN通过3D卷积来对捕获多个相邻帧之间的动作信息来对动作进行识别。深度信念网络(DBN)是由Hinton提出的，学习提取训练数据的深度层次表示。DBN中，较高层的单元被训练去学习相邻低层的单元间的条件依赖，除了最高的两层，其余都没能直接连接。DBN的训练包含两个阶段：预训练和微调。首先用逐层贪婪训练方法初始化深度网络，可以在不需要大量标注数据的情况下防止局部最优解。然后，用有监督的梯度下降对网络的参数和输出进行微调。深度自编码器(Deep autoencoder)首次在[118]中提出来学习特征降维的有效编码，与之前的方法不同，DAE通过最小化重建误差来优化输入的重建。目前存在很多种DAE:降噪自编码器，可从部分损坏的数据中恢复原始未损坏数据；稀疏自编码网络，增强学习得到的特征表示的稀疏性；压缩式自编码器，增加活动相关正则项以提取局部不变特征；卷积自编码器，使用卷积层代替 DAE 中的隐藏层。循环神经网络(RNN)是联结主义的模型，能捕捉时间信息，对于任意长度的序列数据的预测是更合适的。时间的反向传播(BPTT)被用来训练RNN。由Hochreiter和Schmidhuber提出的LSTM是传统的RNN的一种特殊的形式被 用来解决常常出现在训练RNNs中的梯度消失和梯度爆炸的问题。LSTM能学习序列中的长时依赖，被广泛用于基于视频的表情识别的任务。 <img src="/images/2019/12/58ea92f93e35e07ace50018111b7a7ae.png" alt=""></p>
<h3 id="3-4-人脸表情分类"><a href="#3-4-人脸表情分类" class="headerlink" title="3.4 人脸表情分类"></a>3.4 人脸表情分类</h3><p>在学习到深度特征后，FER的最后一步是将给定的人脸进行表情分类。传统深度的特征提取和特征分类是相互独立的，而深度网络用一种端到端的形式来完成FER任务。特别是，在网络的最后能加入损失层来减少反向传播的误差，并且在网络的最后能够直接给出每个实例的预测概率。 在CNN中，softmax损失函数是最常使用的用来最小化预测类别与ground truth之间的交叉熵。论文[130]表明在端到端训练中使用支持向量机(SVM)分类比交叉熵的表现要好。 除了端到端的学习方式，另一种可选用的方式是采用深度神经网络(CNN)进行特征提取，然后再使用额外的分类器进行特征分类，比如支持向量机或随机森林等。</p>
<h2 id="4-最新方法"><a href="#4-最新方法" class="headerlink" title="4 最新方法"></a>4 最新方法</h2><p>在这一章，我们对用于FER的深度神经网络和用于表情相关问题而提出的训练策略进行研究。我们提供了现在的深度FER系统在常见的数据集上的性能表现。由于一些数据集并没有提供明确的提供训练，测试和验证集，与之相关的研究可能在不同的数据集，不同的实验条件下进行的，所以，我总结了识别实验有关数据集的选取与分组方法的信息。在静态图片上进行的表情分类研究有很多，因为不用考虑时间信息，并且数据处理方便，与训练和测试有关的数据集易获得。我们首先介绍了FER中预训练和微调的技巧，然后研究了这个领域的深度神经网络，对最常评估的数据集，在表X中显示在最新方法的性能表现。</p>
<h3 id="4-1-预训练和微调"><a href="#4-1-预训练和微调" class="headerlink" title="4.1 预训练和微调"></a>4.1 预训练和微调</h3><p>在相当小的数据集上直接训练，容易造成过拟合。为了解决这种总是，很多研究先在其它数据集上进行预训练，然后在训练好的网络进行微调(如AlexNet，VGG，GoogleNet等)。Kahou et al.实验证明使用额外的数据集能够帮助模型避免过拟合，并且能够提升FER的性能表现。 比起直接在预训练或微调的模型上对目标数据集进行特征提取，一个多阶段的微调策略(如图X所示)能获得更好的性能。第一阶段在预训练模型上使用 FER2013 进行微调，第二阶段利用目标数据库的训练数据进行微调，使模型更切合目标数据库。 <img src="/images/2019/12/ec8888ead8f53b10b67a889f1b0decb0.png" alt=""> Ding 等人发现由于 FR 和 FER 数据库之间的差距，人脸主导的信息仍然遗留在微调的 FR 网络中，削弱了网络表示不同表情的能力。提出FaceNet2ExpNet的训练策略，如图X所示。微调的网络作为表情网络的初始值，仅能引导卷积层的学习，全连接层的训练则从头开始。</p>
<h3 id="4-2-辅助网络块"><a href="#4-2-辅助网络块" class="headerlink" title="4.2 辅助网络块"></a>4.2 辅助网络块</h3><p>基于CNN的基础架构，一些研究提出了一些设计好的辅助块或辅助层来增强学习到的与表情相关的特征的表达能力。 一个新颖的CNN网络HoloNet将CReLU与强有力的残差结构相结合，加深网络的深度。[165]设计出一个辅助块用于学习多尺度的特征来捕获人脸的变化。Hu 等人将 3 类有监督网络块嵌入 CNN 结构的实现浅层、中层和深层的监督。这些块根据原网络的层级特征表示能力设计。随后，每个块的类间评分在连接层进行累积，进行第二级的监督，如图所求。 图X [91]中三个不同的有监督网络块 <img src="/images/2019/12/13d927eddee7b0114773b851c84ba1dd.png" alt=""> FSN(Feature Selection Network)是在AlexNet中加入了一个特征选择机制，它能自动过滤掉不相关特征，然后根据对人脸表情特征图的学习突出相关特征。Zeng et al.提出了IPA2LT(Inconsistent Pseudo Annotations to Latent Truth)结构，它通过将人类标注与机器标注最大似然化来发现不同数据集间机器的潜在真值。Cai 等人提出岛损失层。如图X所求。特征提取层计算的岛损失层和决策层计算的 softmax 损失结合起来监督 CNN 训练。Liu 等人提出（N+M）组聚类损失层。如图X所求在训练过程中，身份感知的难分样本挖掘和积极样本挖掘技巧用于降低同一表情类别下身份内部的变化所带来的影响。 图X [140]中的岛损失层 <img src="/images/2019/12/7ad67fb3293c4c2942e3b5e2fa6aa965.png" alt=""> 图X [77]组聚类损失层 <img src="/images/2019/12/2b20c764de9cb3ec5fb77145e7b61c97.png" alt=""></p>
<h3 id="4-3-网络集成"><a href="#4-3-网络集成" class="headerlink" title="4.3 网络集成"></a>4.3 网络集成</h3><p>之前的研究表现多个网络的集成性能优于单个网络，在网络集成时，有两点需要注意：(1)多个网络的集成应确保功能多样且互补，而不是相同功能的堆砌。(2)采用合适的集成方法来有效地发挥各个网络的作用。 对于第一点，采用前面提到的预处理方法能产生不同的数据来训练多样的网络，通过改变卷积核的大小，层数，神经元的数目，采用随机初始化的方法来初始网络权重能加强网络的多样性。除此之外，不同的网络结构也能增加多样性。比如将用有监督学习的CNN与无监督学习的CAE进行网络集成。 对于第二点，网络可以在两个不同层面上进行组合：特征层和决策层。对于特征层，最常采取的方法是将不同网络学习得到的特征连接起来，组成一个新的特征矢量，来表示图像。如图X所求。在决策层，常用的三种方法是：多数投票、简单平均和加权平均。Kim 等人提出 3 级组合结构，在决策层融合，获取充分的决策多样性。如图X所求。 <img src="/images/2019/12/6574deac6966e6fb214b26aa1eb07956.png" alt=""> <img src="/images/2019/12/94183af7e151c18d0fdaafd1f719dda6.png" alt=""></p>
<h3 id="4-4-多任务网络"><a href="#4-4-多任务网络" class="headerlink" title="4.4 多任务网络"></a>4.4 多任务网络</h3><p>现在存在的很多网络都是单任务网络，学习到的特征由于没有考虑其它潜在因素与表情的联系，对表情敏感。然而真实世界中，FER和多个因素相关，像头的姿态，光照，个体差异等。为了解决这类问题，引入了多任务学习，将知识从其他相关任务中迁移出来，消除不利因素。 Reed等构造了建造了一个高阶玻尔兹曼机（disBM）学习与表情相关因素的流形坐标并提出了一种训练策略消除与表情相关的因素的影响。其它研究，将FER与其它任务同时进行，比如脸部关键点定位和脸部的Aus检测，它们的结合能有效提高FER的性能。除此之外，IACNN(Identity-aware CNN)采用两个完全相同的子CNN，一个使用对比损失来学习判别式表情特征，另一个用对比损失学习个体相关特征，在 Zhang 等人提出的 MSCNN 中，在训练时一对图像输入 MSCNN 网络。表情识别任务使用交叉熵损失，学习表情变化特征，面部识别人任务使用对比损失，减少同类表情特征之间的变化。如图X所示。 <img src="/images/2019/12/408646cae912d941c168a366044b808d.png" alt=""></p>
<h3 id="4-5-注意力网络"><a href="#4-5-注意力网络" class="headerlink" title="4.5 注意力网络"></a>4.5 注意力网络</h3><p>Attention机制在近几年来在图像，自然语言处理等领域中都取得了重要的突破，被证明有益于提高模型的性能。Attention机制本身也是符合人脑和人眼的感知机制，聚焦于局部信息的机制。 图X FERAtt的网络结构 <img src="/images/2019/12/d29bc1632f7df1393fab830ccf05a6b0.png" alt=""> 现在的很多研究，都是整张进行处理，引入噪声和不必要的计算。仿照人的注意力机制，Fernandez等人提出了一种注意力网络，如图X所求。共分为四个模块：注意力模块、特征提取模块、重建模块和分类再表示模块。并设计出高斯损失函数来优化特征表示。针对遮挡和姿态两大难题，Kai Wang等在FERplus，AffectNet、RAF-DB三个数据集的基础上筛选遮挡和姿态较大的图片创建了六个数据集Occlusion-FERPlus, Pose-FERPlus, Occlusion-AffectNet, Pose-AffectNet, Occlusion-RAF-DB, and Pose-RAF-DB。并设计出RAN(Region Attention Networks)，如图X所求。并设计了RB-Loss，来提升区域在特征表示上的权重。该方法在多个数据集均有较大的性能提升。陆续将会有更多基于Attention机制的FER网络被提出，它在某些问题上的性能表现优于一般的网络结构。 图X RAN网络结构 <img src="/images/2019/12/524e8bcdcb9d396186e851924a7fb059.png" alt=""> 表X比较了不同类型的方法(预处理微调，辅助层，网络集成，多任务网络，注意力网络)对于数据大小的要求，在复杂环境(头的姿态，光照，遮挡和其它环境因素)的性能，计算效率，准确率，网络训练的难度。 <img src="/images/2019/12/a01d457b9b2c0c90c7a56549e8718fe4.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于 FER 研究将其主要关注点转移到具有挑战性的真实场景条件下，许多研究人员利用深度学习技术来解决这些困难，如光照变化、遮挡、非正面头部姿势、身份偏差和低强度表情识别。考虑到 FER 是一个数据驱动的任务，并且训练一个足够深的网络需要大量的训练数据，深度 FER 系统面临的主要挑战是在质量和数量方面都缺乏训练数据。由于不同年龄、文化和性别的人以不同的方式做出面部表情，因此理想的面部表情数据集应该包括丰富的具有精确面部属性标签的样本图像，不仅仅是表情，还有其他属性，例如年龄、性别、种族，这将有助于跨年龄、跨性别和跨文化的深度 FER 相关研究。另一方面，对大量复杂的自然场景图像进行精准标注是构建表情数据库一个明显的障碍。</p>
]]></content>
      <categories>
        <category>人脸表情识别</category>
      </categories>
      <tags>
        <tag>表情识别</tag>
        <tag>阅读笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>湖南大学校园网及VPN使用中遇到的问题</title>
    <url>/2019/08/30/%E6%B9%96%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E5%9B%AD%E7%BD%91%E5%8F%8Avpn%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h2><ol>
<li>手机可以连接湖南大学的wifi(hnu)，电脑有线通过拨号也能连接，唯独电脑不能连接无线且输入用户名（账户）和密码，点击登录时，会出现Server is not responding的错误?</li>
</ol>
<h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a><strong>解决方法</strong>：</h2><p>电脑连接hnu wifi，然后更改适配器设置，在WLAN(hnu)上单击右键，打开属性。 <a href="https://i.loli.net/2019/08/30/1MjDVlGC53gxpEU.png"><img src="https://i.loli.net/2019/08/30/1MjDVlGC53gxpEU.png" alt=""></a> 双击Internet协议版本4会弹出属性设置框，然后设置为自动获取ip地址，自动获取DNS服务器地址。 <a href="https://i.loli.net/2019/08/30/XEAeDbR1iNBjkgG.png"><img src="https://i.loli.net/2019/08/30/XEAeDbR1iNBjkgG.png" alt=""></a> 此时打开校园网登录界面（以前我是需要手动输入ip地址才能进到登录界面，自动获取dns后，打开网页，登录界面会弹出，这是修改有效的一个明显变化），输入用户名和密码，就可以成功使用湖南大学的校园网。 这个方法不一定会适合你，写出来只是希望分享我遇到的问题及解决方案，之前在网上找了好久都没有与之相关的博客，希望它能在一定程度上解决你的问题。</p>
<h2 id="问题描述：-1"><a href="#问题描述：-1" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h2><ol>
<li>湖南大学校园网VPN使用过程中突然断开，然后出现“许可用尽”的错误提示</li>
</ol>
<h2 id="解决方法：-1"><a href="#解决方法：-1" class="headerlink" title="解决方法："></a><strong>解决方法</strong>：</h2><p>在系统最小化托盘中找到湖南大学VPN应用，然后单击右键，有三个选项，选择中间“还原”键，这时再重新登录校园网VPN，这在一定程度上能解决校园网VPN许可用尽的问题。</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>湖南大学VPN</tag>
        <tag>湖南大学校园网</tag>
      </tags>
  </entry>
  <entry>
    <title>第十八次CCF计算机软件能力认证总结与经验分享</title>
    <url>/2019/12/17/%E7%AC%AC%E5%8D%81%E5%85%AB%E6%AC%A1ccf%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%8F%E9%AA%8C%E5%88%86/</url>
    <content><![CDATA[<h2 id="成绩"><a href="#成绩" class="headerlink" title="成绩"></a>成绩</h2><p>首先晒一下成绩。 <img src="https://img-blog.csdnimg.cn/2019121620505333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9vbndhaWVyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="成绩"> 成绩单 <img src="/images/uploads/2019/12/c0f821c46377bbd42f81edda936af279.png" alt="成绩单"></p>
<h2 id="认证经历"><a href="#认证经历" class="headerlink" title="认证经历"></a>认证经历</h2><p>这是第二次参加CCF认证，第一次是在大四的时候，部分考研的同学需要用CCF的成绩作为考研复试机试成绩，找班主任（也是院长）请假去其它学校参加考试。院长一听，就去了解一下CCF认证，觉得还不错，就向那边将我们学校申请为CCF考点，但是一次CCF考试的报名的人数需要达到一定人数才能进行，然后就出现了下面戏剧性的一幕：院长要求XX，XX和XX几个专业的所有大四学生必须参加第16次的CCF考试，并且免报名费，学院出钱。我就这样参加了CCF的考试。第一次参加CCF考试，经验不足。虽然平时有刷天梯赛和蓝桥杯的题目，但是两者的出题思路及考查点不太一样，特别是CCF第3题的题目长度在蓝桥杯和天梯赛基本见不到。并且第16次认证的题目比往年难多了，第2题求中缀表达式的值，这是栈的常见的应用，当时比较执拗，想的是如何用栈将中缀表达式转成后缀表达式，然后再用栈对后缀表达式的值，在这道题上花费了太长时间，到了最后才选择暴力的方法，看了第3题和第4题的题目，选择做了第4题，与进程死锁有关。当时很快有了模拟的思路，写完时间也差不多了，赛后第4题得了80分还不错。但是第1题却破天荒的错了，后来分析错误原因：用了g%的格式控制符。但最后提交只得了一点分，所以，这里需要提醒各位的是，考试建议使用常用的写法，有一些写法不同的编译器不一定能通过。总的来说，第一次认证考试体验感不是很好，题目长（3 4题都很大，并且涉及专业知识看了比较难受）并且题目有些问题，中途组委会通知改的。考试时采用的策略也不够明智，在第2道上花费太长时间，很大一部分时间是想着如何用常规解法去解题，而忽略了快捷的暴力解法。 周日参加的第二次CCF认证考试，题意很好理解。很快把1、2和4题做出来了（大概花了一个半小时），这里大概说一下解题思路。</p>
<h3 id="201912-1报数-题解"><a href="#201912-1报数-题解" class="headerlink" title="201912-1报数 题解"></a>201912-1报数 题解</h3><p>题目大意是4个人轮流报数从1开始，遇到7的倍数或含7的数就跳过。题目输入是n表示的4个人总共报的数（不含跳过的数）。 思路很简单：模拟用idx表示当前报数人的编号，num表示当前报的数，i计数（不含路过的数）。如果当前数是7的倍数或含7的数，则idx跳过的数加1，然后i不变。反之，idx跳过的数不变，i+1。</p>
<h3 id="201912-1报数-考试时代码（100分）"><a href="#201912-1报数-考试时代码（100分）" class="headerlink" title="201912-1报数 考试时代码（100分）"></a>201912-1报数 考试时代码（100分）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num % <span class="number">7</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tmp = num;</span><br><span class="line">    <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp % <span class="number">10</span> == <span class="number">7</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = tmp / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;D://a.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="type">int</span> n, cnt[<span class="number">4</span>], num = <span class="number">0</span>, idx = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;)&#123;</span><br><span class="line">        ++num;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">judge</span>(num))&#123;</span><br><span class="line">            ++cnt[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        idx = (idx + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="201912-2回收站选址-题解"><a href="#201912-2回收站选址-题解" class="headerlink" title="201912-2回收站选址 题解"></a>201912-2回收站选址 题解</h3><p>题目大意：先给所有垃圾堆的坐标，然后从这些垃圾堆中选出回收站，回收站需满足：首先上下左右必须都是垃圾堆，然后4个对角的垃圾堆的个数表示该回收站的分数。最后需要统计的是得分为0， 1， 2， 3， 4回收站的个数。 思路：首先选用map对所有垃圾堆的坐标进行标记（因为垃圾堆的坐标可能为负值，用int数组不能直接标记，除非用哈希函数映射），并用vector存下所有垃圾堆的坐标。然后遍历vector中按题目给出的要求判断即可。注意这里vector中的元素和map的键都是pair类型。</p>
<h3 id="201912-2回收站选址-考试时的代码（100分）"><a href="#201912-2回收站选址-考试时的代码（100分）" class="headerlink" title="201912-2回收站选址 考试时的代码（100分）"></a>201912-2回收站选址 考试时的代码（100分）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">bool</span>&gt;myMap;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;vec;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> dir2[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;D://a.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="type">int</span> n, x, y, nx, ny;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    myMap.<span class="built_in">clear</span>();</span><br><span class="line">    vec.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(x, y));</span><br><span class="line">        myMap[<span class="built_in">make_pair</span>(x, y)] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        x = vec[i].first;</span><br><span class="line">        y = vec[i].second;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">            nx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            ny = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(myMap.<span class="built_in">find</span>(<span class="built_in">make_pair</span>(nx, ny)) == myMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">                nx = x + dir2[i][<span class="number">0</span>];</span><br><span class="line">                ny = y + dir2[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(myMap.<span class="built_in">find</span>(<span class="built_in">make_pair</span>(nx, ny)) != myMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    ++num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="201912-4区块链-题解"><a href="#201912-4区块链-题解" class="headerlink" title="201912-4区块链 题解"></a>201912-4区块链 题解</h3><p>我的理解是：首先根据题意可以建图，然后图中的每个结点都维持了一条链，每个结点初始时，链上都有一个编号为0的初始块。然后有两个操作：查询操作和更新操作。在进行查询操作和更新操作都需要检查在此之前，是否存在其它节点的更新操作的信息传过来，如果有的话，则需要判断传播节点的主链$l_1$与当前节点的主链$l_2$关系，$l_1$的长度大于$l_2$的长度，直接令$l_2$ = $l_1$。如果$len(l_1)=len(l_2)$且$l_1$的最后一个元素的值小于$l_2$的最后一个值，则令$l_2$ = $l_1$。注意，一旦结点维持的主链的信息更新，就需要将其传播给相邻节点（存在传播时长）。我考试的时侯是用一个队列来维持这个传播的更新信息，存储的元素包含节点值，信息到达节点的时刻，主链三个信息。我估计可能是数据太大的时候，队列可能会内存超限。</p>
<h3 id="201912-4区块链-考试时的代码（70分）"><a href="#201912-4区块链-考试时的代码（70分）" class="headerlink" title="201912-4区块链 考试时的代码（70分）"></a>201912-4区块链 考试时的代码（70分）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> time;</span><br><span class="line">    <span class="type">int</span> u;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;vec;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;Node&gt;que;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">gra</span>(<span class="number">505</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">block</span>(<span class="number">505</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">toNum</span><span class="params">(string s, vector&lt;<span class="type">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">    res.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[i]))&#123;</span><br><span class="line">            num = num * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(num);</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num != <span class="number">0</span>)</span><br><span class="line">        res.<span class="built_in">push_back</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;D://a.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="type">int</span> n, m, t, k;</span><br><span class="line">    <span class="type">int</span> u, v, a, b, c;</span><br><span class="line">    string s;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    gra.<span class="built_in">clear</span>();</span><br><span class="line">    block.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">505</span>; ++i)&#123;</span><br><span class="line">        block[i].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        gra[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        gra[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;t, &amp;k);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">        <span class="built_in">getline</span>(cin, s);</span><br><span class="line">        <span class="built_in">toNum</span>(s, res);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            Node frt = que.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">if</span>(frt.time &lt;= res[<span class="number">1</span>])&#123;</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> u = frt.u, v;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; gra[u].<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">                    v = gra[u][i];</span><br><span class="line">                    <span class="keyword">if</span>(block[v].<span class="built_in">size</span>() &lt; frt.vec.<span class="built_in">size</span>())&#123;</span><br><span class="line">                        block[v] = frt.vec;</span><br><span class="line">                        Node tmp;</span><br><span class="line">                        tmp.time = frt.time + t;</span><br><span class="line">                        tmp.u = v;</span><br><span class="line">                        tmp.vec = block[v];</span><br><span class="line">                        que.<span class="built_in">push</span>(tmp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(block[v].<span class="built_in">size</span>() == frt.vec.<span class="built_in">size</span>())&#123;</span><br><span class="line">                        <span class="keyword">if</span>(block[v].<span class="built_in">back</span>() &gt; frt.vec.<span class="built_in">back</span>())&#123;</span><br><span class="line">                            block[v] = frt.vec;</span><br><span class="line">                            Node tmp;</span><br><span class="line">                            tmp.time = frt.time + t;</span><br><span class="line">                            tmp.u = v;</span><br><span class="line">                            tmp.vec = block[v];</span><br><span class="line">                            que.<span class="built_in">push</span>(tmp);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">size</span>() == <span class="number">3</span>)&#123;<span class="comment">//update</span></span><br><span class="line">            block[res[<span class="number">0</span>]].<span class="built_in">push_back</span>(res[<span class="number">2</span>]);</span><br><span class="line">            Node tmp;</span><br><span class="line">            tmp.time = res[<span class="number">1</span>] + t;</span><br><span class="line">            tmp.u = res[<span class="number">0</span>];</span><br><span class="line">            tmp.vec = block[res[<span class="number">0</span>]];</span><br><span class="line">            que.<span class="built_in">push</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> u = res[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, block[u].<span class="built_in">size</span>());</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; block[u].<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, block[u][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="201912-3化学方程式-题解"><a href="#201912-3化学方程式-题解" class="headerlink" title="201912-3化学方程式 题解"></a>201912-3化学方程式 题解</h3><p>题目大意：化学方程式配平，检查两边的元素是否相等。 考试只考虑了60%的测试用例，带括号的一直调试不通（其实也算不上调试，我的调试有问题，只能用printf慢慢输出了）。具体见代码，过60%很容易。</p>
<h3 id="201912-3化学方程式-考试时的代码（60分）"><a href="#201912-3化学方程式-考试时的代码（60分）" class="headerlink" title="201912-3化学方程式 考试时的代码（60分）"></a>201912-3化学方程式 考试时的代码（60分）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;myMap1, myMap2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deal</span><span class="params">(string s, map&lt;string, <span class="type">int</span>&gt;&amp; myMap)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>, len = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[i]))&#123;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isdigit</span>(s[i]))&#123;</span><br><span class="line">                num = num * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isupper</span>(s[i]))&#123;</span><br><span class="line">            string tmp;</span><br><span class="line">            <span class="type">int</span> sum = num;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; len - <span class="number">1</span> &amp;&amp; <span class="built_in">islower</span>(s[i + <span class="number">1</span>]))&#123;</span><br><span class="line">                ++i;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; len - <span class="number">1</span> &amp;&amp; <span class="built_in">isdigit</span>(s[i + <span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="type">int</span> tmpNum = <span class="number">0</span>;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; len &amp;&amp; <span class="built_in">isdigit</span>(s[i]))&#123;</span><br><span class="line">                    tmpNum = tmpNum * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                --i;</span><br><span class="line">                sum = sum * tmpNum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(myMap.<span class="built_in">find</span>(tmp) != myMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">                myMap[tmp] = myMap[tmp] + sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                myMap[tmp] = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cal</span><span class="params">(string s, map&lt;string, <span class="type">int</span>&gt;&amp; myMap)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>, tmp;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span>((tmp = s.<span class="built_in">find</span>(<span class="string">&#x27;+&#x27;</span>, idx)) != <span class="number">-1</span>)&#123;</span><br><span class="line">        str = s.<span class="built_in">substr</span>(idx, tmp - idx);</span><br><span class="line">        <span class="built_in">deal</span>(str, myMap);</span><br><span class="line">        idx = tmp + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    str = s.<span class="built_in">substr</span>(idx);</span><br><span class="line">    <span class="built_in">deal</span>(str, myMap);</span><br><span class="line"><span class="comment">//  for(auto iter = myMap.begin(); iter != myMap.end();++iter)&#123;</span></span><br><span class="line"><span class="comment">//      cout &lt;&lt; iter-&gt;first &lt;&lt; &quot;:&quot; &lt;&lt; iter-&gt;second&lt;&lt;endl;   </span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;D://a.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">getline</span>(cin, s);</span><br><span class="line">        <span class="type">int</span> idx = s.<span class="built_in">find</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        string str1 = s.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">        string str2 = s.<span class="built_in">substr</span>(idx+<span class="number">1</span>);</span><br><span class="line">        myMap1.<span class="built_in">clear</span>();</span><br><span class="line">        myMap2.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">cal</span>(str1, myMap1);</span><br><span class="line">        <span class="built_in">cal</span>(str2, myMap2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(myMap1.<span class="built_in">size</span>() != myMap2.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;N\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> iter1 = myMap1.<span class="built_in">begin</span>(), iter2 = myMap2.<span class="built_in">begin</span>(); iter1 != myMap1.<span class="built_in">end</span>() &amp;&amp; iter2 != myMap2.<span class="built_in">end</span>(); ++iter1, ++iter2)&#123;</span><br><span class="line"><span class="comment">//              cout &lt;&lt; iter1-&gt;first &lt;&lt; &quot;:&quot; &lt;&lt; iter1-&gt;second&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//              cout &lt;&lt; iter2-&gt;first &lt;&lt; &quot;:&quot; &lt;&lt; iter2-&gt;second&lt;&lt;endl;</span></span><br><span class="line">                <span class="keyword">if</span>(iter1-&gt;first != iter2-&gt;first  iter1-&gt;second != iter2-&gt;second)&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Y\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;N\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次在第3题仍然采用不太明智的策略，则开始就考虑了多重括号嵌套的情况，然后代码写了很长时间，真的很长时间，因为一直没有理清思路。后来写完了，运行一直有问题，排错很长时间无效，最后又只能放弃后40%的测试用例，专心调试前60%的用例，很快就通过。所以，在这里需要注意的是，对于用例层层递进的情形，代码如果一时不能处理所有情况，也可以逐渐完善，先保证通过最简单的测试用例，再考虑其它情况。</p>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>可能是最后一次CCF，成绩离预期还是有点小差距，毕竟写题解的过程发现题目并不是很难，所以存在的问题还是要反省。 前一个半小时做完1，2，4题，后两个半小时做第3道题只得60分，对于时间利用率不高。做完1，2，4题大脑开始有点反应不过来（身体还是有点虚啊），第3题对于括号嵌套的情形迟迟没想清楚，导致代码Bug横生，如果及时调整思绪，从简单的情形做起，逐渐增加难度，完善代码，通过一重括号的测试用例应该没有问题。这里可以+20。第5题是大数模拟，听说水个20分没问题。用c++写个大数运算更应该没问题，只是麻烦，这里可以+20。最佳可达370+。 DEV的调试无法使用属于特殊情况，不应归咎。但个人的心态的调整，做题策略的更换，做题时间的分配却应该<strong>以时间，地点，条件为转移</strong>（巧妙将马克思原理应用于实践）。流水不腐，户枢不蠹。</p>
<h2 id="经验分享"><a href="#经验分享" class="headerlink" title="经验分享"></a>经验分享</h2><p><strong>针对C++</strong>： 1. 头文件用万能头文件避免include一堆其它头文件，带来记忆负担。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>
<ol>
<li>从文本读入数据，对于3， 4， 5题，题目的输入往往很长，而它的题目往往又是图片，不能用CV大法。这时，就能充分发挥文件读入的优势了。使用方法，在main函数的第一行加入以下代码<code>freopen(&quot;D://a.txt&quot;, &quot;r&quot;, stdin)</code>然后将数据粘贴进入D盘下的a.txt，这个路径可以自定义，然后运行的时候，直接从文件输入，输出仍在控制台。 注意：提交的时候<code>freopen(&quot;D://a.txt&quot;, &quot;r&quot;, stdin)</code>一行一定要注释掉，一定要注释掉，一定要注释掉，重要的事情说三遍，不然提交会是0分。 我常用的模板文件代码为：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;E://a.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>常用的stl的数据结构及函数一定要牢记，考试的时候能事半功倍。比如：数据结构：<code>map</code>（这次的2 3 题都有用到），<code>set</code>，<code>pair</code>，<code>stack</code>，<code>queue</code>（其中优先队列蛮香的），<code>string</code>， <code>vector</code>等。函数如<code>sort</code>(排序)，<code>binary_search</code>(二分查找)，<a href="https://zh.cppreference.com/w/cpp/header/cctype">cctype</a>的字符判断函数<code>isdigit</code>（是否为数字），<code>isupper</code>（是否为大写字母），<code>islower</code>（是否为小写字母）等，<code>stoi</code>（string转int），<code>atoi</code>（字符串转int），<code>sprintf</code>等。</li>
<li>c++11是真香的，里面有正则表达式，它能让字符串的处理更加简单。有<code>unordered_map</code>，<code>unordered_set</code>能有效解决查询超时的问题。</li>
<li>掌握常见的算法：<code>DFS</code>，<code>BFS</code>，<code>Prim</code>，<code>Dijstra</code>，<code>并查集</code>等，虽然最近几次考的第4题模拟都能做的，不会涉及算法。</li>
</ol>
<p><strong>针对CCF考试</strong>： 1. 做题策略：我一般是1 2 4 3的顺序，如果第3题的题意比较容易理解，容易模拟，可以先做。第5题可以过前面简单规模，简单逻辑的用例。 2. 考试的时候无任何反馈，类似于蓝桥杯，与pat的在线评测不同，所以对于1，2题需仔细设计测试用例，保证得满分。 3. 注意输入输出的格式， 这个有时候很致命，201903-2的中缀表达式的那一题，当时我一个同学就把乘号当成常见的<code>*</code>，实际是<code>x</code>（小写的x），结果可想而知。对于输出<code>YES</code>和<code>NO</code>的，稍有不慎，会看成<code>Yes</code>和<code>No</code>。 这种情况理应避免。 4. 平常多练，注重首次通过率。 我要分享就这么多，这次200+，满足毕业答辨的要求了，2019太过平淡无奇，也算完成了一个小目标。，明天继续一天一道 LeetCode打卡任务，暂时告别CCF。</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>CCF</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>计算理论学习笔记（一）</title>
    <url>/2020/01/05/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="确定性有穷自动机（DFA）"><a href="#确定性有穷自动机（DFA）" class="headerlink" title="确定性有穷自动机（DFA）"></a>确定性有穷自动机（DFA）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="/images/2020/01/878690a705b21453697f807fbd4dc483.png" alt=""> <strong>注意</strong>：允许没有接受状态，此时接受语言为空集；转移函数对每一个状态和每一个可能的输入都恰好指定了一个状态。 <img src="/images/2020/01/efcfdbecc5e9964a5c1fa943e341af90.png" alt=""> 定义正则运算的并、连结和星号 <img src="/images/2020/01/9fa80a1dc151df38b35818424fd504a3.png" alt=""> <strong>正则运算的并，连结和星号都是封闭的，后面在证明DFA与NFA等价后，会用NFA对其进行证明。</strong></p>
<h2 id="常见语言的DFA状态图举例"><a href="#常见语言的DFA状态图举例" class="headerlink" title="常见语言的DFA状态图举例"></a>常见语言的DFA状态图举例</h2><p><img src="/images/2020/01/fa79be91ff4b6fdd4589ecffe91fb161.png" alt=""> c题含某子串，首先画出对应的子串，然后再判断其它输入的状态转换即可。 f题不含某个子串，首先画出含某个子串的DFA，然后将接受态转为非接受态，将非接受态转为接受态。这里运用了DFA的补是封闭这一性质。 <img src="/images/2020/01/ad3e56368713da601dd85e71d64e222d.png" alt=""> 对于l这种类型的题即DFA的或和且运算，画图比较麻烦，有时采用横1纵0不失为一种好方法。 对于n的倍数余m，首先画出n个状态围成的圈，然后从起始状态数起，将第m个状态标为接受态即可。对于这道题有个变形。画出长度除以3余2且除以4余1的DFA，这里先用中国剩余定理求出长度规律为$12n+5(n = 0, 1, \cdots,)$也就是画出长度除以12余5的DFA。 注意：DFA一般不能对保证串中字符a与字符b相等，如$a^nb^n$不是正则语言，通过后面学习知道它是上下无关语言。但是它能表示一个很特殊的串，即串中01和10子串个数相等，它等价于串以相同的字符开始和结尾。（可以把01和10想象成波形图中的下升与下降，现在下升段与下降段相等，那么开始与结尾的值一定相等，同为0或同为1），DFA如图。 <img src="/images/2020/01/29068a7acdb87dcdf1b56496331a6eea.png" alt=""></p>
<h1 id="非确定性有穷自动机（NFA）"><a href="#非确定性有穷自动机（NFA）" class="headerlink" title="非确定性有穷自动机（NFA）"></a>非确定性有穷自动机（NFA）</h1><h2 id="NFA与DFA的不同："><a href="#NFA与DFA的不同：" class="headerlink" title="NFA与DFA的不同："></a>NFA与DFA的不同：</h2><ol>
<li>一入多出。NFA中一个状态对于每个符号可能有0个，1个或多个转换的箭头。而DFA中每一个状态对于每个符号有唯一的转换箭头（状态转换）</li>
<li>加入空漂。NFA的输入字符比DFA多了一个$\epsilon$，即空漂。 <img src="/images/2020/01/95117f4eeee2bba84da943ef17f6cc94.png" alt=""></li>
</ol>
<h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p><img src="/images/2020/01/1cb1aec89e5040e6a93904c49931dfff.png" alt=""> 与DFA的定义同为五元组，但仍存在一定差异。$\Sigma$中新增了$\epsilon$；$\delta$的映射结果属于状态集的幂集，即一入多出，同一个符号，可能对应多个状态转换。 <strong>注意</strong>：由于NFA加入非确定性，一个输入产生了多条路径，只要求所有路径中至少有一条路径能到达接受状态即可，这点与DFA也有所不同。</p>
<h2 id="DFA与NFA的等价性。"><a href="#DFA与NFA的等价性。" class="headerlink" title="DFA与NFA的等价性。"></a>DFA与NFA的等价性。</h2><p>首先DFA是特殊的NFA，即一入一出，没有空漂的NFA。 下面主要是将一个NFA转换成与之对应的DFA。 <img src="/images/2020/01/6c3a4698c35776d6a44ad4b6b57f6c8b.png" alt=""> 已知$DFA\space A = \lbrace Q,\Sigma, \delta, q_0, F\rbrace$，现在要构造出一台与之对应的$NFA\space B = \lbrace Q^{\prime},\Sigma^{\prime}, \delta^{\prime}, q_0^{\prime}, F^{\prime}\rbrace$ 首先原来的DFA有n个状态，那NFA有$2^n$个状态（即状态的组合）$Q^{\prime} = \lbrace Q_{00\dots0}, Q_{10\dots0},\cdots,Q_{11\dots1}\rbrace$，$\Sigma^{\prime}$很简单就为$\lbrace0,1\rbrace$，$\delta^{\prime}$要随$Q^{\prime}$相应的改变，多个状态经过相同的输入的结果要进行位与，最后接受态$F^{\prime}$含有$2^{n-1}$即只是含$q_1$即可（第一个二进制位为1）。这样就构造出一台DFA与NFA对应。 即证DFA与NFA是等价的。</p>
<h2 id="NFA证正则语言的并、连接、星号运算为封闭的。"><a href="#NFA证正则语言的并、连接、星号运算为封闭的。" class="headerlink" title="NFA证正则语言的并、连接、星号运算为封闭的。"></a>NFA证正则语言的并、连接、星号运算为封闭的。</h2><p><img src="/images/2020/01/22d15579c085b4a803186360f11cc93a.png" alt=""> 证明并运算，加入一个新的起始态，然后空漂到两台DFA的接受态即可。连接运算，将$M_1$中接受态全转为非接受态，然后将其空漂到$M_2$的起始态。星号运算，首先加入一个新的起始态（也是接受态）空漂到$M_1$的起始态，然后再将$M_1$的所有接受态空漂到新加入的起始态即可。</p>
<h1 id="正则表达式（RE）"><a href="#正则表达式（RE）" class="headerlink" title="正则表达式（RE）"></a>正则表达式（RE）</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p><img src="/images/2020/01/6bf0bbee71b49e5b3e24fd143ad13560.png" alt=""></p>
<h2 id="NFA转成RE"><a href="#NFA转成RE" class="headerlink" title="NFA转成RE"></a>NFA转成RE</h2><p><img src="/images/2020/01/bae061a56828c388645128e653d0df68.png" alt=""> 利用法则：用力拉首尾，拓扑变形，以星换圈，以并换多路，逐步减少内态。最后得到就是RE。具体可以参考书上46页的2张图。</p>
<h2 id="RE转成NFA"><a href="#RE转成NFA" class="headerlink" title="RE转成NFA"></a>RE转成NFA</h2><p><img src="/images/2020/01/6d163ac352353f47faa97bd101ba5c0f.png" alt=""> 从最小的子表达式到大一点的子表达式逐步建立，直到获得关于原始表达式的NFA. 所以NFA与RE是等价的.</p>
<h2 id="DFA-NFA与RE三者的关系"><a href="#DFA-NFA与RE三者的关系" class="headerlink" title="DFA,NFA与RE三者的关系"></a>DFA,NFA与RE三者的关系</h2><p>三者关系如图所求. <img src="/images/2020/01/d5a73102ce0660dbe2e80562b76fe39a.png" alt=""></p>
<h1 id="泵引理"><a href="#泵引理" class="headerlink" title="泵引理"></a>泵引理</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p><img src="/images/2020/01/0d3d366fbbf4546abf9f8f9d6df06bff.png" alt=""></p>
<h2 id="应用泵引理证明非正则语言"><a href="#应用泵引理证明非正则语言" class="headerlink" title="应用泵引理证明非正则语言"></a>应用泵引理证明非正则语言</h2><p>上述定义是一个正则语言的必要不充分条件，即如果一个语言是正则语言，则它一定满足泵引理。如果不满足泵引理，一定不是正则语言。 注意： 1. 泵引理只能用来证明非正则语言，不能证正则语言。 2. 泵引理只能将“相等”抽成“不等”，“是”抽成“不是”，不能反过来。可能先利用正则语言的交，并，补运算是封闭的，先进行转换。 下面是一些例子 <img src="/images/2020/01/f06c63f84809d8e892c27bc12b8e6b99.png" alt=""> <img src="/images/2020/01/0fa714b908171c1a30e23b9c3037280c.png" alt=""> 另外证明$1^{n^2}$或者$1^{2^p}$这种形式语言，可以在序列中相邻两串长度间隔在不能增大作文章，因为长度间隔的离散性，一定不能满足任意抽取均能满足原语言。</p>
<h1 id="笔记教材及答案"><a href="#笔记教材及答案" class="headerlink" title="笔记教材及答案"></a>笔记教材及答案</h1><p><a href="https://github.com/Onwaier/TheoryOfComputation">github地址</a></p>
]]></content>
      <categories>
        <category>计算理论学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>计算理论学习笔记（三）</title>
    <url>/2020/01/05/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="图灵机-TM"><a href="#图灵机-TM" class="headerlink" title="图灵机(TM)"></a>图灵机(TM)</h1><p>有穷自动机与图灵机区别：图灵机在带子上能写能读；读写头即能左移也能右移；带子无限长；进入拒绝和接受状态立即停机。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="/images/2020/01/84a808bba322c9b3c318f957745cd93c.png" alt=""> 格局 <img src="/images/2020/01/909d93620334e36470be7065f569f03c.png" alt=""> 图灵可判定：有限步骤内，可知结果是yes或者no. 图灵可识别：有限步骤内，可知结果是yes.对于no的可能进入死循环. 图灵可补识别：有限步骤内，可知结果是no.对于yes的可能进入死循环. 识别语言$0^{2^n}$的图灵机如图. <img src="/images/2020/01/6f0222fd64c99407776bb19e2d5a1b9e.png" alt=""> 每次减半，直到1个0结束。中间出现奇数个0且不为1个，则进入拒绝态。</p>
<h1 id="图灵可判定性"><a href="#图灵可判定性" class="headerlink" title="图灵可判定性"></a>图灵可判定性</h1><p><img src="/images/2020/01/83a5a5ea28d84514ff8205310442a94d.png" alt=""> $A_{DFA}$显然可判定，因为DFA对于每个输入的串要不进入接受态，要不进入拒绝态。$E_{DFA}$采用的是标记法，类似于图中遍历。因为正则语言对于交，并，补运算都是封闭的，所以$EQ_{DFA}$可以转成$E_{DFA}$，而$ALL_{DFA}$又能转成$EQ_{DFA}$ <img src="/images/2020/01/3a6e944d4255402044267e22e4deaa72.png" alt=""> CFG的相关的可判定性问题，很大程度上依赖于乔姆斯基范式。$A_{CFG}$使用乔姆斯基范式能有限步内（2n-1步）判断能否识别某串。$A_{\epsilon CFG}$直接借用$A_{CFG}$可判定的结论，来判断是否能派生$\epsilon$串。$E_CFG}$可判定同样采用标记法，不过是逆向标记。 <img src="/images/2020/01/df6eb8c0b8ae2f11f093c6de02ecb39c.png" alt=""> <img src="/images/2020/01/ff44fba5ca572953b412e24f554917fb.png" alt=""> 证明思路类似于$E_{CFG}$的证明.</p>
<h1 id="可归约性"><a href="#可归约性" class="headerlink" title="可归约性"></a>可归约性</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p><img src="/images/2020/01/9e83177900d7286309f5472945167ebe.png" alt=""> <img src="/images/2020/01/b80d55b806b5d62ed65bb7d98931c6da.png" alt=""> <img src="/images/2020/01/5e446e141fecbc78e5e5529f96a22b12.png" alt=""> <img src="/images/2020/01/453d67e1cdfe833b92c1e9f9984e84f3.png" alt=""> 证明$A_{TM}$不可判定，使用的是对角化方法。 <img src="/images/2020/01/da8f3e0db01133c9e3e599bf7f5c108a.png" alt=""> <img src="/images/2020/01/9be17d663e6c7fe752d24d5e79add161.png" alt=""></p>
<h1 id="笔记教材及答案"><a href="#笔记教材及答案" class="headerlink" title="笔记教材及答案"></a>笔记教材及答案</h1><p><a href="https://github.com/Onwaier/TheoryOfComputation">github地址</a></p>
]]></content>
      <categories>
        <category>计算理论学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>计算理论学习笔记（二）</title>
    <url>/2020/01/05/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="上下文无关文法-CFG"><a href="#上下文无关文法-CFG" class="headerlink" title="上下文无关文法(CFG)"></a>上下文无关文法(CFG)</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="/images/2020/01/ec257bf072e5678d3f6e4e49fbcc7bcf.png" alt=""> 前面提到的$0^n1^n$可以用上下文无关文法表示如下： $S\rarr 0S1\vert \epsilon$.</p>
<h2 id="设计CFG"><a href="#设计CFG" class="headerlink" title="设计CFG"></a>设计CFG</h2><p>CFG的设计很难对于多个简单CFG的合并或者语言本身是DFA都较容易设计。 <img src="/images/2020/01/efc4fed579db23874d4f6a61d77117cc.png" alt=""> <img src="/images/2020/01/d8977a48297675283310766f00739b48.png" alt=""> 有些很难的CFG是在一些基础的CFG上发展来的，所以需要记住一些常见的CFG的形式。 一些常见的CFG表示如图所求. <img src="/images/2020/01/a30d0f4e459ef5364c6b02104c40e7f4.png" alt=""></p>
<h2 id="乔姆斯基范式"><a href="#乔姆斯基范式" class="headerlink" title="乔姆斯基范式"></a>乔姆斯基范式</h2><p><img src="/images/2020/01/2471ecfff792ec2c259800fadd94198f.png" alt=""> 乔姆斯基范式有两个特点：一分为二；终级化. 将任意一个上下文无关文法转为乔姆斯基范式的步骤如下： 1. 引入新的起始变元 2. 删除$\epsilon$规则，相同的只替换一次，不循环替换 3. 去掉单一规则 4. 添加终结符规则 5. 添加新变元，使得所有变量规则都是一分为二 具体可参考65页的例3.7. 乔姆斯基范式有一个很重要的性质，在后面证$A_{CFG}$图灵可判定及多项式时间内判定某个串是否可以派生，都要用到乔姆斯基范式。因为乔姆斯基范式派生任何长为n的串，只需要$2n-1$步。 <img src="/images/2020/01/a283c02416ef3c6ba21f9dea11b28e4e.png" alt=""> 证明如图所求。 <img src="/images/2020/01/7e2620b45e8f33f0bd0eb1295dcc0a2b.png" alt=""></p>
<h1 id="下推自动机-PDA"><a href="#下推自动机-PDA" class="headerlink" title="下推自动机(PDA)"></a>下推自动机(PDA)</h1><p>下推自动机相比NFA多了一个栈（可以压入与弹出）。可以进行简单的串的数量的统计。</p>
<h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p><img src="/images/2020/01/72116a19c4f42dbd25530a15cfcc1937.png" alt=""></p>
<h2 id="常见的PDA"><a href="#常见的PDA" class="headerlink" title="常见的PDA"></a>常见的PDA</h2><p><img src="/images/2020/01/10a80d8fe531ce2a135c691b59eecef1.png" alt=""> <img src="/images/2020/01/7387be5de7a97d0c1d6f426efed369b1.png" alt=""> <img src="/images/2020/01/2edb78074b80d4843fe9fc4b8e787df1.png" alt=""></p>
<h1 id="泵引理"><a href="#泵引理" class="headerlink" title="泵引理"></a>泵引理</h1><p>与正则语言相同，上下文无关语言也有泵引理。</p>
<h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p><img src="/images/2020/01/32fd48d550914efeb1887ab76861d0d8.png" alt=""></p>
<h2 id="用泵引理证明非上下文无关语言"><a href="#用泵引理证明非上下文无关语言" class="headerlink" title="用泵引理证明非上下文无关语言"></a>用泵引理证明非上下文无关语言</h2><p><img src="/images/2020/01/1b2af2cdb4799406121220c0eddb5ca4.png" alt=""> “抽进”+“抽出” <img src="/images/2020/01/9f33594a5c9eeca7e7b7eac42401b0f6.png" alt=""> <strong>注意</strong>：上下文 无关语言对并运算是封闭的，而对交，补，差都不是封闭的.</p>
<h1 id="笔记教材及答案"><a href="#笔记教材及答案" class="headerlink" title="笔记教材及答案"></a>笔记教材及答案</h1><p><a href="https://github.com/Onwaier/TheoryOfComputation">github地址</a></p>
]]></content>
      <categories>
        <category>计算理论学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>调试运行ns2 lab22.tcl中遇到的问题</title>
    <url>/2019/12/01/%E8%B0%83%E8%AF%95%E8%BF%90%E8%A1%8Cns2-lab22-tcl%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>需要用到threshold来计算不同的无线传输模型的传输矩离，但使用gcc编译过程中出错。 首先进入ns文件夹下的<code>indep-utils/propagation</code>，我的路径是<code>/home/onwaier/ns-allinone-2.35_gcc482/ns-allinone-2.35/ns-2.35/indep-utils/propagation</code> 编辑命令为<code>g++ -lm threshold.cc -o threshold</code></p>
<h2 id="错误1-报错”threshold-cc-56-22-fatal-error-iostream-h-没有那个文件或目录”"><a href="#错误1-报错”threshold-cc-56-22-fatal-error-iostream-h-没有那个文件或目录”" class="headerlink" title="错误1 报错”threshold.cc:56:22: fatal error: iostream.h: 没有那个文件或目录”"></a>错误1 报错”threshold.cc:56:22: fatal error: iostream.h: 没有那个文件或目录”</h2><p>找到<code>#include&lt;iostream.h&gt;</code>这一行，把<code>#include&lt;iostream.h&gt;</code>修改为<code>#include&lt;iostream&gt;</code>,并添加命令空间std，代码为<code>using namespace std;</code> 编译再次出现新的错误</p>
<h2 id="错误2-报错”threshold-cc-211-30-error-‘strcmp’-was-not-declared-in-this-scope”"><a href="#错误2-报错”threshold-cc-211-30-error-‘strcmp’-was-not-declared-in-this-scope”" class="headerlink" title="错误2 报错”threshold.cc:211:30: error: ‘strcmp’ was not declared in this scope”"></a>错误2 报错”threshold.cc:211:30: error: ‘strcmp’ was not declared in this scope”</h2><p><code>strcmp</code>函数是关于字符串的操作，头文件为<code>#include&lt;string.h&gt;</code>，而文件中并未包含，加入<code>#include&lt;string.h&gt;</code>一行。 再次编译，没有报错，编译成功。 以Two Ray Ground，希望有效的传输距离为250m为例。 输入命令<code>./threshold -m TwoRayGround 250</code> 运行结果如图所示。 <img src="https://img-blog.csdnimg.cn/20191201154059892.png" alt="运行结果"> 执行命令<code>ns test_2nodes.tcl</code>出错，</p>
<h2 id="错误3-报错”invalid-command-name-“Agent-mUDP””"><a href="#错误3-报错”invalid-command-name-“Agent-mUDP””" class="headerlink" title="错误3 报错”invalid command name “Agent/mUDP””"></a>错误3 报错”invalid command name “Agent/mUDP””</h2><p>查询发现<strong>mUDP,mUdpSink,mTcpsink是NS2中没有的，是后来人写的。所以要使用此功能必须自行加入。</strong>下载mUDP, mUdpSink的文件，要下载的有下列几个文件 mudp.cc、mudp.h、mudpsink.cc、mudpsink.h。下载地址为:<a href="https://pan.baidu.com/s/1y8HluXPEQVDm8O8Ei34nNQ">百度网盘</a>，提取码为<code>65j6</code>。<a href="http://onwaier.com:7777/share/oywQUpGI">个人网盘</a>。 具体如何添加参照<a href="https://www.cnblogs.com/helloWaston/p/4549735.html">博客1</a>和<a href="http://blog.sina.com.cn/s/blog_4bb73ce80100m18r.html">博客2</a> 下面以我的路径（ns在<code>/home/onwaier</code>）来说明配置过程 1. 在<code>/home/onwaier/ns-allinone-2.35_gcc482/ns-allinone-2.35/ns-2.35</code>目录下新建文件夹，添加刚才下载的文件<code>mtcpsink.cc</code>、<code>mtcpsink.h</code>、<code>mudp.cc</code>、<code>mudp.h</code>、<code>mudpsink.cc</code>、<code>mudpsink.h</code>。 2. 修改<code>/home/onwaier/ns-allinone-2.35_gcc482/ns-allinone-2.35/ns-2.35/common/packet.h</code>，在<code>struct hdr_cmn&#123;&#125;</code>中添加以下代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> frametype_; <span class="comment">//added by smallko</span></span><br><span class="line"><span class="type">double</span>  sendtime_;  <span class="comment">// added by smallko</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> pkt_id_; <span class="comment">// added by smallko</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> frame_pkt_id_; <span class="comment">//added by smallko</span></span><br></pre></td></tr></table></figure>
<ol>
<li>修改<code>/home/onwaier/ns-allinone-2.35_gcc482/ns-allinone-2.35/ns-2.35/Makefile</code>,找到<code>OBJ_CC</code>这一行， 在其下行添加代码<code>measure/mtcpsink.o measure/mudp.o measure/mudpsink.o \</code>。注意Makefile对于语法要求很高，不能有空行或多余的空格。</li>
<li>修改<code>/home/onwaier/ns-allinone-2.35_gcc482/ns-allinone-2.35/ns-2.35/tcl/lib/ns-default.tcl</code>，找到<code>Delayer set debug_ false</code>这一行，在其下一行添加<code>Agent/mUDP set packetSize_ 1000</code>。</li>
<li>执行命令<code>./configure --with-tcl-ver=8.5;make clean;make</code> 出现新的错误。</li>
</ol>
<h2 id="错误4-报错”cannot-call-constructor-mUdpAgent-UdpAgent’-directly-fpermissive-“"><a href="#错误4-报错”cannot-call-constructor-mUdpAgent-UdpAgent’-directly-fpermissive-“" class="headerlink" title="错误4 报错”cannot call constructor mUdpAgent::UdpAgent’ directly [-fpermissive]“"></a>错误4 报错”cannot call constructor mUdpAgent::UdpAgent’ directly [-fpermissive]“</h2><ol>
<li>在makefile中加入以下<code>CCOPT = -Wall -Wno-write-strings -fpermissive</code></li>
<li>修改<code>measure/mudp.cc</code> 将代码</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mUdpAgent::<span class="built_in">mUdpAgent</span>() : <span class="built_in">id_</span>(<span class="number">0</span>), <span class="built_in">openfile</span>(<span class="number">0</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">        <span class="built_in">bind</span>(<span class="string">&quot;packetSize_&quot;</span>, &amp;size_);  </span><br><span class="line">       UdpAgent::<span class="built_in">UdpAgent</span>();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mUdpAgent::<span class="built_in">mUdpAgent</span>() :<span class="built_in">UdpAgent</span>(), <span class="built_in">id_</span>(<span class="number">0</span>), <span class="built_in">openfile</span>(<span class="number">0</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">        <span class="built_in">bind</span>(<span class="string">&quot;packetSize_&quot;</span>, &amp;size_);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>重新编译，运行通过。 但仍有上述问题<code>invalid command name &quot;Agent/mUDP&quot;</code> 尝试进入目录<code>/home/onwaier/ns-allinone-2.35_gcc482/ns-allinone-2.35</code>，执行<code>./install</code>，然后进入目录<code>/home/onwaier/ns-allinone-2.35_gcc482/ns-allinone-2.35/ns-2.35</code>执行<code>sudo make install</code>。 再次执行命令<code>ns test_2nodes.tcl</code>，运行结果为： <img src="https://img-blog.csdnimg.cn/2019120121585676.png" alt="执行结果"></p>
]]></content>
      <categories>
        <category>ns</category>
      </categories>
      <tags>
        <tag>ns2</tag>
      </tags>
  </entry>
  <entry>
    <title>释放GPU资源</title>
    <url>/2020/03/17/%E9%87%8A%E6%94%BEgpu%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://blog.csdn.net/u013241583/article/details/90174967">linux GPU查询和空闲时自动抢占脚本</a></li>
<li><a href="https://ptorch.com/news/161.html">pytorc使用后正确释放GPU内存以及检测GPU使用情况</a></li>
<li><a href="https://blog.csdn.net/liangdong2014/article/details/78860661">GPU 命令行释放内存</a></li>
</ol>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>一大早起来，看看实验室的服务器有没有空闲的GPU，仍被占的满满的，太难了。想着自己总不能这样一直盯着吧，能不能写个脚本自动检测空闲GPU并占用呢？于是查到<a href="https://blog.csdn.net/u013241583/article/details/90174967">资料1</a>，按照上面的提示，用命令<code>pip install gpustat</code>，安装了<code>gpustat</code>。然后在服务器上执行一下<code>gpustat</code>，发生了一件诡异的事。 <a href="/images/2020/03/4bddccd1896b50a72044d1fb5789393b.png"><img src="/images/2020/03/4bddccd1896b50a72044d1fb5789393b.png" alt=""></a> 第4块GPU的GPU显存占用了10066M，<code>GPU-Util Compute</code>却是0%（原来是0%，释放内存后恢复正常，这里对图片进行了修改）。昨天晚上我有一个在第4块GPU运行的程序异常退出，然后再次运行，发现GPU内存不够，当时以为有人跑了其它程序。现在看看，可能是主程序退出，子线程没有及时释放GPU资源，导致内存泄漏。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>参照[资料3]，先使用命令<code>fuser -v /dev/nvidia*</code>查找占用GPU资源的PID，然后用<code>kill -9 PID</code>杀死程序，再用<code>nvidia-smi</code>发现资源已经成功释放了。</p>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>非root用户编译安装GCC</title>
    <url>/2020/07/29/%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85gcc/</url>
    <content><![CDATA[<h1 id="非root用户编译安装GCC"><a href="#非root用户编译安装GCC" class="headerlink" title="非root用户编译安装GCC"></a>非root用户编译安装GCC</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://gcc.gnu.org/mirrors.html">源码下载地址</a></li>
<li><a href="[https://hpzhao.github.io/2016/07/19/%E9%9D%9Eroot%E6%9D%83%E9%99%90%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85GCC/](https://hpzhao.github.io/2016/07/19/非root权限源码安装GCC/">非root权限下源码安装GCC</a>)</li>
<li><a href="https://blog.csdn.net/qq_36573282/article/details/79762028">linux 没有root权限的用户安装GCC</a></li>
<li><a href="http://c.biancheng.net/view/7933.html">GCC编译器下载和安装教程（针对Linux发行版）</a></li>
<li><a href="https://gcc.gnu.org/pub/gcc/infrastructure/mpc-0.8.1.tar.gz">mpc-0.8.1下载地址</a></li>
</ol>
<h2 id="编译安装GCC"><a href="#编译安装GCC" class="headerlink" title="编译安装GCC"></a>编译安装GCC</h2><ol>
<li>下载GCC及其依赖的源码</li>
</ol>
<p>这里以gcc-6.5.0为例，下载解压。<code>tar -zxcf gcc-6.5.0.tar.gz</code> ，进入目录<code>cd gcc-6.5.0/contrib/</code>，查看文件<code>cat download_prerequisites</code>，查看依赖的版本号 <img src="https://raw.githubusercontent.com/onwaiers/Picture/master/img/20200729180617.png" alt="image-20200729163234221"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MPFR=mpfr-2.4.2</span><br><span class="line">GMP=gmp-4.3.2</span><br><span class="line">MPC=mpc-0.8.1</span><br></pre></td></tr></table></figure>
<p>然后在镜像网站下载指定版本依赖，其中mpc0.8.1在国内镜像网站没有找到，可以直接在<a href="https://gcc.gnu.org/pub/gcc/infrastructure/mpc-0.8.1.tar.gz">这里下载</a>。 解压命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf gmp-4.3.2.tar.gz</span><br><span class="line">tar -zxvf mpc-0.8.1.tar.gz</span><br><span class="line">tar -zxvf mpfr-2.4.2.tar.gz</span><br></pre></td></tr></table></figure>
<ol>
<li>编译安装</li>
</ol>
<p>根据参考资料，编译安装有两种方式， 一种是<a href="https://blog.csdn.net/qq_36573282/article/details/79762028">linux 没有root权限的用户安装GCC</a>，对gcc和依赖依次编译安装，这样做需要注意依赖的安装顺序。</p>
<blockquote>
<p>首先安装gmp、之后安装mpfr、最后安装mpc，因为它们之间有依赖关系。</p>
</blockquote>
<p>并且依赖项存在依赖时，还需要在编译时加上with选项。另一种是一起编译。</p>
<blockquote>
<p>把这三个依赖包拷贝到gcc源代码目录一块编译</p>
</blockquote>
<p>首先在gcc-6.5.0新建文件夹mpfr、gmp和mpc，然后将它们复制gcc源目录下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv gmp-4.3.2 gcc-6.5.0/gmp</span><br><span class="line">mv mpfr-2.4.2 gcc-6.5.0/mpfr</span><br><span class="line">mv mpc-0.8.1 gcc-6.5.0/mpc</span><br></pre></td></tr></table></figure>
<p>进入gcc-6.5.0目录，即<code>cd gcc-6.5.0</code>。 然后执行以下命令，分别生成makefile,编译，将文件复制到指定目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#生成MakeFile，换成立自己的绝对路径</span><br><span class="line">./configure --prefix=/home/ljj/.local --enable-checking=release --enable-languages=c,c++ --disable-multilib</span><br><span class="line">#编译，开启4个线程</span><br><span class="line">make -j4</span><br><span class="line">#拷贝到.local目录</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<ol>
<li>修改环境变量</li>
</ol>
<p>此时执行<code>gcc --version</code>显示的是 7.4.0. 修改<code>～/.bashrc</code>文件，在文件末尾添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=/home/ljj/.local/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>执行<code>source ~/.bashrc</code>，使修改生效. 再次执行<code>gcc --version</code>，显示的是6.5.0.</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>gcc编译安装</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo的基本用法</title>
    <url>/2022/08/27/hexo%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="创建hexo工程"><a href="#创建hexo工程" class="headerlink" title="创建hexo工程"></a>创建hexo工程</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure>
<p>使用hexo初始化hexo项目，将会创建一个文件夹blog</p>
<h2 id="新建post"><a href="#新建post" class="headerlink" title="新建post"></a>新建post</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">hexo new “HelloWorld”</span><br></pre></td></tr></table></figure>
<p>进入blog文件夹，创建名为HelloWorld.md文件，位置为<code>blog/sources/_posts/</code></p>
<h2 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate <span class="comment"># hexo g</span></span><br></pre></td></tr></table></figure>
<p>将Markdown格式的文件解析成可以使用浏览器查看的HTML文件，HTML文件存储在blog/public目录下。</p>
<h2 id="运行hexo服务器"><a href="#运行hexo服务器" class="headerlink" title="运行hexo服务器"></a>运行hexo服务器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server <span class="comment"># hexo s</span></span><br></pre></td></tr></table></figure>
<p>打开命令行提示的网址，便能查看我们的blog</p>
<p>如需修改 <strong>HelloWorld.md</strong>文件，只需直接编辑，然后再次执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate </span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d <span class="comment"># 需先执行hexo g 生成静态文件</span></span><br></pre></td></tr></table></figure>
<p>即可在公网访问到文章。</p>
<h2 id="创建草稿"><a href="#创建草稿" class="headerlink" title="创建草稿"></a>创建草稿</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new draft draft1</span><br></pre></td></tr></table></figure>
<p>创建名为draft1.md，在<code>blog/sources/_drafts</code></p>
<p>查看已有草稿</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo --draft</span><br></pre></td></tr></table></figure>
<h2 id="推送文章"><a href="#推送文章" class="headerlink" title="推送文章"></a>推送文章</h2><p>将草稿draft1.md转至<code>blog/sources/_drafts</code>，可执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo publish draft1</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
